import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isIndexedDBAvailable,
  isSafari,
  registerVersion
} from "./chunk-7FBG3CEV.js";
import "./chunk-RSJERJUL.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b2 = typeof a;
  b2 = "object" != b2 ? b2 : a ? Array.isArray(a) ? "array" : b2 : "null";
  return "array" == b2 || "object" == b2 && "number" == typeof a.length;
}
function p(a) {
  var b2 = typeof a;
  return "object" == b2 && null != a || "function" == b2;
}
function ca(a) {
  return Object.prototype.hasOwnProperty.call(a, da) && a[da] || (a[da] = ++ea);
}
var da = "closure_uid_" + (1e9 * Math.random() >>> 0);
var ea = 0;
function fa(a, b2, c) {
  return a.call.apply(a.bind, arguments);
}
function ha(a, b2, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b2, e);
    };
  }
  return function() {
    return a.apply(b2, arguments);
  };
}
function q(a, b2, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? q = fa : q = ha;
  return q.apply(null, arguments);
}
function ia(a, b2) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b2) {
  function c() {
  }
  c.prototype = b2.prototype;
  a.X = b2.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b2.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ja = 0;
var ka = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), 0 != ja)) {
    var a = ca(this);
    delete ka[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var la = Array.prototype.indexOf ? function(a, b2) {
  return Array.prototype.indexOf.call(a, b2, void 0);
} : function(a, b2) {
  if ("string" === typeof a)
    return "string" !== typeof b2 || 1 != b2.length ? -1 : a.indexOf(b2, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b2)
      return c;
  return -1;
};
function ma(a) {
  const b2 = a.length;
  if (0 < b2) {
    const c = Array(b2);
    for (let d = 0; d < b2; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function na(a, b2) {
  for (let c = 1; c < arguments.length; c++) {
    const d = arguments[c];
    if (ba(d)) {
      const e = a.length || 0, f = d.length || 0;
      a.length = e + f;
      for (let h = 0; h < f; h++)
        a[e + h] = d[h];
    } else
      a.push(d);
  }
}
function w(a, b2) {
  this.type = a;
  this.g = this.target = b2;
  this.defaultPrevented = false;
}
w.prototype.h = function() {
  this.defaultPrevented = true;
};
var oa = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b2 = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b2), l.removeEventListener("test", aa, b2);
  } catch (c) {
  }
  return a;
}();
function pa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var qa = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function ra(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
}
function sa() {
  var a = l.navigator;
  return a && (a = a.userAgent) ? a : "";
}
function x(a) {
  return -1 != sa().indexOf(a);
}
function ta(a) {
  ta[" "](a);
  return a;
}
ta[" "] = aa;
function ua(a) {
  var b2 = va;
  return Object.prototype.hasOwnProperty.call(b2, 9) ? b2[9] : b2[9] = a(9);
}
var wa = x("Opera");
var y = x("Trident") || x("MSIE");
var xa = x("Edge");
var ya = xa || y;
var za = x("Gecko") && !(-1 != sa().toLowerCase().indexOf("webkit") && !x("Edge")) && !(x("Trident") || x("MSIE")) && !x("Edge");
var Aa = -1 != sa().toLowerCase().indexOf("webkit") && !x("Edge");
function Ba() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Ea;
a: {
  Fa2 = "", Ga2 = function() {
    var a = sa();
    if (za)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (xa)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (Aa)
      return /WebKit\/(\S+)/.exec(a);
    if (wa)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Ga2 && (Fa2 = Ga2 ? Ga2[1] : "");
  if (y) {
    Ha2 = Ba();
    if (null != Ha2 && Ha2 > parseFloat(Fa2)) {
      Ea = String(Ha2);
      break a;
    }
  }
  Ea = Fa2;
}
var Fa2;
var Ga2;
var Ha2;
var va = {};
function Ia() {
  return ua(function() {
    let a = 0;
    const b2 = qa(String(Ea)).split("."), c = qa("9").split("."), d = Math.max(b2.length, c.length);
    for (let h = 0; 0 == a && h < d; h++) {
      var e = b2[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (0 == e[0].length && 0 == f[0].length)
          break;
        a = ra(0 == e[1].length ? 0 : parseInt(e[1], 10), 0 == f[1].length ? 0 : parseInt(f[1], 10)) || ra(0 == e[2].length, 0 == f[2].length) || ra(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (0 == a);
    }
    return 0 <= a;
  });
}
var Ja;
if (l.document && y) {
  Ka2 = Ba();
  Ja = Ka2 ? Ka2 : parseInt(Ea, 10) || void 0;
} else
  Ja = void 0;
var Ka2;
var La = Ja;
function z(a, b2) {
  w.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b2;
    if (b2 = a.relatedTarget) {
      if (za) {
        a: {
          try {
            ta(b2.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b2 = null);
      }
    } else
      "mouseover" == c ? b2 = a.fromElement : "mouseout" == c && (b2 = a.toElement);
    this.relatedTarget = b2;
    d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = "string" === typeof a.pointerType ? a.pointerType : Ma[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && z.X.h.call(this);
  }
}
t(z, w);
var Ma = { 2: "touch", 3: "pen", 4: "mouse" };
z.prototype.h = function() {
  z.X.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var A = "closure_listenable_" + (1e6 * Math.random() | 0);
var Na = 0;
function Oa(a, b2, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b2;
  this.type = c;
  this.capture = !!d;
  this.ha = e;
  this.key = ++Na;
  this.ba = this.ea = false;
}
function Pa(a) {
  a.ba = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ha = null;
}
function Qa(a, b2, c) {
  for (const d in a)
    b2.call(c, a[d], d, a);
}
function Ra(a) {
  const b2 = {};
  for (const c in a)
    b2[c] = a[c];
  return b2;
}
var Sa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Ta(a, b2) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < Sa.length; f++)
      c = Sa[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ua(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
Ua.prototype.add = function(a, b2, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = Va(a, b2, d, e);
  -1 < h ? (b2 = a[h], c || (b2.ea = false)) : (b2 = new Oa(b2, this.src, f, !!d, e), b2.ea = c, a.push(b2));
  return b2;
};
function Wa(a, b2) {
  var c = b2.type;
  if (c in a.g) {
    var d = a.g[c], e = la(d, b2), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Pa(b2), 0 == a.g[c].length && (delete a.g[c], a.h--));
  }
}
function Va(a, b2, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ba && f.listener == b2 && f.capture == !!c && f.ha == d)
      return e;
  }
  return -1;
}
var Xa = "closure_lm_" + (1e6 * Math.random() | 0);
var Ya = {};
function $a(a, b2, c, d, e) {
  if (d && d.once)
    return ab(a, b2, c, d, e);
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      $a(a, b2[f], c, d, e);
    return null;
  }
  c = bb(c);
  return a && a[A] ? a.N(b2, c, p(d) ? !!d.capture : !!d, e) : cb(a, b2, c, false, d, e);
}
function cb(a, b2, c, d, e, f) {
  if (!b2)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = db(a);
  n || (a[Xa] = n = new Ua(a));
  c = n.add(b2, c, d, h, f);
  if (c.proxy)
    return c;
  d = eb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    oa || (e = h), void 0 === e && (e = false), a.addEventListener(b2.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(fb(b2.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function eb() {
  function a(c) {
    return b2.call(a.src, a.listener, c);
  }
  const b2 = gb;
  return a;
}
function ab(a, b2, c, d, e) {
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      ab(a, b2[f], c, d, e);
    return null;
  }
  c = bb(c);
  return a && a[A] ? a.O(b2, c, p(d) ? !!d.capture : !!d, e) : cb(a, b2, c, true, d, e);
}
function hb(a, b2, c, d, e) {
  if (Array.isArray(b2))
    for (var f = 0; f < b2.length; f++)
      hb(a, b2[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = bb(c), a && a[A]) ? (a = a.i, b2 = String(b2).toString(), b2 in a.g && (f = a.g[b2], c = Va(f, c, d, e), -1 < c && (Pa(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.g[b2], a.h--)))) : a && (a = db(a)) && (b2 = a.g[b2.toString()], a = -1, b2 && (a = Va(b2, c, d, e)), (c = -1 < a ? b2[a] : null) && ib(c));
}
function ib(a) {
  if ("number" !== typeof a && a && !a.ba) {
    var b2 = a.src;
    if (b2 && b2[A])
      Wa(b2.i, a);
    else {
      var c = a.type, d = a.proxy;
      b2.removeEventListener ? b2.removeEventListener(c, d, a.capture) : b2.detachEvent ? b2.detachEvent(fb(c), d) : b2.addListener && b2.removeListener && b2.removeListener(d);
      (c = db(b2)) ? (Wa(c, a), 0 == c.h && (c.src = null, b2[Xa] = null)) : Pa(a);
    }
  }
}
function fb(a) {
  return a in Ya ? Ya[a] : Ya[a] = "on" + a;
}
function gb(a, b2) {
  if (a.ba)
    a = true;
  else {
    b2 = new z(b2, this);
    var c = a.listener, d = a.ha || a.src;
    a.ea && ib(a);
    a = c.call(d, b2);
  }
  return a;
}
function db(a) {
  a = a[Xa];
  return a instanceof Ua ? a : null;
}
var jb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function bb(a) {
  if ("function" === typeof a)
    return a;
  a[jb] || (a[jb] = function(b2) {
    return a.handleEvent(b2);
  });
  return a[jb];
}
function B() {
  v.call(this);
  this.i = new Ua(this);
  this.P = this;
  this.I = null;
}
t(B, v);
B.prototype[A] = true;
B.prototype.removeEventListener = function(a, b2, c, d) {
  hb(this, a, b2, c, d);
};
function C(a, b2) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b2.type || b2;
  if ("string" === typeof b2)
    b2 = new w(b2, a);
  else if (b2 instanceof w)
    b2.target = b2.target || a;
  else {
    var e = b2;
    b2 = new w(d, a);
    Ta(b2, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b2.g = c[f];
      e = kb(h, d, true, b2) && e;
    }
  h = b2.g = a;
  e = kb(h, d, true, b2) && e;
  e = kb(h, d, false, b2) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b2.g = c[f], e = kb(h, d, false, b2) && e;
}
B.prototype.M = function() {
  B.X.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Pa(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
B.prototype.N = function(a, b2, c, d) {
  return this.i.add(String(a), b2, false, c, d);
};
B.prototype.O = function(a, b2, c, d) {
  return this.i.add(String(a), b2, true, c, d);
};
function kb(a, b2, c, d) {
  b2 = a.i.g[String(b2)];
  if (!b2)
    return true;
  b2 = b2.concat();
  for (var e = true, f = 0; f < b2.length; ++f) {
    var h = b2[f];
    if (h && !h.ba && h.capture == c) {
      var n = h.listener, u = h.ha || h.src;
      h.ea && Wa(a.i, h);
      e = false !== n.call(u, d) && e;
    }
  }
  return e && !d.defaultPrevented;
}
var lb = l.JSON.stringify;
function mb() {
  var a = nb;
  let b2 = null;
  a.g && (b2 = a.g, a.g = a.g.next, a.g || (a.h = null), b2.next = null);
  return b2;
}
var ob = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b2) {
    const c = pb.get();
    c.set(a, b2);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var pb = new class {
  constructor(a, b2) {
    this.i = a;
    this.j = b2;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new qb(), (a) => a.reset());
var qb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b2) {
    this.h = a;
    this.g = b2;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function rb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function sb(a, b2) {
  ub || vb();
  wb || (ub(), wb = true);
  nb.add(a, b2);
}
var ub;
function vb() {
  var a = l.Promise.resolve(void 0);
  ub = function() {
    a.then(xb);
  };
}
var wb = false;
var nb = new ob();
function xb() {
  for (var a; a = mb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      rb(c);
    }
    var b2 = pb;
    b2.j(a);
    100 > b2.h && (b2.h++, a.next = b2.g, b2.g = a);
  }
  wb = false;
}
function yb(a, b2) {
  B.call(this);
  this.h = a || 1;
  this.g = b2 || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(yb, B);
k = yb.prototype;
k.ca = false;
k.R = null;
k.kb = function() {
  if (this.ca) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.R = this.g.setTimeout(this.j, this.h - a) : (this.R && (this.g.clearTimeout(this.R), this.R = null), C(this, "tick"), this.ca && (zb(this), this.start()));
  }
};
k.start = function() {
  this.ca = true;
  this.R || (this.R = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function zb(a) {
  a.ca = false;
  a.R && (a.g.clearTimeout(a.R), a.R = null);
}
k.M = function() {
  yb.X.M.call(this);
  zb(this);
  delete this.g;
};
function Ab(a, b2, c) {
  if ("function" === typeof a)
    c && (a = q(a, c));
  else if (a && "function" == typeof a.handleEvent)
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b2) ? -1 : l.setTimeout(a, b2 || 0);
}
function Bb(a) {
  a.g = Ab(() => {
    a.g = null;
    a.i && (a.i = false, Bb(a));
  }, a.j);
  const b2 = a.h;
  a.h = null;
  a.m.apply(null, b2);
}
var Cb = class extends v {
  constructor(a, b2) {
    super();
    this.m = a;
    this.j = b2;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Bb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function D(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(D, v);
var Db = [];
function Eb(a, b2, c, d) {
  Array.isArray(c) || (c && (Db[0] = c.toString()), c = Db);
  for (var e = 0; e < c.length; e++) {
    var f = $a(b2, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Fb(a) {
  Qa(a.g, function(b2, c) {
    this.g.hasOwnProperty(c) && ib(b2);
  }, a);
  a.g = {};
}
D.prototype.M = function() {
  D.X.M.call(this);
  Fb(this);
};
D.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Gb() {
  this.g = true;
}
Gb.prototype.Aa = function() {
  this.g = false;
};
function Hb(a, b2, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var F2 = r.split("_");
            h = 2 <= F2.length && "type" == F2[1] ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b2 + "\n" + c + "\n" + h;
  });
}
function Ib(a, b2, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b2 + "\n" + c + "\n" + f + " " + h;
  });
}
function E(a, b2, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b2 + "): " + Jb(a, c) + (d ? " " + d : "");
  });
}
function Kb(a, b2) {
  a.info(function() {
    return "TIMEOUT: " + b2;
  });
}
Gb.prototype.info = function() {
};
function Jb(a, b2) {
  if (!a.g)
    return b2;
  if (!b2)
    return null;
  try {
    var c = JSON.parse(b2);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if ("noop" != f && "stop" != f && "close" != f)
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return lb(c);
  } catch (n) {
    return b2;
  }
}
var G = {};
var Lb = null;
function Mb() {
  return Lb = Lb || new B();
}
G.Oa = "serverreachability";
function Nb(a) {
  w.call(this, G.Oa, a);
}
t(Nb, w);
function H(a) {
  const b2 = Mb();
  C(b2, new Nb(b2, a));
}
G.STAT_EVENT = "statevent";
function Ob(a, b2) {
  w.call(this, G.STAT_EVENT, a);
  this.stat = b2;
}
t(Ob, w);
function I(a) {
  const b2 = Mb();
  C(b2, new Ob(b2, a));
}
G.Pa = "timingevent";
function Pb(a, b2) {
  w.call(this, G.Pa, a);
  this.size = b2;
}
t(Pb, w);
function J(a, b2) {
  if ("function" !== typeof a)
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b2);
}
var Qb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, La: 7, TIMEOUT: 8, Cb: 9 };
var Rb = { qb: "complete", Mb: "success", Ma: "error", La: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Sb() {
}
Sb.prototype.h = null;
function Tb(a) {
  return a.h || (a.h = a.i());
}
function Ub() {
}
var K = { OPEN: "a", pb: "b", Ma: "c", Bb: "d" };
function Vb() {
  w.call(this, "d");
}
t(Vb, w);
function Wb() {
  w.call(this, "c");
}
t(Wb, w);
var Xb;
function Yb() {
}
t(Yb, Sb);
Yb.prototype.g = function() {
  return new XMLHttpRequest();
};
Yb.prototype.i = function() {
  return {};
};
Xb = new Yb();
function L(a, b2, c, d) {
  this.l = a;
  this.j = b2;
  this.m = c;
  this.U = d || 1;
  this.S = new D(this);
  this.O = Zb;
  a = ya ? 125 : void 0;
  this.T = new yb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.V = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.Y = -1;
  this.I = false;
  this.N = 0;
  this.L = null;
  this.$ = this.J = this.Z = this.P = false;
  this.h = new $b();
}
function $b() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var Zb = 45e3;
var ac = {};
var bc = {};
k = L.prototype;
k.setTimeout = function(a) {
  this.O = a;
};
function cc(a, b2, c) {
  a.K = 1;
  a.v = dc(M(b2));
  a.s = c;
  a.P = true;
  ec(a, null);
}
function ec(a, b2) {
  a.F = Date.now();
  N(a);
  a.A = M(a.v);
  var c = a.A, d = a.U;
  Array.isArray(d) || (d = [String(d)]);
  fc(c.i, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new $b();
  a.g = gc(a.l, c ? b2 : null, !a.s);
  0 < a.N && (a.L = new Cb(q(a.Ka, a, a.g), a.N));
  Eb(a.S, a.g, "readystatechange", a.hb);
  b2 = a.H ? Ra(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b2["Content-Type"] = "application/x-www-form-urlencoded", a.g.da(a.A, a.u, a.s, b2)) : (a.u = "GET", a.g.da(a.A, a.u, null, b2));
  H(1);
  Hb(a.j, a.u, a.A, a.m, a.U, a.s);
}
k.hb = function(a) {
  a = a.target;
  const b2 = this.L;
  b2 && 3 == O(a) ? b2.l() : this.Ka(a);
};
k.Ka = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b2 = this.g.Ea();
        const F2 = this.g.aa();
        if (!(3 > r) && (3 != r || ya || this.g && (this.h.h || this.g.fa() || hc(this.g)))) {
          this.I || 4 != r || 7 == b2 || (8 == b2 || 0 >= F2 ? H(3) : H(2));
          ic(this);
          var c = this.g.aa();
          this.Y = c;
          b:
            if (jc(this)) {
              var d = hc(this.g);
              a = "";
              var e = d.length, f = 4 == O(this.g);
              if (!this.h.i) {
                if ("undefined" === typeof TextDecoder) {
                  P(this);
                  Q(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b2 = 0; b2 < e; b2++)
                this.h.h = true, a += this.h.i.decode(d[b2], { stream: f && b2 == e - 1 });
              d.splice(
                0,
                e
              );
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.fa();
          this.i = 200 == c;
          Ib(this.j, this.u, this.A, this.m, this.U, r, c);
          if (this.i) {
            if (this.Z && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !pa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                E(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, kc(this, c);
              else {
                this.i = false;
                this.o = 3;
                I(12);
                P(this);
                Q(this);
                break a;
              }
            }
            this.P ? (lc(this, r, h), ya && this.i && 3 == r && (Eb(this.S, this.T, "tick", this.gb), this.T.start())) : (E(this.j, this.m, h, null), kc(this, h));
            4 == r && P(this);
            this.i && !this.I && (4 == r ? mc(this.l, this) : (this.i = false, N(this)));
          } else
            400 == c && 0 < h.indexOf("Unknown SID") ? (this.o = 3, I(12)) : (this.o = 0, I(13)), P(this), Q(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function jc(a) {
  return a.g ? "GET" == a.u && 2 != a.K && a.l.Da : false;
}
function lc(a, b2, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = nc(a, c), e == bc) {
      4 == b2 && (a.o = 4, I(14), d = false);
      E(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == ac) {
      a.o = 4;
      I(15);
      E(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      E(a.j, a.m, e, null), kc(a, e);
  jc(a) && e != bc && e != ac && (a.h.g = "", a.C = 0);
  4 != b2 || 0 != c.length || a.h.h || (a.o = 1, I(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.$ && (a.$ = true, b2 = a.l, b2.g == a && b2.$ && !b2.K && (b2.j.info("Great, no buffering proxy detected. Bytes received: " + c.length), oc(b2), b2.K = true, I(11))) : (E(
    a.j,
    a.m,
    c,
    "[Invalid Chunked Response]"
  ), P(a), Q(a));
}
k.gb = function() {
  if (this.g) {
    var a = O(this.g), b2 = this.g.fa();
    this.C < b2.length && (ic(this), lc(this, a, b2), this.i && 4 != a && N(this));
  }
};
function nc(a, b2) {
  var c = a.C, d = b2.indexOf("\n", c);
  if (-1 == d)
    return bc;
  c = Number(b2.substring(c, d));
  if (isNaN(c))
    return ac;
  d += 1;
  if (d + c > b2.length)
    return bc;
  b2 = b2.substr(d, c);
  a.C = d + c;
  return b2;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function N(a) {
  a.V = Date.now() + a.O;
  pc(a, a.O);
}
function pc(a, b2) {
  if (null != a.B)
    throw Error("WatchDog timer not null");
  a.B = J(q(a.fb, a), b2);
}
function ic(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.fb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.V ? (Kb(this.j, this.A), 2 != this.K && (H(3), I(17)), P(this), this.o = 2, Q(this)) : pc(this, this.V - a);
};
function Q(a) {
  0 == a.l.G || a.I || mc(a.l, a);
}
function P(a) {
  ic(a);
  var b2 = a.L;
  b2 && "function" == typeof b2.na && b2.na();
  a.L = null;
  zb(a.T);
  Fb(a.S);
  a.g && (b2 = a.g, a.g = null, b2.abort(), b2.na());
}
function kc(a, b2) {
  try {
    var c = a.l;
    if (0 != c.G && (c.g == a || qc(c.h, a))) {
      if (!a.J && qc(c.h, a) && 3 == c.G) {
        try {
          var d = c.Fa.g.parse(b2);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && 3 == d.length) {
          var e = d;
          if (0 == e[0])
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    rc(c), sc(c);
                  else
                    break a;
                tc(c);
                I(18);
              }
            }
          else
            c.Ba = e[1], 0 < c.Ba - c.T && 37500 > e[2] && c.L && 0 == c.A && !c.v && (c.v = J(q(c.bb, c), 6e3));
          if (1 >= uc(c.h) && c.ja) {
            try {
              c.ja();
            } catch (m) {
            }
            c.ja = void 0;
          }
        } else
          R(c, 11);
      } else if ((a.J || c.g == a) && rc(c), !pa(b2))
        for (e = c.Fa.g.parse(b2), b2 = 0; b2 < e.length; b2++) {
          let m = e[b2];
          c.T = m[0];
          m = m[1];
          if (2 == c.G)
            if ("c" == m[0]) {
              c.I = m[1];
              c.ka = m[2];
              const r = m[3];
              null != r && (c.ma = r, c.j.info("VER=" + c.ma));
              const F2 = m[4];
              null != F2 && (c.Ca = F2, c.j.info("SVER=" + c.Ca));
              const Ca2 = m[5];
              null != Ca2 && "number" === typeof Ca2 && 0 < Ca2 && (d = 1.5 * Ca2, c.J = d, c.j.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const Z2 = a.g;
              if (Z2) {
                const Da2 = Z2.g ? Z2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Da2) {
                  var f = d.h;
                  f.g || -1 == Da2.indexOf("spdy") && -1 == Da2.indexOf("quic") && -1 == Da2.indexOf("h2") || (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (vc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const tb = Z2.g ? Z2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  tb && (d.za = tb, S(d.F, d.D, tb));
                }
              }
              c.G = 3;
              c.l && c.l.xa();
              c.$ && (c.P = Date.now() - a.F, c.j.info("Handshake RTT: " + c.P + "ms"));
              d = c;
              var h = a;
              d.sa = wc(d, d.H ? d.ka : null, d.V);
              if (h.J) {
                xc(d.h, h);
                var n = h, u = d.J;
                u && n.setTimeout(u);
                n.B && (ic(n), N(n));
                d.g = h;
              } else
                yc(d);
              0 < c.i.length && zc(c);
            } else
              "stop" != m[0] && "close" != m[0] || R(c, 7);
          else
            3 == c.G && ("stop" == m[0] || "close" == m[0] ? "stop" == m[0] ? R(c, 7) : Ac(c) : "noop" != m[0] && c.l && c.l.wa(m), c.A = 0);
        }
    }
    H(4);
  } catch (m) {
  }
}
function Bc(a) {
  if (a.W && "function" == typeof a.W)
    return a.W();
  if ("undefined" !== typeof Map && a instanceof Map || "undefined" !== typeof Set && a instanceof Set)
    return Array.from(a.values());
  if ("string" === typeof a)
    return a.split("");
  if (ba(a)) {
    for (var b2 = [], c = a.length, d = 0; d < c; d++)
      b2.push(a[d]);
    return b2;
  }
  b2 = [];
  c = 0;
  for (d in a)
    b2[c++] = a[d];
  return b2;
}
function Cc(a) {
  if (a.oa && "function" == typeof a.oa)
    return a.oa();
  if (!a.W || "function" != typeof a.W) {
    if ("undefined" !== typeof Map && a instanceof Map)
      return Array.from(a.keys());
    if (!("undefined" !== typeof Set && a instanceof Set)) {
      if (ba(a) || "string" === typeof a) {
        var b2 = [];
        a = a.length;
        for (var c = 0; c < a; c++)
          b2.push(c);
        return b2;
      }
      b2 = [];
      c = 0;
      for (const d in a)
        b2[c++] = d;
      return b2;
    }
  }
}
function Dc(a, b2) {
  if (a.forEach && "function" == typeof a.forEach)
    a.forEach(b2, void 0);
  else if (ba(a) || "string" === typeof a)
    Array.prototype.forEach.call(a, b2, void 0);
  else
    for (var c = Cc(a), d = Bc(a), e = d.length, f = 0; f < e; f++)
      b2.call(void 0, d[f], c && c[f], a);
}
var Ec = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
function Fc(a, b2) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b2(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function T(a, b2) {
  this.g = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.h = false;
  if (a instanceof T) {
    this.h = void 0 !== b2 ? b2 : a.h;
    Gc(this, a.j);
    this.s = a.s;
    this.g = a.g;
    Hc(this, a.m);
    this.l = a.l;
    b2 = a.i;
    var c = new Ic();
    c.i = b2.i;
    b2.g && (c.g = new Map(b2.g), c.h = b2.h);
    Jc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Ec)) ? (this.h = !!b2, Gc(this, c[1] || "", true), this.s = Kc(c[2] || ""), this.g = Kc(c[3] || "", true), Hc(this, c[4]), this.l = Kc(c[5] || "", true), Jc(this, c[6] || "", true), this.o = Kc(c[7] || "")) : (this.h = !!b2, this.i = new Ic(null, this.h));
}
T.prototype.toString = function() {
  var a = [], b2 = this.j;
  b2 && a.push(Lc(b2, Mc, true), ":");
  var c = this.g;
  if (c || "file" == b2)
    a.push("//"), (b2 = this.s) && a.push(Lc(b2, Mc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, null != c && a.push(":", String(c));
  if (c = this.l)
    this.g && "/" != c.charAt(0) && a.push("/"), a.push(Lc(c, "/" == c.charAt(0) ? Nc : Oc, true));
  (c = this.i.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Lc(c, Pc));
  return a.join("");
};
function M(a) {
  return new T(a);
}
function Gc(a, b2, c) {
  a.j = c ? Kc(b2, true) : b2;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Hc(a, b2) {
  if (b2) {
    b2 = Number(b2);
    if (isNaN(b2) || 0 > b2)
      throw Error("Bad port number " + b2);
    a.m = b2;
  } else
    a.m = null;
}
function Jc(a, b2, c) {
  b2 instanceof Ic ? (a.i = b2, Qc(a.i, a.h)) : (c || (b2 = Lc(b2, Rc)), a.i = new Ic(b2, a.h));
}
function S(a, b2, c) {
  a.i.set(b2, c);
}
function dc(a) {
  S(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function Kc(a, b2) {
  return a ? b2 ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Lc(a, b2, c) {
  return "string" === typeof a ? (a = encodeURI(a).replace(b2, Sc), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function Sc(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Mc = /[#\/\?@]/g;
var Oc = /[#\?:]/g;
var Nc = /[#\?]/g;
var Rc = /[#\?@]/g;
var Pc = /#/g;
function Ic(a, b2) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b2;
}
function U(a) {
  a.g || (a.g = /* @__PURE__ */ new Map(), a.h = 0, a.i && Fc(a.i, function(b2, c) {
    a.add(decodeURIComponent(b2.replace(/\+/g, " ")), c);
  }));
}
k = Ic.prototype;
k.add = function(a, b2) {
  U(this);
  this.i = null;
  a = V(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b2);
  this.h += 1;
  return this;
};
function Tc(a, b2) {
  U(a);
  b2 = V(a, b2);
  a.g.has(b2) && (a.i = null, a.h -= a.g.get(b2).length, a.g.delete(b2));
}
function Uc(a, b2) {
  U(a);
  b2 = V(a, b2);
  return a.g.has(b2);
}
k.forEach = function(a, b2) {
  U(this);
  this.g.forEach(function(c, d) {
    c.forEach(function(e) {
      a.call(b2, e, d, this);
    }, this);
  }, this);
};
k.oa = function() {
  U(this);
  const a = Array.from(this.g.values()), b2 = Array.from(this.g.keys()), c = [];
  for (let d = 0; d < b2.length; d++) {
    const e = a[d];
    for (let f = 0; f < e.length; f++)
      c.push(b2[d]);
  }
  return c;
};
k.W = function(a) {
  U(this);
  let b2 = [];
  if ("string" === typeof a)
    Uc(this, a) && (b2 = b2.concat(this.g.get(V(this, a))));
  else {
    a = Array.from(this.g.values());
    for (let c = 0; c < a.length; c++)
      b2 = b2.concat(a[c]);
  }
  return b2;
};
k.set = function(a, b2) {
  U(this);
  this.i = null;
  a = V(this, a);
  Uc(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b2]);
  this.h += 1;
  return this;
};
k.get = function(a, b2) {
  if (!a)
    return b2;
  a = this.W(a);
  return 0 < a.length ? String(a[0]) : b2;
};
function fc(a, b2, c) {
  Tc(a, b2);
  0 < c.length && (a.i = null, a.g.set(V(a, b2), ma(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  const a = [], b2 = Array.from(this.g.keys());
  for (var c = 0; c < b2.length; c++) {
    var d = b2[c];
    const f = encodeURIComponent(String(d)), h = this.W(d);
    for (d = 0; d < h.length; d++) {
      var e = f;
      "" !== h[d] && (e += "=" + encodeURIComponent(String(h[d])));
      a.push(e);
    }
  }
  return this.i = a.join("&");
};
function V(a, b2) {
  b2 = String(b2);
  a.j && (b2 = b2.toLowerCase());
  return b2;
}
function Qc(a, b2) {
  b2 && !a.j && (U(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (Tc(this, d), fc(this, e, c));
  }, a));
  a.j = b2;
}
var Vc = class {
  constructor(a, b2) {
    this.h = a;
    this.g = b2;
  }
};
function Wc(a) {
  this.l = a || Xc;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(l.g && l.g.Ga && l.g.Ga() && l.g.Ga().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var Xc = 10;
function Yc(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function uc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function qc(a, b2) {
  return a.h ? a.h == b2 : a.g ? a.g.has(b2) : false;
}
function vc(a, b2) {
  a.g ? a.g.add(b2) : a.h = b2;
}
function xc(a, b2) {
  a.h && a.h == b2 ? a.h = null : a.g && a.g.has(b2) && a.g.delete(b2);
}
Wc.prototype.cancel = function() {
  this.i = Zc(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && 0 !== this.g.size) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function Zc(a) {
  if (null != a.h)
    return a.i.concat(a.h.D);
  if (null != a.g && 0 !== a.g.size) {
    let b2 = a.i;
    for (const c of a.g.values())
      b2 = b2.concat(c.D);
    return b2;
  }
  return ma(a.i);
}
function $c() {
}
$c.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
$c.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ad() {
  this.g = new $c();
}
function bd(a, b2, c) {
  const d = c || "";
  try {
    Dc(a, function(e, f) {
      let h = e;
      p(e) && (h = lb(e));
      b2.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b2.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function cd(a, b2) {
  const c = new Gb();
  if (l.Image) {
    const d = new Image();
    d.onload = ia(dd, c, d, "TestLoadImage: loaded", true, b2);
    d.onerror = ia(dd, c, d, "TestLoadImage: error", false, b2);
    d.onabort = ia(dd, c, d, "TestLoadImage: abort", false, b2);
    d.ontimeout = ia(dd, c, d, "TestLoadImage: timeout", false, b2);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b2(false);
}
function dd(a, b2, c, d, e) {
  try {
    b2.onload = null, b2.onerror = null, b2.onabort = null, b2.ontimeout = null, e(d);
  } catch (f) {
  }
}
function ed(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(ed, Sb);
ed.prototype.g = function() {
  return new fd(this.l, this.j);
};
ed.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function fd(a, b2) {
  B.call(this);
  this.D = a;
  this.u = b2;
  this.m = void 0;
  this.readyState = gd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(fd, B);
var gd = 0;
k = fd.prototype;
k.open = function(a, b2) {
  if (this.readyState != gd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b2;
  this.readyState = 1;
  hd(this);
};
k.send = function(a) {
  if (1 != this.readyState)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b2 = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b2.body = a);
  (this.D || l).fetch(new Request(this.B, b2)).then(this.Va.bind(this), this.ga.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.").catch(() => {
  });
  1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, id(this));
  this.readyState = gd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, hd(this)), this.g && (this.readyState = 3, hd(this), this.g)))
    if ("arraybuffer" === this.responseType)
      a.arrayBuffer().then(this.Ta.bind(this), this.ga.bind(this));
    else if ("undefined" !== typeof l.ReadableStream && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      jd(this);
    } else
      a.text().then(this.Ua.bind(this), this.ga.bind(this));
};
function jd(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ga.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b2 = a.value ? a.value : new Uint8Array(0);
      if (b2 = this.A.decode(b2, { stream: !a.done }))
        this.response = this.responseText += b2;
    }
    a.done ? id(this) : hd(this);
    3 == this.readyState && jd(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, id(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, id(this));
};
k.ga = function() {
  this.g && id(this);
};
function id(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  hd(a);
}
k.setRequestHeader = function(a, b2) {
  this.v.append(a, b2);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b2 = this.h.entries();
  for (var c = b2.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b2.next();
  return a.join("\r\n");
};
function hd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(fd.prototype, "withCredentials", { get: function() {
  return "include" === this.m;
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var kd = l.JSON.parse;
function W(a) {
  B.call(this);
  this.headers = /* @__PURE__ */ new Map();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = ld;
  this.K = this.L = false;
}
t(W, B);
var ld = "";
var md = /^https?$/i;
var nd = ["POST", "PUT"];
k = W.prototype;
k.da = function(a, b2, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b2 = b2 ? b2.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : Xb.g();
  this.C = this.u ? Tb(this.u) : Tb(Xb);
  this.g.onreadystatechange = q(this.Ha, this);
  try {
    this.F = true, this.g.open(b2, String(a), true), this.F = false;
  } catch (f) {
    od(this, f);
    return;
  }
  a = c || "";
  c = new Map(this.headers);
  if (d)
    if (Object.getPrototypeOf(d) === Object.prototype)
      for (var e in d)
        c.set(e, d[e]);
    else if ("function" === typeof d.keys && "function" === typeof d.get)
      for (const f of d.keys())
        c.set(f, d.get(f));
    else
      throw Error("Unknown input type for opt_headers: " + String(d));
  d = Array.from(c.keys()).find((f) => "content-type" == f.toLowerCase());
  e = l.FormData && a instanceof l.FormData;
  !(0 <= la(nd, b2)) || d || e || c.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  for (const [f, h] of c)
    this.g.setRequestHeader(f, h);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    pd(this), 0 < this.B && ((this.K = qd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.qa, this)) : this.A = Ab(this.qa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    od(this, f);
  }
};
function qd(a) {
  return y && Ia() && "number" === typeof a.timeout && void 0 !== a.ontimeout;
}
k.qa = function() {
  "undefined" != typeof goog && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, C(this, "timeout"), this.abort(8));
};
function od(a, b2) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b2;
  a.m = 5;
  rd(a);
  sd(a);
}
function rd(a) {
  a.D || (a.D = true, C(a, "complete"), C(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, C(this, "complete"), C(this, "abort"), sd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), sd(this, true));
  W.X.M.call(this);
};
k.Ha = function() {
  this.s || (this.F || this.v || this.l ? td(this) : this.eb());
};
k.eb = function() {
  td(this);
};
function td(a) {
  if (a.h && "undefined" != typeof goog && (!a.C[1] || 4 != O(a) || 2 != a.aa())) {
    if (a.v && 4 == O(a))
      Ab(a.Ha, 0, a);
    else if (C(a, "readystatechange"), 4 == O(a)) {
      a.h = false;
      try {
        const n = a.aa();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b2 = true;
              break a;
            default:
              b2 = false;
          }
        var c;
        if (!(c = b2)) {
          var d;
          if (d = 0 === n) {
            var e = String(a.H).match(Ec)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !md.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          C(a, "complete"), C(
            a,
            "success"
          );
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.aa() + "]";
          rd(a);
        }
      } finally {
        sd(a);
      }
    }
  }
}
function sd(a, b2) {
  if (a.g) {
    pd(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b2 || C(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function pd(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.aa = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.fa = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Ra = function(a) {
  if (this.g) {
    var b2 = this.g.responseText;
    a && 0 == b2.indexOf(a) && (b2 = b2.substring(a.length));
    return kd(b2);
  }
};
function hc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case ld:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b2) {
    return null;
  }
}
k.Ea = function() {
  return this.m;
};
k.Na = function() {
  return "string" === typeof this.j ? this.j : String(this.j);
};
function ud(a) {
  let b2 = "";
  Qa(a, function(c, d) {
    b2 += d;
    b2 += ":";
    b2 += c;
    b2 += "\r\n";
  });
  return b2;
}
function vd(a, b2, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = ud(c), "string" === typeof a ? null != c && encodeURIComponent(String(c)) : S(a, b2, c));
}
function wd(a, b2, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b2 : b2;
}
function xd(a) {
  this.Ca = 0;
  this.i = [];
  this.j = new Gb();
  this.ka = this.sa = this.F = this.V = this.g = this.za = this.D = this.ia = this.o = this.S = this.s = null;
  this.$a = this.U = 0;
  this.Ya = wd("failFast", false, a);
  this.L = this.v = this.u = this.m = this.l = null;
  this.Y = true;
  this.pa = this.Ba = this.T = -1;
  this.Z = this.A = this.C = 0;
  this.Wa = wd("baseRetryDelayMs", 5e3, a);
  this.ab = wd("retryDelaySeedMs", 1e4, a);
  this.Za = wd("forwardChannelMaxRetries", 2, a);
  this.ta = wd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.ra = a && a.xmlHttpFactory || void 0;
  this.Da = a && a.Yb || false;
  this.J = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.I = "";
  this.h = new Wc(a && a.concurrentRequestLimit);
  this.Fa = new ad();
  this.O = a && a.fastHandshake || false;
  this.N = a && a.encodeInitMessageHeaders || false;
  this.O && this.N && (this.N = false);
  this.Xa = a && a.Wb || false;
  a && a.Aa && this.j.Aa();
  a && a.forceLongPolling && (this.Y = false);
  this.$ = !this.O && this.Y && a && a.detectBufferingProxy || false;
  this.ja = void 0;
  this.P = 0;
  this.K = false;
  this.la = this.B = null;
}
k = xd.prototype;
k.ma = 8;
k.G = 1;
function Ac(a) {
  yd(a);
  if (3 == a.G) {
    var b2 = a.U++, c = M(a.F);
    S(c, "SID", a.I);
    S(c, "RID", b2);
    S(c, "TYPE", "terminate");
    zd(a, c);
    b2 = new L(a, a.j, b2, void 0);
    b2.K = 2;
    b2.v = dc(M(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b2.v.toString(), ""));
    !c && l.Image && (new Image().src = b2.v, c = true);
    c || (b2.g = gc(b2.l, null), b2.g.da(b2.v));
    b2.F = Date.now();
    N(b2);
  }
  Ad(a);
}
function sc(a) {
  a.g && (oc(a), a.g.cancel(), a.g = null);
}
function yd(a) {
  sc(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  rc(a);
  a.h.cancel();
  a.m && ("number" === typeof a.m && l.clearTimeout(a.m), a.m = null);
}
function zc(a) {
  Yc(a.h) || a.m || (a.m = true, sb(a.Ja, a), a.C = 0);
}
function Bd(a, b2) {
  if (uc(a.h) >= a.h.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.i = b2.D.concat(a.i), true;
  if (1 == a.G || 2 == a.G || a.C >= (a.Ya ? 0 : a.Za))
    return false;
  a.m = J(q(a.Ja, a, b2), Cd(a, a.C));
  a.C++;
  return true;
}
k.Ja = function(a) {
  if (this.m)
    if (this.m = null, 1 == this.G) {
      if (!a) {
        this.U = Math.floor(1e5 * Math.random());
        a = this.U++;
        const e = new L(this, this.j, a, void 0);
        let f = this.s;
        this.S && (f ? (f = Ra(f), Ta(f, this.S)) : f = this.S);
        null !== this.o || this.N || (e.H = f, f = null);
        if (this.O)
          a: {
            var b2 = 0;
            for (var c = 0; c < this.i.length; c++) {
              b: {
                var d = this.i[c];
                if ("__data__" in d.g && (d = d.g.__data__, "string" === typeof d)) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (void 0 === d)
                break;
              b2 += d;
              if (4096 < b2) {
                b2 = c;
                break a;
              }
              if (4096 === b2 || c === this.i.length - 1) {
                b2 = c + 1;
                break a;
              }
            }
            b2 = 1e3;
          }
        else
          b2 = 1e3;
        b2 = Dd(this, e, b2);
        c = M(this.F);
        S(c, "RID", a);
        S(c, "CVER", 22);
        this.D && S(c, "X-HTTP-Session-Id", this.D);
        zd(this, c);
        f && (this.N ? b2 = "headers=" + encodeURIComponent(String(ud(f))) + "&" + b2 : this.o && vd(c, this.o, f));
        vc(this.h, e);
        this.Xa && S(c, "TYPE", "init");
        this.O ? (S(c, "$req", b2), S(c, "SID", "null"), e.Z = true, cc(e, c, null)) : cc(e, c, b2);
        this.G = 2;
      }
    } else
      3 == this.G && (a ? Ed(this, a) : 0 == this.i.length || Yc(this.h) || Ed(this));
};
function Ed(a, b2) {
  var c;
  b2 ? c = b2.m : c = a.U++;
  const d = M(a.F);
  S(d, "SID", a.I);
  S(d, "RID", c);
  S(d, "AID", a.T);
  zd(a, d);
  a.o && a.s && vd(d, a.o, a.s);
  c = new L(a, a.j, c, a.C + 1);
  null === a.o && (c.H = a.s);
  b2 && (a.i = b2.D.concat(a.i));
  b2 = Dd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ta) + Math.round(0.5 * a.ta * Math.random()));
  vc(a.h, c);
  cc(c, d, b2);
}
function zd(a, b2) {
  a.ia && Qa(a.ia, function(c, d) {
    S(b2, d, c);
  });
  a.l && Dc({}, function(c, d) {
    S(b2, d, c);
  });
}
function Dd(a, b2, c) {
  c = Math.min(a.i.length, c);
  var d = a.l ? q(a.l.Qa, a.l, a) : null;
  a: {
    var e = a.i;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      -1 == f ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            bd(r, h, "req" + m + "_");
          } catch (F2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.i.splice(0, c);
  b2.D = a;
  return d;
}
function yc(a) {
  a.g || a.u || (a.Z = 1, sb(a.Ia, a), a.A = 0);
}
function tc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Z++;
  a.u = J(q(a.Ia, a), Cd(a, a.A));
  a.A++;
  return true;
}
k.Ia = function() {
  this.u = null;
  Fd(this);
  if (this.$ && !(this.K || null == this.g || 0 >= this.P)) {
    var a = 2 * this.P;
    this.j.info("BP detection timer enabled: " + a);
    this.B = J(q(this.cb, this), a);
  }
};
k.cb = function() {
  this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.L = false, this.K = true, I(10), sc(this), Fd(this));
};
function oc(a) {
  null != a.B && (l.clearTimeout(a.B), a.B = null);
}
function Fd(a) {
  a.g = new L(a, a.j, "rpc", a.Z);
  null === a.o && (a.g.H = a.s);
  a.g.N = 0;
  var b2 = M(a.sa);
  S(b2, "RID", "rpc");
  S(b2, "SID", a.I);
  S(b2, "CI", a.L ? "0" : "1");
  S(b2, "AID", a.T);
  S(b2, "TYPE", "xmlhttp");
  zd(a, b2);
  a.o && a.s && vd(b2, a.o, a.s);
  a.J && a.g.setTimeout(a.J);
  var c = a.g;
  a = a.ka;
  c.K = 1;
  c.v = dc(M(b2));
  c.s = null;
  c.P = true;
  ec(c, a);
}
k.bb = function() {
  null != this.v && (this.v = null, sc(this), tc(this), I(19));
};
function rc(a) {
  null != a.v && (l.clearTimeout(a.v), a.v = null);
}
function mc(a, b2) {
  var c = null;
  if (a.g == b2) {
    rc(a);
    oc(a);
    a.g = null;
    var d = 2;
  } else if (qc(a.h, b2))
    c = b2.D, xc(a.h, b2), d = 1;
  else
    return;
  if (0 != a.G) {
    if (a.pa = b2.Y, b2.i)
      if (1 == d) {
        c = b2.s ? b2.s.length : 0;
        b2 = Date.now() - b2.F;
        var e = a.C;
        d = Mb();
        C(d, new Pb(d, c, b2, e));
        zc(a);
      } else
        yc(a);
    else if (e = b2.o, 3 == e || 0 == e && 0 < a.pa || !(1 == d && Bd(a, b2) || 2 == d && tc(a)))
      switch (c && 0 < c.length && (b2 = a.h, b2.i = b2.i.concat(c)), e) {
        case 1:
          R(a, 5);
          break;
        case 4:
          R(a, 10);
          break;
        case 3:
          R(a, 6);
          break;
        default:
          R(a, 2);
      }
  }
}
function Cd(a, b2) {
  let c = a.Wa + Math.floor(Math.random() * a.ab);
  a.l || (c *= 2);
  return c * b2;
}
function R(a, b2) {
  a.j.info("Error code " + b2);
  if (2 == b2) {
    var c = null;
    a.l && (c = null);
    var d = q(a.jb, a);
    c || (c = new T("//www.google.com/images/cleardot.gif"), l.location && "http" == l.location.protocol || Gc(c, "https"), dc(c));
    cd(c.toString(), d);
  } else
    I(2);
  a.G = 0;
  a.l && a.l.va(b2);
  Ad(a);
  yd(a);
}
k.jb = function(a) {
  a ? (this.j.info("Successfully pinged google.com"), I(2)) : (this.j.info("Failed to ping google.com"), I(1));
};
function Ad(a) {
  a.G = 0;
  a.la = [];
  if (a.l) {
    const b2 = Zc(a.h);
    if (0 != b2.length || 0 != a.i.length)
      na(a.la, b2), na(a.la, a.i), a.h.i.length = 0, ma(a.i), a.i.length = 0;
    a.l.ua();
  }
}
function wc(a, b2, c) {
  var d = c instanceof T ? M(c) : new T(c, void 0);
  if ("" != d.g)
    b2 && (d.g = b2 + "." + d.g), Hc(d, d.m);
  else {
    var e = l.location;
    d = e.protocol;
    b2 = b2 ? b2 + "." + e.hostname : e.hostname;
    e = +e.port;
    var f = new T(null, void 0);
    d && Gc(f, d);
    b2 && (f.g = b2);
    e && Hc(f, e);
    c && (f.l = c);
    d = f;
  }
  c = a.D;
  b2 = a.za;
  c && b2 && S(d, c, b2);
  S(d, "VER", a.ma);
  zd(a, d);
  return d;
}
function gc(a, b2, c) {
  if (b2 && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b2 = c && a.Da && !a.ra ? new W(new ed({ ib: true })) : new W(a.ra);
  b2.L = a.H;
  return b2;
}
function Gd() {
}
k = Gd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Qa = function() {
};
function Hd() {
  if (y && !(10 <= Number(La)))
    throw Error("Environmental error: no available transport.");
}
Hd.prototype.g = function(a, b2) {
  return new X(a, b2);
};
function X(a, b2) {
  B.call(this);
  this.g = new xd(b2);
  this.l = a;
  this.h = b2 && b2.messageUrlParams || null;
  a = b2 && b2.messageHeaders || null;
  b2 && b2.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b2 && b2.initMessageHeaders || null;
  b2 && b2.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b2.messageContentType : a = { "X-WebChannel-Content-Type": b2.messageContentType });
  b2 && b2.ya && (a ? a["X-WebChannel-Client-Profile"] = b2.ya : a = { "X-WebChannel-Client-Profile": b2.ya });
  this.g.S = a;
  (a = b2 && b2.Xb) && !pa(a) && (this.g.o = a);
  this.A = b2 && b2.supportsCrossDomainXhr || false;
  this.v = b2 && b2.sendRawJson || false;
  (b2 = b2 && b2.httpSessionIdParam) && !pa(b2) && (this.g.D = b2, a = this.h, null !== a && b2 in a && (a = this.h, b2 in a && delete a[b2]));
  this.j = new Y(this);
}
t(X, B);
X.prototype.m = function() {
  this.g.l = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b2 = this.l, c = this.h || void 0;
  I(0);
  a.V = b2;
  a.ia = c || {};
  a.L = a.Y;
  a.F = wc(a, null, a.V);
  zc(a);
};
X.prototype.close = function() {
  Ac(this.g);
};
X.prototype.u = function(a) {
  var b2 = this.g;
  if ("string" === typeof a) {
    var c = {};
    c.__data__ = a;
    a = c;
  } else
    this.v && (c = {}, c.__data__ = lb(a), a = c);
  b2.i.push(new Vc(b2.$a++, a));
  3 == b2.G && zc(b2);
};
X.prototype.M = function() {
  this.g.l = null;
  delete this.j;
  Ac(this.g);
  delete this.g;
  X.X.M.call(this);
};
function Id(a) {
  Vb.call(this);
  var b2 = a.__sm__;
  if (b2) {
    a: {
      for (const c in b2) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b2 = null !== b2 && a in b2 ? b2[a] : void 0;
    this.data = b2;
  } else
    this.data = a;
}
t(Id, Vb);
function Jd() {
  Wb.call(this);
  this.status = 1;
}
t(Jd, Wb);
function Y(a) {
  this.g = a;
}
t(Y, Gd);
Y.prototype.xa = function() {
  C(this.g, "a");
};
Y.prototype.wa = function(a) {
  C(this.g, new Id(a));
};
Y.prototype.va = function(a) {
  C(this.g, new Jd(a));
};
Y.prototype.ua = function() {
  C(this.g, "b");
};
Hd.prototype.createWebChannel = Hd.prototype.g;
X.prototype.send = X.prototype.u;
X.prototype.open = X.prototype.m;
X.prototype.close = X.prototype.close;
Qb.NO_ERROR = 0;
Qb.TIMEOUT = 8;
Qb.HTTP_ERROR = 6;
Rb.COMPLETE = "complete";
Ub.EventType = K;
K.OPEN = "a";
K.CLOSE = "b";
K.ERROR = "c";
K.MESSAGE = "d";
B.prototype.listen = B.prototype.N;
W.prototype.listenOnce = W.prototype.O;
W.prototype.getLastError = W.prototype.Na;
W.prototype.getLastErrorCode = W.prototype.Ea;
W.prototype.getStatus = W.prototype.aa;
W.prototype.getResponseJson = W.prototype.Ra;
W.prototype.getResponseText = W.prototype.fa;
W.prototype.send = W.prototype.da;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Hd();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Mb();
};
var ErrorCode = esm.ErrorCode = Qb;
var EventType = esm.EventType = Rb;
var Event = esm.Event = G;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = ed;
var WebChannel = esm.WebChannel = Ub;
var XhrIo = esm.XhrIo = W;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var R2 = "@firebase/firestore";
var b = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return null != this.uid;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
b.UNAUTHENTICATED = new b(null), b.GOOGLE_CREDENTIALS = new b("google-credentials-uid"), b.FIRST_PARTY = new b("first-party-uid"), b.MOCK_USER = new b("mock-user");
var P2 = "9.10.0";
var v2 = new Logger("@firebase/firestore");
function V2() {
  return v2.logLevel;
}
function S2(t2) {
  v2.setLogLevel(t2);
}
function D2(t2, ...e) {
  if (v2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(N2);
    v2.debug(`Firestore (${P2}): ${t2}`, ...n);
  }
}
function C2(t2, ...e) {
  if (v2.logLevel <= LogLevel.ERROR) {
    const n = e.map(N2);
    v2.error(`Firestore (${P2}): ${t2}`, ...n);
  }
}
function x2(t2, ...e) {
  if (v2.logLevel <= LogLevel.WARN) {
    const n = e.map(N2);
    v2.warn(`Firestore (${P2}): ${t2}`, ...n);
  }
}
function N2(t2) {
  if ("string" == typeof t2)
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function k2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${P2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw C2(e), new Error(e);
}
function M2(t2, e) {
  t2 || k2();
}
function O2(t2, e) {
  t2 || k2();
}
function F(t2, e) {
  return t2;
}
var $ = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var B2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var L2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var U2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var q2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(b.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var K2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var G2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = b.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new L2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new L2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      D2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (D2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new L2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (D2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (M2("string" == typeof e2.accessToken), new U2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return M2(null === t2 || "string" == typeof t2), new b(t2);
  }
};
var Q2 = class {
  constructor(t2, e, n, s) {
    this.h = t2, this.l = e, this.m = n, this.g = s, this.type = "FirstParty", this.user = b.FIRST_PARTY, this.p = /* @__PURE__ */ new Map();
  }
  I() {
    return this.g ? this.g() : (M2(!("object" != typeof this.h || null === this.h || !this.h.auth || !this.h.auth.getAuthHeaderValueForFirstParty)), this.h.auth.getAuthHeaderValueForFirstParty([]));
  }
  get headers() {
    this.p.set("X-Goog-AuthUser", this.l);
    const t2 = this.I();
    return t2 && this.p.set("Authorization", t2), this.m && this.p.set("X-Goog-Iam-Authorization-Token", this.m), this.p;
  }
};
var j = class {
  constructor(t2, e, n, s) {
    this.h = t2, this.l = e, this.m = n, this.g = s;
  }
  getToken() {
    return Promise.resolve(new Q2(this.h, this.l, this.m, this.g));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(b.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var W2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var z2 = class {
  constructor(t2) {
    this.T = t2, this.forceRefresh = false, this.appCheck = null, this.A = null;
  }
  start(t2, e) {
    const n = (t3) => {
      null != t3.error && D2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.A;
      return this.A = t3.token, D2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      D2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.T.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.T.getImmediate({
          optional: true
        });
        t3 ? s(t3) : D2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (M2("string" == typeof t3.token), this.A = t3.token, new W2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var H2 = class {
  getToken() {
    return Promise.resolve(new W2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
function J2(t2) {
  const e = "undefined" != typeof self && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && "function" == typeof e.getRandomValues)
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
var Y2 = class {
  static R() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = J2(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function X2(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function Z(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function tt(t2) {
  return t2 + "\0";
}
var et = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new B2($.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new B2($.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new B2($.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new B2($.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return et.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return et.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new et(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? X2(this.nanoseconds, t2.nanoseconds) : X2(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var nt = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new nt(t2);
  }
  static min() {
    return new nt(new et(0, 0));
  }
  static max() {
    return new nt(new et(253402300799, 999999999));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
var st = class {
  constructor(t2, e, n) {
    void 0 === e ? e = 0 : e > t2.length && k2(), void 0 === n ? n = t2.length - e : n > t2.length - e && k2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return 0 === st.comparator(this, t2);
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof st ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = void 0 === t2 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return 0 === this.length;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var it = class extends st {
  construct(t2, e, n) {
    return new it(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new B2($.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new it(e);
  }
  static emptyPath() {
    return new it([]);
  }
};
var rt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var ot = class extends st {
  construct(t2, e, n) {
    return new ot(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return rt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ot.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return 1 === this.length && "__name__" === this.get(0);
  }
  static keyField() {
    return new ot(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (0 === n.length)
        throw new B2($.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if ("\\" === e2) {
        if (s + 1 === t2.length)
          throw new B2($.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if ("\\" !== e3 && "." !== e3 && "`" !== e3)
          throw new B2($.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        "`" === e2 ? (r = !r, s++) : "." !== e2 || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new B2($.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new ot(e);
  }
  static emptyPath() {
    return new ot([]);
  }
};
var ut = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new ut(it.fromString(t2));
  }
  static fromName(t2) {
    return new ut(it.fromString(t2).popFirst(5));
  }
  static empty() {
    return new ut(it.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return null !== t2 && 0 === it.comparator(this.path, t2.path);
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return it.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new ut(new it(t2.slice()));
  }
};
var ct = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function at(t2) {
  return t2.fields.find((t3) => 2 === t3.kind);
}
function ht(t2) {
  return t2.fields.filter((t3) => 2 !== t3.kind);
}
function lt(t2, e) {
  let n = X2(t2.collectionGroup, e.collectionGroup);
  if (0 !== n)
    return n;
  for (let s = 0; s < Math.min(t2.fields.length, e.fields.length); ++s)
    if (n = dt(t2.fields[s], e.fields[s]), 0 !== n)
      return n;
  return X2(t2.fields.length, e.fields.length);
}
ct.UNKNOWN_ID = -1;
var ft = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
function dt(t2, e) {
  const n = ot.comparator(t2.fieldPath, e.fieldPath);
  return 0 !== n ? n : X2(t2.kind, e.kind);
}
var _t = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new _t(0, gt.min());
  }
};
function wt(t2, e) {
  const n = t2.toTimestamp().seconds, s = t2.toTimestamp().nanoseconds + 1, i = nt.fromTimestamp(1e9 === s ? new et(n + 1, 0) : new et(n, s));
  return new gt(i, ut.empty(), e);
}
function mt(t2) {
  return new gt(t2.readTime, t2.key, -1);
}
var gt = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new gt(nt.min(), ut.empty(), -1);
  }
  static max() {
    return new gt(nt.max(), ut.empty(), -1);
  }
};
function yt(t2, e) {
  let n = t2.readTime.compareTo(e.readTime);
  return 0 !== n ? n : (n = ut.comparator(t2.documentKey, e.documentKey), 0 !== n ? n : X2(t2.largestBatchId, e.largestBatchId));
}
var pt = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var It = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
async function Tt(t2) {
  if (t2.code !== $.FAILED_PRECONDITION || t2.message !== pt)
    throw t2;
  D2("LocalStore", "Unexpectedly lost primary lease");
}
var Et = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && k2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new Et((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof Et ? e : Et.resolve(e);
    } catch (t3) {
      return Et.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Et.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Et.reject(e);
  }
  static resolve(t2) {
    return new Et((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new Et((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new Et((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = Et.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? Et.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
  static mapArray(t2, e) {
    return new Et((n, s) => {
      const i = t2.length, r = new Array(i);
      let o = 0;
      for (let u = 0; u < i; u++) {
        const c = u;
        e(t2[c]).next((t3) => {
          r[c] = t3, ++o, o === i && n(r);
        }, (t3) => s(t3));
      }
    });
  }
  static doWhile(t2, e) {
    return new Et((n, s) => {
      const i = () => {
        true === t2() ? e().next(() => {
          i();
        }, s) : n();
      };
      i();
    });
  }
};
var At = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.P = new L2(), this.transaction.oncomplete = () => {
      this.P.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.P.reject(new Pt(t2, e.error)) : this.P.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Ct(e2.target.error);
      this.P.reject(new Pt(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new At(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Pt(e, t3);
    }
  }
  get v() {
    return this.P.promise;
  }
  abort(t2) {
    t2 && this.P.reject(t2), this.aborted || (D2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  V() {
    const t2 = this.transaction;
    this.aborted || "function" != typeof t2.commit || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Vt(e);
  }
};
var Rt = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.S = n;
    12.2 === Rt.D(getUA()) && C2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return D2("SimpleDb", "Removing database:", t2), St(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static C() {
    if (!isIndexedDBAvailable())
      return false;
    if (Rt.N())
      return true;
    const t2 = getUA(), e = Rt.D(t2), n = 0 < e && e < 10, s = Rt.k(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static N() {
    var t2;
    return "undefined" != typeof process && "YES" === (null === (t2 = process.env) || void 0 === t2 ? void 0 : t2.M);
  }
  static O(t2, e) {
    return t2.store(e);
  }
  static D(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static k(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async F(t2) {
    return this.db || (D2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Pt(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        "VersionError" === s2.name ? n(new B2($.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === s2.name ? n(new B2($.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Pt(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        D2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.S.$(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          D2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.B && (this.db.onversionchange = (t3) => this.B(t3)), this.db;
  }
  L(t2) {
    this.B = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = "readonly" === e;
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.F(t2);
        const e2 = At.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.V(), t3)).catch((t3) => (e2.abort(t3), Et.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.v, r2;
      } catch (t3) {
        const e2 = t3, n2 = "FirebaseError" !== e2.name && r < 3;
        if (D2("SimpleDb", "Transaction failed with error:", e2.message, "Retrying:", n2), this.close(), !n2)
          return Promise.reject(e2);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var bt = class {
  constructor(t2) {
    this.U = t2, this.q = false, this.K = null;
  }
  get isDone() {
    return this.q;
  }
  get G() {
    return this.K;
  }
  set cursor(t2) {
    this.U = t2;
  }
  done() {
    this.q = true;
  }
  j(t2) {
    this.K = t2;
  }
  delete() {
    return St(this.U.delete());
  }
};
var Pt = class extends B2 {
  constructor(t2, e) {
    super($.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function vt(t2) {
  return "IndexedDbTransactionError" === t2.name;
}
var Vt = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return void 0 !== e ? (D2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (D2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), St(n);
  }
  add(t2) {
    D2("SimpleDb", "ADD", this.store.name, t2, t2);
    return St(this.store.add(t2));
  }
  get(t2) {
    return St(this.store.get(t2)).next((e) => (void 0 === e && (e = null), D2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    D2("SimpleDb", "DELETE", this.store.name, t2);
    return St(this.store.delete(t2));
  }
  count() {
    D2("SimpleDb", "COUNT", this.store.name);
    return St(this.store.count());
  }
  W(t2, e) {
    const n = this.options(t2, e);
    if (n.index || "function" != typeof this.store.getAll) {
      const t3 = this.cursor(n), e2 = [];
      return this.H(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new Et((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  J(t2, e) {
    const n = this.store.getAll(t2, null === e ? void 0 : e);
    return new Et((t3, e2) => {
      n.onerror = (t4) => {
        e2(t4.target.error);
      }, n.onsuccess = (e3) => {
        t3(e3.target.result);
      };
    });
  }
  Y(t2, e) {
    D2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.X = false;
    const s = this.cursor(n);
    return this.H(s, (t3, e2, n2) => n2.delete());
  }
  Z(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.H(s, e);
  }
  tt(t2) {
    const e = this.cursor({});
    return new Et((n, s) => {
      e.onerror = (t3) => {
        const e2 = Ct(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  H(t2, e) {
    const n = [];
    return new Et((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new bt(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof Et) {
          const t4 = o.catch((t5) => (r.done(), Et.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : null === r.G ? i2.continue() : i2.continue(r.G);
      };
    }).next(() => Et.waitFor(n));
  }
  options(t2, e) {
    let n;
    return void 0 !== t2 && ("string" == typeof t2 ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.X ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function St(t2) {
  return new Et((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = Ct(t3.target.error);
      n(e2);
    };
  });
}
var Dt = false;
function Ct(t2) {
  const e = Rt.D(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new B2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Dt || (Dt = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var xt = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.et = e, this.task = null;
  }
  start() {
    this.nt(15e3);
  }
  stop() {
    this.task && (this.task.cancel(), this.task = null);
  }
  get started() {
    return null !== this.task;
  }
  nt(t2) {
    D2("IndexBackiller", `Scheduled in ${t2}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", t2, async () => {
      this.task = null;
      try {
        D2("IndexBackiller", `Documents written: ${await this.et.st()}`);
      } catch (t3) {
        vt(t3) ? D2("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", t3) : await Tt(t3);
      }
      await this.nt(6e4);
    });
  }
};
var Nt = class {
  constructor(t2, e) {
    this.localStore = t2, this.persistence = e;
  }
  async st(t2 = 50) {
    return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", (e) => this.it(e, t2));
  }
  it(t2, e) {
    const n = /* @__PURE__ */ new Set();
    let s = e, i = true;
    return Et.doWhile(() => true === i && s > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(t2).next((e2) => {
      if (null !== e2 && !n.has(e2))
        return D2("IndexBackiller", `Processing collection: ${e2}`), this.rt(t2, e2, s).next((t3) => {
          s -= t3, n.add(e2);
        });
      i = false;
    })).next(() => e - s);
  }
  rt(t2, e, n) {
    return this.localStore.indexManager.getMinOffsetFromCollectionGroup(t2, e).next((s) => this.localStore.localDocuments.getNextDocuments(t2, e, s, n).next((n2) => {
      const i = n2.changes;
      return this.localStore.indexManager.updateIndexEntries(t2, i).next(() => this.ot(s, n2)).next((n3) => (D2("IndexBackiller", `Updating offset: ${n3}`), this.localStore.indexManager.updateCollectionGroup(t2, e, n3))).next(() => i.size);
    }));
  }
  ot(t2, e) {
    let n = t2;
    return e.changes.forEach((t3, e2) => {
      const s = mt(e2);
      yt(s, n) > 0 && (n = s);
    }), new gt(n.readTime, n.documentKey, Math.max(e.batchId, t2.largestBatchId));
  }
};
var kt = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.ut(t3), this.ct = (t3) => e.writeSequenceNumber(t3));
  }
  ut(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.ct && this.ct(t2), t2;
  }
};
function Mt(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function Ot(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function Ft(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
kt.at = -1;
var $t = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Lt.EMPTY;
  }
  insert(t2, e) {
    return new $t(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Lt.BLACK, null, null));
  }
  remove(t2) {
    return new $t(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Lt.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (0 === n)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (0 === s)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new Bt(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new Bt(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new Bt(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new Bt(this.root, t2, this.comparator, true);
  }
};
var Bt = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, e && s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (0 === i) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (0 === this.nodeStack.length)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Lt = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = null != n ? n : Lt.RED, this.left = null != s ? s : Lt.EMPTY, this.right = null != i ? i : Lt.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Lt(null != t2 ? t2 : this.key, null != e ? e : this.value, null != n ? n : this.color, null != s ? s : this.left, null != i ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : 0 === i ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Lt.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), 0 === e(t2, s.key)) {
        if (s.right.isEmpty())
          return Lt.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Lt.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Lt.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw k2();
    if (this.right.isRed())
      throw k2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw k2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Lt.EMPTY = null, Lt.RED = true, Lt.BLACK = false;
Lt.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw k2();
  }
  get value() {
    throw k2();
  }
  get color() {
    throw k2();
  }
  get left() {
    throw k2();
  }
  get right() {
    throw k2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Lt(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var Ut = class {
  constructor(t2) {
    this.comparator = t2, this.data = new $t(this.comparator);
  }
  has(t2) {
    return null !== this.data.get(t2);
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new qt(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new qt(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof Ut))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (0 !== this.comparator(t3, s))
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new Ut(this.comparator);
    return e.data = t2, e;
  }
};
var qt = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Kt(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var Gt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(ot.comparator);
  }
  static empty() {
    return new Gt([]);
  }
  unionWith(t2) {
    let e = new Ut(ot.comparator);
    for (const t3 of this.fields)
      e = e.add(t3);
    for (const n of t2)
      e = e.add(n);
    return new Gt(e.toArray());
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return Z(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function Qt() {
  return "undefined" != typeof atob;
}
var jt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new jt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new jt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return X2(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
jt.EMPTY_BYTE_STRING = new jt("");
var Wt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function zt(t2) {
  if (M2(!!t2), "string" == typeof t2) {
    let e = 0;
    const n = Wt.exec(t2);
    if (M2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Ht(t2.seconds),
    nanos: Ht(t2.nanos)
  };
}
function Ht(t2) {
  return "number" == typeof t2 ? t2 : "string" == typeof t2 ? Number(t2) : 0;
}
function Jt(t2) {
  return "string" == typeof t2 ? jt.fromBase64String(t2) : jt.fromUint8Array(t2);
}
function Yt(t2) {
  var e, n;
  return "server_timestamp" === (null === (n = ((null === (e = null == t2 ? void 0 : t2.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue);
}
function Xt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Yt(e) ? Xt(e) : e;
}
function Zt(t2) {
  const e = zt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new et(e.seconds, e.nanos);
}
var te = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var ee = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new ee("", "");
  }
  get isDefaultDatabase() {
    return "(default)" === this.database;
  }
  isEqual(t2) {
    return t2 instanceof ee && t2.projectId === this.projectId && t2.database === this.database;
  }
};
function ne(t2) {
  return null == t2;
}
function se(t2) {
  return 0 === t2 && 1 / t2 == -1 / 0;
}
function ie(t2) {
  return "number" == typeof t2 && Number.isInteger(t2) && !se(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var re = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var oe = {
  nullValue: "NULL_VALUE"
};
function ue(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Yt(t2) ? 4 : Te(t2) ? 9007199254740991 : 10 : k2();
}
function ce(t2, e) {
  if (t2 === e)
    return true;
  const n = ue(t2);
  if (n !== ue(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Zt(t2).isEqual(Zt(e));
    case 3:
      return function(t3, e2) {
        if ("string" == typeof t3.timestampValue && "string" == typeof e2.timestampValue && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = zt(t3.timestampValue), s = zt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return Jt(t3.bytesValue).isEqual(Jt(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Ht(t3.geoPointValue.latitude) === Ht(e2.geoPointValue.latitude) && Ht(t3.geoPointValue.longitude) === Ht(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Ht(t3.integerValue) === Ht(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Ht(t3.doubleValue), s = Ht(e2.doubleValue);
          return n2 === s ? se(n2) === se(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return Z(t2.arrayValue.values || [], e.arrayValue.values || [], ce);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (Mt(n2) !== Mt(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (void 0 === s[t4] || !ce(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return k2();
  }
}
function ae(t2, e) {
  return void 0 !== (t2.values || []).find((t3) => ce(t3, e));
}
function he(t2, e) {
  if (t2 === e)
    return 0;
  const n = ue(t2), s = ue(e);
  if (n !== s)
    return X2(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return X2(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Ht(t3.integerValue || t3.doubleValue), s2 = Ht(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return le(t2.timestampValue, e.timestampValue);
    case 4:
      return le(Zt(t2), Zt(e));
    case 5:
      return X2(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = Jt(t3), s2 = Jt(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = X2(n2[t4], s2[t4]);
          if (0 !== e3)
            return e3;
        }
        return X2(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = X2(Ht(t3.latitude), Ht(e2.latitude));
        if (0 !== n2)
          return n2;
        return X2(Ht(t3.longitude), Ht(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = he(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return X2(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        if (t3 === re.mapValue && e2 === re.mapValue)
          return 0;
        if (t3 === re.mapValue)
          return 1;
        if (e2 === re.mapValue)
          return -1;
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = X2(s2[t4], r[t4]);
          if (0 !== e3)
            return e3;
          const o = he(n2[s2[t4]], i[r[t4]]);
          if (0 !== o)
            return o;
        }
        return X2(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw k2();
  }
}
function le(t2, e) {
  if ("string" == typeof t2 && "string" == typeof e && t2.length === e.length)
    return X2(t2, e);
  const n = zt(t2), s = zt(e), i = X2(n.seconds, s.seconds);
  return 0 !== i ? i : X2(n.nanos, s.nanos);
}
function fe(t2) {
  return de(t2);
}
function de(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = zt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? Jt(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, ut.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += de(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${de(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : k2();
  var e, n;
}
function _e(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function we(t2) {
  return !!t2 && "integerValue" in t2;
}
function me(t2) {
  return !!t2 && "arrayValue" in t2;
}
function ge(t2) {
  return !!t2 && "nullValue" in t2;
}
function ye(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function pe(t2) {
  return !!t2 && "mapValue" in t2;
}
function Ie(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && "object" == typeof t2.timestampValue)
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return Ot(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Ie(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Ie(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function Te(t2) {
  return "__max__" === (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue;
}
function Ee(t2) {
  return "nullValue" in t2 ? oe : "booleanValue" in t2 ? {
    booleanValue: false
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    doubleValue: NaN
  } : "timestampValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "stringValue" in t2 ? {
    stringValue: ""
  } : "bytesValue" in t2 ? {
    bytesValue: ""
  } : "referenceValue" in t2 ? _e(ee.empty(), ut.empty()) : "geoPointValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "arrayValue" in t2 ? {
    arrayValue: {}
  } : "mapValue" in t2 ? {
    mapValue: {}
  } : k2();
}
function Ae(t2) {
  return "nullValue" in t2 ? {
    booleanValue: false
  } : "booleanValue" in t2 ? {
    doubleValue: NaN
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "timestampValue" in t2 ? {
    stringValue: ""
  } : "stringValue" in t2 ? {
    bytesValue: ""
  } : "bytesValue" in t2 ? _e(ee.empty(), ut.empty()) : "referenceValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "geoPointValue" in t2 ? {
    arrayValue: {}
  } : "arrayValue" in t2 ? {
    mapValue: {}
  } : "mapValue" in t2 ? re : k2();
}
function Re(t2, e) {
  const n = he(t2.value, e.value);
  return 0 !== n ? n : t2.inclusive && !e.inclusive ? -1 : !t2.inclusive && e.inclusive ? 1 : 0;
}
function be(t2, e) {
  const n = he(t2.value, e.value);
  return 0 !== n ? n : t2.inclusive && !e.inclusive ? 1 : !t2.inclusive && e.inclusive ? -1 : 0;
}
var Pe = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Pe({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !pe(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Ie(e);
  }
  setAll(t2) {
    let e = ot.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Ie(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    pe(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return ce(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      pe(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    Ot(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Pe(Ie(this.value));
  }
};
function ve(t2) {
  const e = [];
  return Ot(t2.fields, (t3, n) => {
    const s = new ot([t3]);
    if (pe(n)) {
      const t4 = ve(n.mapValue).fields;
      if (0 === t4.length)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new Gt(e);
}
var Ve = class {
  constructor(t2, e, n, s, i, r) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t2) {
    return new Ve(t2, 0, nt.min(), nt.min(), Pe.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Ve(t2, 1, e, nt.min(), n, 0);
  }
  static newNoDocument(t2, e) {
    return new Ve(t2, 2, e, nt.min(), Pe.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Ve(t2, 3, e, nt.min(), Pe.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Pe.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Pe.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = nt.min(), this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return 1 === this.documentState;
  }
  get hasCommittedMutations() {
    return 2 === this.documentState;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return 0 !== this.documentType;
  }
  isFoundDocument() {
    return 1 === this.documentType;
  }
  isNoDocument() {
    return 2 === this.documentType;
  }
  isUnknownDocument() {
    return 3 === this.documentType;
  }
  isEqual(t2) {
    return t2 instanceof Ve && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new Ve(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Se = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.ht = null;
  }
};
function De(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Se(t2, e, n, s, i, r, o);
}
function Ce(t2) {
  const e = F(t2);
  if (null === e.ht) {
    let t3 = e.path.canonicalString();
    null !== e.collectionGroup && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => {
      return (e2 = t4).field.canonicalString() + e2.op.toString() + fe(e2.value);
      var e2;
    }).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), ne(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => fe(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => fe(t4)).join(",")), e.ht = t3;
  }
  return e.ht;
}
function xe(t2) {
  let e = t2.path.canonicalString();
  return null !== t2.collectionGroup && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${fe(e2.value)}`;
    var e2;
  }).join(", ")}]`), ne(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: ", e += t2.startAt.inclusive ? "b:" : "a:", e += t2.startAt.position.map((t3) => fe(t3)).join(",")), t2.endAt && (e += ", endAt: ", e += t2.endAt.inclusive ? "a:" : "b:", e += t2.endAt.position.map((t3) => fe(t3)).join(",")), `Target(${e})`;
}
function Ne(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!He(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !ce(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!Ye(t2.startAt, e.startAt) && Ye(t2.endAt, e.endAt)));
}
function ke(t2) {
  return ut.isDocumentKey(t2.path) && null === t2.collectionGroup && 0 === t2.filters.length;
}
function Me(t2, e) {
  return t2.filters.filter((t3) => t3 instanceof $e && t3.field.isEqual(e));
}
function Oe(t2, e, n) {
  let s = oe, i = true;
  for (const n2 of Me(t2, e)) {
    let t3 = oe, e2 = true;
    switch (n2.op) {
      case "<":
      case "<=":
        t3 = Ee(n2.value);
        break;
      case "==":
      case "in":
      case ">=":
        t3 = n2.value;
        break;
      case ">":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = oe;
    }
    Re({
      value: s,
      inclusive: i
    }, {
      value: t3,
      inclusive: e2
    }) < 0 && (s = t3, i = e2);
  }
  if (null !== n)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        Re({
          value: s,
          inclusive: i
        }, {
          value: t3,
          inclusive: n.inclusive
        }) < 0 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
function Fe(t2, e, n) {
  let s = re, i = true;
  for (const n2 of Me(t2, e)) {
    let t3 = re, e2 = true;
    switch (n2.op) {
      case ">=":
      case ">":
        t3 = Ae(n2.value), e2 = false;
        break;
      case "==":
      case "in":
      case "<=":
        t3 = n2.value;
        break;
      case "<":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = re;
    }
    be({
      value: s,
      inclusive: i
    }, {
      value: t3,
      inclusive: e2
    }) > 0 && (s = t3, i = e2);
  }
  if (null !== n)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        be({
          value: s,
          inclusive: i
        }, {
          value: t3,
          inclusive: n.inclusive
        }) > 0 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
var $e = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? "in" === e || "not-in" === e ? this.lt(t2, e, n) : new Be(t2, e, n) : "array-contains" === e ? new Ke(t2, n) : "in" === e ? new Ge(t2, n) : "not-in" === e ? new Qe(t2, n) : "array-contains-any" === e ? new je(t2, n) : new $e(t2, e, n);
  }
  static lt(t2, e, n) {
    return "in" === e ? new Le(t2, n) : new Ue(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return "!=" === this.op ? null !== e && this.ft(he(e, this.value)) : null !== e && ue(this.value) === ue(e) && this.ft(he(e, this.value));
  }
  ft(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return 0 === t2;
      case "!=":
        return 0 !== t2;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return k2();
    }
  }
  dt() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var Be = class extends $e {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = ut.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = ut.comparator(t2.key, this.key);
    return this.ft(e);
  }
};
var Le = class extends $e {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = qe("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var Ue = class extends $e {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = qe("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function qe(t2, e) {
  var n;
  return ((null === (n = e.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((t3) => ut.fromName(t3.referenceValue));
}
var Ke = class extends $e {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return me(e) && ae(e.arrayValue, this.value);
  }
};
var Ge = class extends $e {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return null !== e && ae(this.value.arrayValue, e);
  }
};
var Qe = class extends $e {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (ae(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return null !== e && !ae(this.value.arrayValue, e);
  }
};
var je = class extends $e {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!me(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => ae(this.value.arrayValue, t3));
  }
};
var We = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
var ze = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function He(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function Je(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = ut.comparator(ut.fromName(o.referenceValue), n.key);
    else {
      s = he(o, n.data.field(r.field));
    }
    if ("desc" === r.dir && (s *= -1), 0 !== s)
      break;
  }
  return s;
}
function Ye(t2, e) {
  if (null === t2)
    return null === e;
  if (null === e)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!ce(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var Xe = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, u = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = u, this._t = null, this.wt = null, this.startAt, this.endAt;
  }
};
function Ze(t2, e, n, s, i, r, o, u) {
  return new Xe(t2, e, n, s, i, r, o, u);
}
function tn(t2) {
  return new Xe(t2);
}
function en(t2) {
  return 0 === t2.filters.length && null === t2.limit && null == t2.startAt && null == t2.endAt && (0 === t2.explicitOrderBy.length || 1 === t2.explicitOrderBy.length && t2.explicitOrderBy[0].field.isKeyField());
}
function nn(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function sn(t2) {
  for (const e of t2.filters)
    if (e.dt())
      return e.field;
  return null;
}
function rn(t2) {
  return null !== t2.collectionGroup;
}
function on(t2) {
  const e = F(t2);
  if (null === e._t) {
    e._t = [];
    const t3 = sn(e), n = nn(e);
    if (null !== t3 && null === n)
      t3.isKeyField() || e._t.push(new ze(t3)), e._t.push(new ze(ot.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e._t.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e._t.push(new ze(ot.keyField(), t5));
      }
    }
  }
  return e._t;
}
function un(t2) {
  const e = F(t2);
  if (!e.wt)
    if ("F" === e.limitType)
      e.wt = De(e.path, e.collectionGroup, on(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of on(e)) {
        const e2 = "desc" === n2.dir ? "asc" : "desc";
        t3.push(new ze(n2.field, e2));
      }
      const n = e.endAt ? new We(e.endAt.position, e.endAt.inclusive) : null, s = e.startAt ? new We(e.startAt.position, e.startAt.inclusive) : null;
      e.wt = De(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.wt;
}
function cn(t2, e, n) {
  return new Xe(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function an(t2, e) {
  return Ne(un(t2), un(e)) && t2.limitType === e.limitType;
}
function hn(t2) {
  return `${Ce(un(t2))}|lt:${t2.limitType}`;
}
function ln(t2) {
  return `Query(target=${xe(un(t2))}; limitType=${t2.limitType})`;
}
function fn(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return null !== t3.collectionGroup ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : ut.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && null === e2.data.field(n.field))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = Je(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, on(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = Je(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, on(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function dn(t2) {
  return t2.collectionGroup || (t2.path.length % 2 == 1 ? t2.path.lastSegment() : t2.path.get(t2.path.length - 2));
}
function _n(t2) {
  return (e, n) => {
    let s = false;
    for (const i of on(t2)) {
      const t3 = wn(i, e, n);
      if (0 !== t3)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function wn(t2, e, n) {
  const s = t2.field.isKeyField() ? ut.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return null !== s2 && null !== i ? he(s2, i) : k2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return k2();
  }
}
function mn(t2, e) {
  if (t2.gt) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: se(e) ? "-0" : e
  };
}
function gn(t2) {
  return {
    integerValue: "" + t2
  };
}
function yn(t2, e) {
  return ie(e) ? gn(e) : mn(t2, e);
}
var pn = class {
  constructor() {
    this._ = void 0;
  }
};
function In(t2, e, n) {
  return t2 instanceof An ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Rn ? bn(t2, e) : t2 instanceof Pn ? vn(t2, e) : function(t3, e2) {
    const n2 = En(t3, e2), s = Sn(n2) + Sn(t3.yt);
    return we(n2) && we(t3.yt) ? gn(s) : mn(t3.It, s);
  }(t2, e);
}
function Tn(t2, e, n) {
  return t2 instanceof Rn ? bn(t2, e) : t2 instanceof Pn ? vn(t2, e) : n;
}
function En(t2, e) {
  return t2 instanceof Vn ? we(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var An = class extends pn {
};
var Rn = class extends pn {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function bn(t2, e) {
  const n = Dn(e);
  for (const e2 of t2.elements)
    n.some((t3) => ce(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Pn = class extends pn {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function vn(t2, e) {
  let n = Dn(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !ce(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Vn = class extends pn {
  constructor(t2, e) {
    super(), this.It = t2, this.yt = e;
  }
};
function Sn(t2) {
  return Ht(t2.integerValue || t2.doubleValue);
}
function Dn(t2) {
  return me(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var Cn = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function xn(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Rn && e2 instanceof Rn || t3 instanceof Pn && e2 instanceof Pn ? Z(t3.elements, e2.elements, ce) : t3 instanceof Vn && e2 instanceof Vn ? ce(t3.yt, e2.yt) : t3 instanceof An && e2 instanceof An;
  }(t2.transform, e.transform);
}
var Nn = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var kn = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new kn();
  }
  static exists(t2) {
    return new kn(void 0, t2);
  }
  static updateTime(t2) {
    return new kn(t2);
  }
  get isNone() {
    return void 0 === this.updateTime && void 0 === this.exists;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function Mn(t2, e) {
  return void 0 !== t2.updateTime ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : void 0 === t2.exists || t2.exists === e.isFoundDocument();
}
var On = class {
};
function Fn(t2, e) {
  if (!t2.hasLocalMutations || e && 0 === e.fields.length)
    return null;
  if (null === e)
    return t2.isNoDocument() ? new Wn(t2.key, kn.none()) : new qn(t2.key, t2.data, kn.none());
  {
    const n = t2.data, s = Pe.empty();
    let i = new Ut(ot.comparator);
    for (let t3 of e.fields)
      if (!i.has(t3)) {
        let e2 = n.field(t3);
        null === e2 && t3.length > 1 && (t3 = t3.popLast(), e2 = n.field(t3)), null === e2 ? s.delete(t3) : s.set(t3, e2), i = i.add(t3);
      }
    return new Kn(t2.key, s, new Gt(i.toArray()), kn.none());
  }
}
function $n(t2, e, n) {
  t2 instanceof qn ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = Qn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof Kn ? function(t3, e2, n2) {
    if (!Mn(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = Qn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(Gn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Bn(t2, e, n, s) {
  return t2 instanceof qn ? function(t3, e2, n2, s2) {
    if (!Mn(t3.precondition, e2))
      return n2;
    const i = t3.value.clone(), r = jn(t3.fieldTransforms, s2, e2);
    return i.setAll(r), e2.convertToFoundDocument(e2.version, i).setHasLocalMutations(), null;
  }(t2, e, n, s) : t2 instanceof Kn ? function(t3, e2, n2, s2) {
    if (!Mn(t3.precondition, e2))
      return n2;
    const i = jn(t3.fieldTransforms, s2, e2), r = e2.data;
    if (r.setAll(Gn(t3)), r.setAll(i), e2.convertToFoundDocument(e2.version, r).setHasLocalMutations(), null === n2)
      return null;
    return n2.unionWith(t3.fieldMask.fields).unionWith(t3.fieldTransforms.map((t4) => t4.field));
  }(t2, e, n, s) : function(t3, e2, n2) {
    if (Mn(t3.precondition, e2))
      return e2.convertToNoDocument(e2.version).setHasLocalMutations(), null;
    return n2;
  }(t2, e, n);
}
function Ln(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = En(s.transform, t3 || null);
    null != i && (null === n && (n = Pe.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Un(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return void 0 === t3 && void 0 === e2 || !(!t3 || !e2) && Z(t3, e2, (t4, e3) => xn(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (0 === t2.type ? t2.value.isEqual(e.value) : 1 !== t2.type || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
var qn = class extends On {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
};
var Kn = class extends On {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
};
function Gn(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function Qn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  M2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, u = e.data.field(r.field);
    s.set(r.field, Tn(o, u, n[i]));
  }
  return s;
}
function jn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, In(t3, r, e));
  }
  return s;
}
var Wn = class extends On {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var zn = class extends On {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Hn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var Jn;
var Yn;
function Xn(t2) {
  switch (t2) {
    default:
      return k2();
    case $.CANCELLED:
    case $.UNKNOWN:
    case $.DEADLINE_EXCEEDED:
    case $.RESOURCE_EXHAUSTED:
    case $.INTERNAL:
    case $.UNAVAILABLE:
    case $.UNAUTHENTICATED:
      return false;
    case $.INVALID_ARGUMENT:
    case $.NOT_FOUND:
    case $.ALREADY_EXISTS:
    case $.PERMISSION_DENIED:
    case $.FAILED_PRECONDITION:
    case $.ABORTED:
    case $.OUT_OF_RANGE:
    case $.UNIMPLEMENTED:
    case $.DATA_LOSS:
      return true;
  }
}
function Zn(t2) {
  if (void 0 === t2)
    return C2("GRPC error has no .code"), $.UNKNOWN;
  switch (t2) {
    case Jn.OK:
      return $.OK;
    case Jn.CANCELLED:
      return $.CANCELLED;
    case Jn.UNKNOWN:
      return $.UNKNOWN;
    case Jn.DEADLINE_EXCEEDED:
      return $.DEADLINE_EXCEEDED;
    case Jn.RESOURCE_EXHAUSTED:
      return $.RESOURCE_EXHAUSTED;
    case Jn.INTERNAL:
      return $.INTERNAL;
    case Jn.UNAVAILABLE:
      return $.UNAVAILABLE;
    case Jn.UNAUTHENTICATED:
      return $.UNAUTHENTICATED;
    case Jn.INVALID_ARGUMENT:
      return $.INVALID_ARGUMENT;
    case Jn.NOT_FOUND:
      return $.NOT_FOUND;
    case Jn.ALREADY_EXISTS:
      return $.ALREADY_EXISTS;
    case Jn.PERMISSION_DENIED:
      return $.PERMISSION_DENIED;
    case Jn.FAILED_PRECONDITION:
      return $.FAILED_PRECONDITION;
    case Jn.ABORTED:
      return $.ABORTED;
    case Jn.OUT_OF_RANGE:
      return $.OUT_OF_RANGE;
    case Jn.UNIMPLEMENTED:
      return $.UNIMPLEMENTED;
    case Jn.DATA_LOSS:
      return $.DATA_LOSS;
    default:
      return k2();
  }
}
(Yn = Jn || (Jn = {}))[Yn.OK = 0] = "OK", Yn[Yn.CANCELLED = 1] = "CANCELLED", Yn[Yn.UNKNOWN = 2] = "UNKNOWN", Yn[Yn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Yn[Yn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Yn[Yn.NOT_FOUND = 5] = "NOT_FOUND", Yn[Yn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Yn[Yn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Yn[Yn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Yn[Yn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Yn[Yn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Yn[Yn.ABORTED = 10] = "ABORTED", Yn[Yn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Yn[Yn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Yn[Yn.INTERNAL = 13] = "INTERNAL", Yn[Yn.UNAVAILABLE = 14] = "UNAVAILABLE", Yn[Yn.DATA_LOSS = 15] = "DATA_LOSS";
var ts = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (void 0 !== n) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return void 0 !== this.get(t2);
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (void 0 === s)
      return this.inner[n] = [[t2, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t2))
        return void (s[n2] = [t2, e]);
    s.push([t2, e]), this.innerSize++;
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (void 0 === n)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return 1 === n.length ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    Ot(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return Ft(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var es = new $t(ut.comparator);
function ns() {
  return es;
}
var ss = new $t(ut.comparator);
function is(...t2) {
  let e = ss;
  for (const n of t2)
    e = e.insert(n.key, n);
  return e;
}
function rs(t2) {
  let e = ss;
  return t2.forEach((t3, n) => e = e.insert(t3, n.overlayedDocument)), e;
}
function os() {
  return cs();
}
function us() {
  return cs();
}
function cs() {
  return new ts((t2) => t2.toString(), (t2, e) => t2.isEqual(e));
}
var as = new $t(ut.comparator);
var hs = new Ut(ut.comparator);
function ls(...t2) {
  let e = hs;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var fs = new Ut(X2);
function ds() {
  return fs;
}
var _s = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t2, ws.createSynthesizedTargetChangeForCurrentChange(t2, e)), new _s(nt.min(), n, ds(), ns(), ls());
  }
};
var ws = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new ws(jt.EMPTY_BYTE_STRING, e, ls(), ls(), ls());
  }
};
var ms = class {
  constructor(t2, e, n, s) {
    this.Tt = t2, this.removedTargetIds = e, this.key = n, this.Et = s;
  }
};
var gs = class {
  constructor(t2, e) {
    this.targetId = t2, this.At = e;
  }
};
var ys = class {
  constructor(t2, e, n = jt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var ps = class {
  constructor() {
    this.Rt = 0, this.bt = Es(), this.Pt = jt.EMPTY_BYTE_STRING, this.vt = false, this.Vt = true;
  }
  get current() {
    return this.vt;
  }
  get resumeToken() {
    return this.Pt;
  }
  get St() {
    return 0 !== this.Rt;
  }
  get Dt() {
    return this.Vt;
  }
  Ct(t2) {
    t2.approximateByteSize() > 0 && (this.Vt = true, this.Pt = t2);
  }
  xt() {
    let t2 = ls(), e = ls(), n = ls();
    return this.bt.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          k2();
      }
    }), new ws(this.Pt, this.vt, t2, e, n);
  }
  Nt() {
    this.Vt = false, this.bt = Es();
  }
  kt(t2, e) {
    this.Vt = true, this.bt = this.bt.insert(t2, e);
  }
  Mt(t2) {
    this.Vt = true, this.bt = this.bt.remove(t2);
  }
  Ot() {
    this.Rt += 1;
  }
  Ft() {
    this.Rt -= 1;
  }
  $t() {
    this.Vt = true, this.vt = true;
  }
};
var Is = class {
  constructor(t2) {
    this.Bt = t2, this.Lt = /* @__PURE__ */ new Map(), this.Ut = ns(), this.qt = Ts(), this.Kt = new Ut(X2);
  }
  Gt(t2) {
    for (const e of t2.Tt)
      t2.Et && t2.Et.isFoundDocument() ? this.Qt(e, t2.Et) : this.jt(e, t2.key, t2.Et);
    for (const e of t2.removedTargetIds)
      this.jt(e, t2.key, t2.Et);
  }
  Wt(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.zt(e);
      switch (t2.state) {
        case 0:
          this.Ht(e) && n.Ct(t2.resumeToken);
          break;
        case 1:
          n.Ft(), n.St || n.Nt(), n.Ct(t2.resumeToken);
          break;
        case 2:
          n.Ft(), n.St || this.removeTarget(e);
          break;
        case 3:
          this.Ht(e) && (n.$t(), n.Ct(t2.resumeToken));
          break;
        case 4:
          this.Ht(e) && (this.Jt(e), n.Ct(t2.resumeToken));
          break;
        default:
          k2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.Lt.forEach((t3, n) => {
      this.Ht(n) && e(n);
    });
  }
  Yt(t2) {
    const e = t2.targetId, n = t2.At.count, s = this.Xt(e);
    if (s) {
      const t3 = s.target;
      if (ke(t3))
        if (0 === n) {
          const n2 = new ut(t3.path);
          this.jt(e, n2, Ve.newNoDocument(n2, nt.min()));
        } else
          M2(1 === n);
      else {
        this.Zt(e) !== n && (this.Jt(e), this.Kt = this.Kt.add(e));
      }
    }
  }
  te(t2) {
    const e = /* @__PURE__ */ new Map();
    this.Lt.forEach((n2, s2) => {
      const i = this.Xt(s2);
      if (i) {
        if (n2.current && ke(i.target)) {
          const e2 = new ut(i.target.path);
          null !== this.Ut.get(e2) || this.ee(s2, e2) || this.jt(s2, e2, Ve.newNoDocument(e2, t2));
        }
        n2.Dt && (e.set(s2, n2.xt()), n2.Nt());
      }
    });
    let n = ls();
    this.qt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.Xt(t4);
        return !e3 || 2 === e3.purpose || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.Ut.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new _s(t2, e, this.Kt, this.Ut, n);
    return this.Ut = ns(), this.qt = Ts(), this.Kt = new Ut(X2), s;
  }
  Qt(t2, e) {
    if (!this.Ht(t2))
      return;
    const n = this.ee(t2, e.key) ? 2 : 0;
    this.zt(t2).kt(e.key, n), this.Ut = this.Ut.insert(e.key, e), this.qt = this.qt.insert(e.key, this.ne(e.key).add(t2));
  }
  jt(t2, e, n) {
    if (!this.Ht(t2))
      return;
    const s = this.zt(t2);
    this.ee(t2, e) ? s.kt(e, 1) : s.Mt(e), this.qt = this.qt.insert(e, this.ne(e).delete(t2)), n && (this.Ut = this.Ut.insert(e, n));
  }
  removeTarget(t2) {
    this.Lt.delete(t2);
  }
  Zt(t2) {
    const e = this.zt(t2).xt();
    return this.Bt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Ot(t2) {
    this.zt(t2).Ot();
  }
  zt(t2) {
    let e = this.Lt.get(t2);
    return e || (e = new ps(), this.Lt.set(t2, e)), e;
  }
  ne(t2) {
    let e = this.qt.get(t2);
    return e || (e = new Ut(X2), this.qt = this.qt.insert(t2, e)), e;
  }
  Ht(t2) {
    const e = null !== this.Xt(t2);
    return e || D2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  Xt(t2) {
    const e = this.Lt.get(t2);
    return e && e.St ? null : this.Bt.se(t2);
  }
  Jt(t2) {
    this.Lt.set(t2, new ps());
    this.Bt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.jt(t2, e, null);
    });
  }
  ee(t2, e) {
    return this.Bt.getRemoteKeysForTarget(t2).has(e);
  }
};
function Ts() {
  return new $t(ut.comparator);
}
function Es() {
  return new $t(ut.comparator);
}
var As = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var Rs = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var bs = class {
  constructor(t2, e) {
    this.databaseId = t2, this.gt = e;
  }
};
function Ps(t2, e) {
  if (t2.gt) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function vs(t2, e) {
  return t2.gt ? e.toBase64() : e.toUint8Array();
}
function Vs(t2, e) {
  return Ps(t2, e.toTimestamp());
}
function Ss(t2) {
  return M2(!!t2), nt.fromTimestamp(function(t3) {
    const e = zt(t3);
    return new et(e.seconds, e.nanos);
  }(t2));
}
function Ds(t2, e) {
  return function(t3) {
    return new it(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Cs(t2) {
  const e = it.fromString(t2);
  return M2(si(e)), e;
}
function xs(t2, e) {
  return Ds(t2.databaseId, e.path);
}
function Ns(t2, e) {
  const n = Cs(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new B2($.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new B2($.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new ut(Fs(n));
}
function ks(t2, e) {
  return Ds(t2.databaseId, e);
}
function Ms(t2) {
  const e = Cs(t2);
  return 4 === e.length ? it.emptyPath() : Fs(e);
}
function Os(t2) {
  return new it(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Fs(t2) {
  return M2(t2.length > 4 && "documents" === t2.get(4)), t2.popFirst(5);
}
function $s(t2, e, n) {
  return {
    name: xs(t2, e),
    fields: n.value.mapValue.fields
  };
}
function Bs(t2, e, n) {
  const s = Ns(t2, e.name), i = Ss(e.updateTime), r = new Pe({
    mapValue: {
      fields: e.fields
    }
  }), o = Ve.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function Ls(t2, e) {
  return "found" in e ? function(t3, e2) {
    M2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Ns(t3, e2.found.name), s = Ss(e2.found.updateTime), i = new Pe({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Ve.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    M2(!!e2.missing), M2(!!e2.readTime);
    const n = Ns(t3, e2.missing), s = Ss(e2.readTime);
    return Ve.newNoDocument(n, s);
  }(t2, e) : k2();
}
function Us(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return "NO_CHANGE" === t3 ? 0 : "ADD" === t3 ? 1 : "REMOVE" === t3 ? 2 : "CURRENT" === t3 ? 3 : "RESET" === t3 ? 4 : k2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.gt ? (M2(void 0 === e2 || "string" == typeof e2), jt.fromBase64String(e2 || "")) : (M2(void 0 === e2 || e2 instanceof Uint8Array), jt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, u = o && function(t3) {
      const e2 = void 0 === t3.code ? $.UNKNOWN : Zn(t3.code);
      return new B2(e2, t3.message || "");
    }(o);
    n = new ys(s, i, r, u || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Ns(t2, s.document.name), r = Ss(s.document.updateTime), o = new Pe({
      mapValue: {
        fields: s.document.fields
      }
    }), u = Ve.newFoundDocument(i, r, o), c = s.targetIds || [], a = s.removedTargetIds || [];
    n = new ms(c, a, u.key, u);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Ns(t2, s.document), r = s.readTime ? Ss(s.readTime) : nt.min(), o = Ve.newNoDocument(i, r), u = s.removedTargetIds || [];
    n = new ms([], u, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Ns(t2, s.document), r = s.removedTargetIds || [];
    n = new ms([], r, i, null);
  } else {
    if (!("filter" in e))
      return k2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new Hn(s), r = t3.targetId;
      n = new gs(r, i);
    }
  }
  return n;
}
function qs(t2, e) {
  let n;
  if (e instanceof qn)
    n = {
      update: $s(t2, e.key, e.value)
    };
  else if (e instanceof Wn)
    n = {
      delete: xs(t2, e.key)
    };
  else if (e instanceof Kn)
    n = {
      update: $s(t2, e.key, e.data),
      updateMask: ni(e.fieldMask)
    };
  else {
    if (!(e instanceof zn))
      return k2();
    n = {
      verify: xs(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof An)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Rn)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Pn)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Vn)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.yt
      };
    throw k2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return void 0 !== e2.updateTime ? {
      updateTime: Vs(t3, e2.updateTime)
    } : void 0 !== e2.exists ? {
      exists: e2.exists
    } : k2();
  }(t2, e.precondition)), n;
}
function Ks(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return void 0 !== t3.updateTime ? kn.updateTime(Ss(t3.updateTime)) : void 0 !== t3.exists ? kn.exists(t3.exists) : kn.none();
  }(e.currentDocument) : kn.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      M2("REQUEST_TIME" === e3.setToServerValue), n2 = new An();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Rn(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Pn(t4);
    } else
      "increment" in e3 ? n2 = new Vn(t3, e3.increment) : k2();
    const s2 = ot.fromServerFormat(e3.fieldPath);
    return new Cn(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Ns(t2, e.update.name), r = new Pe({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new Gt(e2.map((t5) => ot.fromServerFormat(t5)));
      }(e.updateMask);
      return new Kn(i, r, t3, n, s);
    }
    return new qn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Ns(t2, e.delete);
    return new Wn(s2, n);
  }
  if (e.verify) {
    const s2 = Ns(t2, e.verify);
    return new zn(s2, n);
  }
  return k2();
}
function Gs(t2, e) {
  return t2 && t2.length > 0 ? (M2(void 0 !== e), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? Ss(t4.updateTime) : Ss(e2);
    return n.isEqual(nt.min()) && (n = Ss(e2)), new Nn(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function Qs(t2, e) {
  return {
    documents: [ks(t2, e.path)]
  };
}
function js(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  null !== e.collectionGroup ? (n.parent = ks(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = ks(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (0 === t3.length)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if ("==" === t5.op) {
        if (ye(t5.value))
          return {
            unaryFilter: {
              field: Xs(t5.field),
              op: "IS_NAN"
            }
          };
        if (ge(t5.value))
          return {
            unaryFilter: {
              field: Xs(t5.field),
              op: "IS_NULL"
            }
          };
      } else if ("!=" === t5.op) {
        if (ye(t5.value))
          return {
            unaryFilter: {
              field: Xs(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (ge(t5.value))
          return {
            unaryFilter: {
              field: Xs(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Xs(t5.field),
          op: Ys(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (1 === e2.length)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (0 === t3.length)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Xs(t5.field),
        direction: Js(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.gt || ne(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var u;
  return null !== o && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function Ws(t2) {
  let e = Ms(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    M2(1 === s);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = Hs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new ze(
      Zs(t4.field),
      function(t5) {
        switch (t5) {
          case "ASCENDING":
            return "asc";
          case "DESCENDING":
            return "desc";
          default:
            return;
        }
      }(t4.direction)
    );
  }(t3)));
  let u = null;
  n.limit && (u = function(t3) {
    let e2;
    return e2 = "object" == typeof t3 ? t3.value : t3, ne(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new We(n2, e2);
  }(n.startAt));
  let a = null;
  return n.endAt && (a = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new We(n2, e2);
  }(n.endAt)), Ze(e, i, o, r, u, "F", c, a);
}
function zs(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return k2();
    }
  }(0, e.purpose);
  return null == n ? null : {
    "goog-listen-tags": n
  };
}
function Hs(t2) {
  return t2 ? void 0 !== t2.unaryFilter ? [ei(t2)] : void 0 !== t2.fieldFilter ? [ti(t2)] : void 0 !== t2.compositeFilter ? t2.compositeFilter.filters.map((t3) => Hs(t3)).reduce((t3, e) => t3.concat(e)) : k2() : [];
}
function Js(t2) {
  return As[t2];
}
function Ys(t2) {
  return Rs[t2];
}
function Xs(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function Zs(t2) {
  return ot.fromServerFormat(t2.fieldPath);
}
function ti(t2) {
  return $e.create(Zs(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return k2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ei(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = Zs(t2.unaryFilter.field);
      return $e.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = Zs(t2.unaryFilter.field);
      return $e.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = Zs(t2.unaryFilter.field);
      return $e.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = Zs(t2.unaryFilter.field);
      return $e.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return k2();
  }
}
function ni(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function si(t2) {
  return t2.length >= 4 && "projects" === t2.get(0) && "databases" === t2.get(2);
}
function ii(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = oi(e)), e = ri(t2.get(n), e);
  return oi(e);
}
function ri(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function oi(t2) {
  return t2 + "";
}
function ui(t2) {
  const e = t2.length;
  if (M2(e >= 2), 2 === e)
    return M2("" === t2.charAt(0) && "" === t2.charAt(1)), it.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && k2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        0 === i.length ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        k2();
    }
    r = e2 + 2;
  }
  return new it(s);
}
var ci = ["userId", "batchId"];
function ai(t2, e) {
  return [t2, ii(e)];
}
function hi(t2, e, n) {
  return [t2, ii(e), n];
}
var li = {};
var fi = ["prefixPath", "collectionGroup", "readTime", "documentId"];
var di = ["prefixPath", "collectionGroup", "documentId"];
var _i = ["collectionGroup", "readTime", "prefixPath", "documentId"];
var wi = ["canonicalId", "targetId"];
var mi = ["targetId", "path"];
var gi = ["path", "targetId"];
var yi = ["collectionId", "parent"];
var pi = ["indexId", "uid"];
var Ii = ["uid", "sequenceNumber"];
var Ti = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"];
var Ei = ["indexId", "uid", "orderedDocumentKey"];
var Ai = ["userId", "collectionPath", "documentId"];
var Ri = ["userId", "collectionPath", "largestBatchId"];
var bi = ["userId", "collectionGroup", "largestBatchId"];
var Pi = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var vi = [...Pi, "documentOverlays"];
var Vi = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
var Si = Vi;
var Di = [...Si, "indexConfiguration", "indexState", "indexEntries"];
var Ci = class extends It {
  constructor(t2, e) {
    super(), this.ie = t2, this.currentSequenceNumber = e;
  }
};
function xi(t2, e) {
  const n = F(t2);
  return Rt.O(n.ie, e);
}
var Ni = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        $n(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2, e) {
    for (const n of this.baseMutations)
      n.key.isEqual(t2.key) && (e = Bn(n, t2, e, this.localWriteTime));
    for (const n of this.mutations)
      n.key.isEqual(t2.key) && (e = Bn(n, t2, e, this.localWriteTime));
    return e;
  }
  applyToLocalDocumentSet(t2, e) {
    const n = us();
    return this.mutations.forEach((s) => {
      const i = t2.get(s.key), r = i.overlayedDocument;
      let o = this.applyToLocalView(r, i.mutatedFields);
      o = e.has(s.key) ? null : o;
      const u = Fn(r, o);
      null !== u && n.set(s.key, u), r.isValidDocument() || r.convertToNoDocument(nt.min());
    }), n;
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), ls());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && Z(this.mutations, t2.mutations, (t3, e) => Un(t3, e)) && Z(this.baseMutations, t2.baseMutations, (t3, e) => Un(t3, e));
  }
};
var ki = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    M2(t2.mutations.length === n.length);
    let s = as;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new ki(t2, e, n, s);
  }
};
var Mi = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return null !== t2 && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var Oi = class {
  constructor(t2, e, n, s, i = nt.min(), r = nt.min(), o = jt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new Oi(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new Oi(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new Oi(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var Fi = class {
  constructor(t2) {
    this.re = t2;
  }
};
function $i(t2, e) {
  let n;
  if (e.document)
    n = Bs(t2.re, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = ut.fromSegments(e.noDocument.path), s = qi(e.noDocument.readTime);
    n = Ve.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return k2();
    {
      const t3 = ut.fromSegments(e.unknownDocument.path), s = qi(e.unknownDocument.version);
      n = Ve.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(function(t3) {
    const e2 = new et(t3[0], t3[1]);
    return nt.fromTimestamp(e2);
  }(e.readTime)), n;
}
function Bi(t2, e) {
  const n = e.key, s = {
    prefixPath: n.getCollectionPath().popLast().toArray(),
    collectionGroup: n.collectionGroup,
    documentId: n.path.lastSegment(),
    readTime: Li(e.readTime),
    hasCommittedMutations: e.hasCommittedMutations
  };
  if (e.isFoundDocument())
    s.document = function(t3, e2) {
      return {
        name: xs(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Ps(t3, e2.version.toTimestamp())
      };
    }(t2.re, e);
  else if (e.isNoDocument())
    s.noDocument = {
      path: n.path.toArray(),
      readTime: Ui(e.version)
    };
  else {
    if (!e.isUnknownDocument())
      return k2();
    s.unknownDocument = {
      path: n.path.toArray(),
      version: Ui(e.version)
    };
  }
  return s;
}
function Li(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Ui(t2) {
  const e = t2.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function qi(t2) {
  const e = new et(t2.seconds, t2.nanoseconds);
  return nt.fromTimestamp(e);
}
function Ki(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Ks(t2.re, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && void 0 !== e.mutations[t3 + 1].transform) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Ks(t2.re, e2)), i = et.fromMillis(e.localWriteTimeMs);
  return new Ni(e.batchId, i, n, s);
}
function Gi(t2) {
  const e = qi(t2.readTime), n = void 0 !== t2.lastLimboFreeSnapshotVersion ? qi(t2.lastLimboFreeSnapshotVersion) : nt.min();
  let s;
  var i;
  return void 0 !== t2.query.documents ? (M2(1 === (i = t2.query).documents.length), s = un(tn(Ms(i.documents[0])))) : s = function(t3) {
    return un(Ws(t3));
  }(t2.query), new Oi(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, jt.fromBase64String(t2.resumeToken));
}
function Qi(t2, e) {
  const n = Ui(e.snapshotVersion), s = Ui(e.lastLimboFreeSnapshotVersion);
  let i;
  i = ke(e.target) ? Qs(t2.re, e.target) : js(t2.re, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: Ce(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function ji(t2) {
  const e = Ws({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return "LAST" === t2.limitType ? cn(e, e.limit, "L") : e;
}
function Wi(t2, e) {
  return new Mi(e.largestBatchId, Ks(t2.re, e.overlayMutation));
}
function zi(t2, e) {
  const n = e.path.lastSegment();
  return [t2, ii(e.path.popLast()), n];
}
function Hi(t2, e, n, s) {
  return {
    indexId: t2,
    uid: e.uid || "",
    sequenceNumber: n,
    readTime: Ui(s.readTime),
    documentKey: ii(s.documentKey.path),
    largestBatchId: s.largestBatchId
  };
}
var Ji = class {
  getBundleMetadata(t2, e) {
    return Yi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: qi(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return Yi(t2).put({
      bundleId: (n = e).id,
      createTime: Ui(Ss(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return Xi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: ji(e2.bundledQuery),
          readTime: qi(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return Xi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Ui(Ss(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function Yi(t2) {
  return xi(t2, "bundles");
}
function Xi(t2) {
  return xi(t2, "namedQueries");
}
var Zi = class {
  constructor(t2, e) {
    this.It = t2, this.userId = e;
  }
  static oe(t2, e) {
    const n = e.uid || "";
    return new Zi(t2, n);
  }
  getOverlay(t2, e) {
    return tr(t2).get(zi(this.userId, e)).next((t3) => t3 ? Wi(this.It, t3) : null);
  }
  getOverlays(t2, e) {
    const n = os();
    return Et.forEach(e, (e2) => this.getOverlay(t2, e2).next((t3) => {
      null !== t3 && n.set(e2, t3);
    })).next(() => n);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Mi(e, i);
      s.push(this.ue(t2, r));
    }), Et.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add(ii(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound(
        [this.userId, e2, n],
        [this.userId, e2, n + 1],
        false,
        true
      );
      i.push(tr(t2).Y("collectionPathOverlayIndex", s2));
    }), Et.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = os(), i = ii(e), r = IDBKeyRange.bound(
      [this.userId, i, n],
      [this.userId, i, Number.POSITIVE_INFINITY],
      true
    );
    return tr(t2).W("collectionPathOverlayIndex", r).next((t3) => {
      for (const e2 of t3) {
        const t4 = Wi(this.It, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = os();
    let r;
    const o = IDBKeyRange.bound(
      [this.userId, e, n],
      [this.userId, e, Number.POSITIVE_INFINITY],
      true
    );
    return tr(t2).Z({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t3, e2, n2) => {
      const o2 = Wi(this.It, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  ue(t2, e) {
    return tr(t2).put(function(t3, e2, n) {
      const [s, i, r] = zi(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: qs(t3.re, n.mutation)
      };
    }(this.It, this.userId, e));
  }
};
function tr(t2) {
  return xi(t2, "documentOverlays");
}
var er = class {
  constructor() {
  }
  ce(t2, e) {
    this.ae(t2, e), e.he();
  }
  ae(t2, e) {
    if ("nullValue" in t2)
      this.le(e, 5);
    else if ("booleanValue" in t2)
      this.le(e, 10), e.fe(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.le(e, 15), e.fe(Ht(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Ht(t2.doubleValue);
      isNaN(n) ? this.le(e, 13) : (this.le(e, 15), se(n) ? e.fe(0) : e.fe(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.le(e, 20), "string" == typeof n ? e.de(n) : (e.de(`${n.seconds || ""}`), e.fe(n.nanos || 0));
    } else if ("stringValue" in t2)
      this._e(t2.stringValue, e), this.we(e);
    else if ("bytesValue" in t2)
      this.le(e, 30), e.me(Jt(t2.bytesValue)), this.we(e);
    else if ("referenceValue" in t2)
      this.ge(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.le(e, 45), e.fe(n.latitude || 0), e.fe(n.longitude || 0);
    } else
      "mapValue" in t2 ? Te(t2) ? this.le(e, Number.MAX_SAFE_INTEGER) : (this.ye(t2.mapValue, e), this.we(e)) : "arrayValue" in t2 ? (this.pe(t2.arrayValue, e), this.we(e)) : k2();
  }
  _e(t2, e) {
    this.le(e, 25), this.Ie(t2, e);
  }
  Ie(t2, e) {
    e.de(t2);
  }
  ye(t2, e) {
    const n = t2.fields || {};
    this.le(e, 55);
    for (const t3 of Object.keys(n))
      this._e(t3, e), this.ae(n[t3], e);
  }
  pe(t2, e) {
    const n = t2.values || [];
    this.le(e, 50);
    for (const t3 of n)
      this.ae(t3, e);
  }
  ge(t2, e) {
    this.le(e, 37);
    ut.fromName(t2).path.forEach((t3) => {
      this.le(e, 60), this.Ie(t3, e);
    });
  }
  le(t2, e) {
    t2.fe(e);
  }
  we(t2) {
    t2.fe(2);
  }
};
er.Te = new er();
function nr(t2) {
  if (0 === t2)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function sr(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = nr(255 & t3[n]);
      if (e2 += s, 8 !== s)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var ir = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  Ee(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Ae(n.value), n = e.next();
    this.Re();
  }
  be(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Pe(n.value), n = e.next();
    this.ve();
  }
  Ve(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.Ae(t3);
      else if (t3 < 2048)
        this.Ae(960 | t3 >>> 6), this.Ae(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Ae(480 | t3 >>> 12), this.Ae(128 | 63 & t3 >>> 6), this.Ae(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.Ae(240 | t4 >>> 18), this.Ae(128 | 63 & t4 >>> 12), this.Ae(128 | 63 & t4 >>> 6), this.Ae(128 | 63 & t4);
      }
    }
    this.Re();
  }
  Se(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.Pe(t3);
      else if (t3 < 2048)
        this.Pe(960 | t3 >>> 6), this.Pe(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Pe(480 | t3 >>> 12), this.Pe(128 | 63 & t3 >>> 6), this.Pe(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.Pe(240 | t4 >>> 18), this.Pe(128 | 63 & t4 >>> 12), this.Pe(128 | 63 & t4 >>> 6), this.Pe(128 | 63 & t4);
      }
    }
    this.ve();
  }
  De(t2) {
    const e = this.Ce(t2), n = sr(e);
    this.xe(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  Ne(t2) {
    const e = this.Ce(t2), n = sr(e);
    this.xe(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  ke() {
    this.Me(255), this.Me(255);
  }
  Oe() {
    this.Fe(255), this.Fe(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.xe(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  $e() {
    return this.buffer.slice(0, this.position);
  }
  Ce(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = 0 != (128 & e[0]);
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  Ae(t2) {
    const e = 255 & t2;
    0 === e ? (this.Me(0), this.Me(255)) : 255 === e ? (this.Me(255), this.Me(0)) : this.Me(e);
  }
  Pe(t2) {
    const e = 255 & t2;
    0 === e ? (this.Fe(0), this.Fe(255)) : 255 === e ? (this.Fe(255), this.Fe(0)) : this.Fe(t2);
  }
  Re() {
    this.Me(0), this.Me(1);
  }
  ve() {
    this.Fe(0), this.Fe(1);
  }
  Me(t2) {
    this.xe(1), this.buffer[this.position++] = t2;
  }
  Fe(t2) {
    this.xe(1), this.buffer[this.position++] = ~t2;
  }
  xe(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var rr = class {
  constructor(t2) {
    this.Be = t2;
  }
  me(t2) {
    this.Be.Ee(t2);
  }
  de(t2) {
    this.Be.Ve(t2);
  }
  fe(t2) {
    this.Be.De(t2);
  }
  he() {
    this.Be.ke();
  }
};
var or = class {
  constructor(t2) {
    this.Be = t2;
  }
  me(t2) {
    this.Be.be(t2);
  }
  de(t2) {
    this.Be.Se(t2);
  }
  fe(t2) {
    this.Be.Ne(t2);
  }
  he() {
    this.Be.Oe();
  }
};
var ur = class {
  constructor() {
    this.Be = new ir(), this.Le = new rr(this.Be), this.Ue = new or(this.Be);
  }
  seed(t2) {
    this.Be.seed(t2);
  }
  qe(t2) {
    return 0 === t2 ? this.Le : this.Ue;
  }
  $e() {
    return this.Be.$e();
  }
  reset() {
    this.Be.reset();
  }
};
var cr = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  Ke() {
    const t2 = this.directionalValue.length, e = 0 === t2 || 255 === this.directionalValue[t2 - 1] ? t2 + 1 : t2, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t2 ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new cr(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function ar(t2, e) {
  let n = t2.indexId - e.indexId;
  return 0 !== n ? n : (n = hr(t2.arrayValue, e.arrayValue), 0 !== n ? n : (n = hr(t2.directionalValue, e.directionalValue), 0 !== n ? n : ut.comparator(t2.documentKey, e.documentKey)));
}
function hr(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (0 !== s)
      return s;
  }
  return t2.length - e.length;
}
var lr = class {
  constructor(t2) {
    this.collectionId = null != t2.collectionGroup ? t2.collectionGroup : t2.path.lastSegment(), this.Ge = t2.orderBy, this.Qe = [];
    for (const e of t2.filters) {
      const t3 = e;
      t3.dt() ? this.je = t3 : this.Qe.push(t3);
    }
  }
  We(t2) {
    const e = at(t2);
    if (void 0 !== e && !this.ze(e))
      return false;
    const n = ht(t2);
    let s = 0, i = 0;
    for (; s < n.length && this.ze(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (void 0 !== this.je) {
      const t3 = n[s];
      if (!this.He(this.je, t3) || !this.Je(this.Ge[i++], t3))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t3 = n[s];
      if (i >= this.Ge.length || !this.Je(this.Ge[i++], t3))
        return false;
    }
    return true;
  }
  ze(t2) {
    for (const e of this.Qe)
      if (this.He(e, t2))
        return true;
    return false;
  }
  He(t2, e) {
    if (void 0 === t2 || !t2.field.isEqual(e.fieldPath))
      return false;
    const n = "array-contains" === t2.op || "array-contains-any" === t2.op;
    return 2 === e.kind === n;
  }
  Je(t2, e) {
    return !!t2.field.isEqual(e.fieldPath) && (0 === e.kind && "asc" === t2.dir || 1 === e.kind && "desc" === t2.dir);
  }
};
var fr = class {
  constructor() {
    this.Ye = new dr();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Ye.add(e), Et.resolve();
  }
  getCollectionParents(t2, e) {
    return Et.resolve(this.Ye.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return Et.resolve();
  }
  deleteFieldIndex(t2, e) {
    return Et.resolve();
  }
  getDocumentsMatchingTarget(t2, e) {
    return Et.resolve(null);
  }
  getIndexType(t2, e) {
    return Et.resolve(0);
  }
  getFieldIndexes(t2, e) {
    return Et.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return Et.resolve(null);
  }
  getMinOffset(t2, e) {
    return Et.resolve(gt.min());
  }
  getMinOffsetFromCollectionGroup(t2, e) {
    return Et.resolve(gt.min());
  }
  updateCollectionGroup(t2, e, n) {
    return Et.resolve();
  }
  updateIndexEntries(t2, e) {
    return Et.resolve();
  }
};
var dr = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new Ut(it.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new Ut(it.comparator)).toArray();
  }
};
var _r = new Uint8Array(0);
var wr = class {
  constructor(t2, e) {
    this.user = t2, this.databaseId = e, this.Xe = new dr(), this.Ze = new ts((t3) => Ce(t3), (t3, e2) => Ne(t3, e2)), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Xe.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Xe.add(e);
      });
      const i = {
        collectionId: n,
        parent: ii(s)
      };
      return mr(t2).put(i);
    }
    return Et.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound(
      [e, ""],
      [tt(e), ""],
      false,
      true
    );
    return mr(t2).W(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(ui(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = yr(t2), s = function(t3) {
      return {
        indexId: t3.indexId,
        collectionGroup: t3.collectionGroup,
        fields: t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind])
      };
    }(e);
    delete s.indexId;
    const i = n.add(s);
    if (e.indexState) {
      const n2 = pr(t2);
      return i.next((t3) => {
        n2.put(Hi(t3, this.user, e.indexState.sequenceNumber, e.indexState.offset));
      });
    }
    return i.next();
  }
  deleteFieldIndex(t2, e) {
    const n = yr(t2), s = pr(t2), i = gr(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound(
      [e.indexId],
      [e.indexId + 1],
      false,
      true
    ))).next(() => i.delete(IDBKeyRange.bound(
      [e.indexId],
      [e.indexId + 1],
      false,
      true
    )));
  }
  getDocumentsMatchingTarget(t2, e) {
    const n = gr(t2);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return Et.forEach(this.tn(e), (e2) => this.en(t2, e2).next((t3) => {
      s && (s = !!t3), i.set(e2, t3);
    })).next(() => {
      if (s) {
        let t3 = ls();
        const s2 = [];
        return Et.forEach(i, (i2, r) => {
          var o;
          D2("IndexedDbIndexManager", `Using index ${o = i2, `id=${o.indexId}|cg=${o.collectionGroup}|f=${o.fields.map((t4) => `${t4.fieldPath}:${t4.kind}`).join(",")}`} to execute ${Ce(e)}`);
          const u = function(t4, e2) {
            const n2 = at(e2);
            if (void 0 === n2)
              return null;
            for (const e3 of Me(t4, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(r, i2), c = function(t4, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of ht(e2))
              for (const e3 of Me(t4, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(r, i2), a = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of ht(e2)) {
              const e3 = 0 === i3.kind ? Oe(t4, i3.fieldPath, t4.startAt) : Fe(t4, i3.fieldPath, t4.startAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new We(n2, s3);
          }(r, i2), h = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of ht(e2)) {
              const e3 = 0 === i3.kind ? Fe(t4, i3.fieldPath, t4.endAt) : Oe(t4, i3.fieldPath, t4.endAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new We(n2, s3);
          }(r, i2), l2 = this.nn(i2, r, a), f = this.nn(i2, r, h), d = this.sn(i2, r, c), _ = this.rn(i2.indexId, u, l2, a.inclusive, f, h.inclusive, d);
          return Et.forEach(_, (i3) => n.J(i3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              const n2 = ut.fromSegments(e3.documentKey);
              t3.has(n2) || (t3 = t3.add(n2), s2.push(n2));
            });
          }));
        }).next(() => s2);
      }
      return Et.resolve(null);
    });
  }
  tn(t2) {
    let e = this.Ze.get(t2);
    return e || (e = [t2], this.Ze.set(t2, e), e);
  }
  rn(t2, e, n, s, i, r, o) {
    const u = (null != e ? e.length : 1) * Math.max(n.length, i.length), c = u / (null != e ? e.length : 1), a = [];
    for (let h = 0; h < u; ++h) {
      const u2 = e ? this.on(e[h / c]) : _r, l2 = this.un(t2, u2, n[h % c], s), f = this.cn(t2, u2, i[h % c], r), d = o.map((e2) => this.un(
        t2,
        u2,
        e2,
        true
      ));
      a.push(...this.createRange(l2, f, d));
    }
    return a;
  }
  un(t2, e, n, s) {
    const i = new cr(t2, ut.empty(), e, n);
    return s ? i : i.Ke();
  }
  cn(t2, e, n, s) {
    const i = new cr(t2, ut.empty(), e, n);
    return s ? i.Ke() : i;
  }
  en(t2, e) {
    const n = new lr(e), s = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t2, s).next((t3) => {
      let e2 = null;
      for (const s2 of t3) {
        n.We(s2) && (!e2 || s2.fields.length > e2.fields.length) && (e2 = s2);
      }
      return e2;
    });
  }
  getIndexType(t2, e) {
    let n = 2;
    return Et.forEach(this.tn(e), (e2) => this.en(t2, e2).next((t3) => {
      t3 ? 0 !== n && t3.fields.length < function(t4) {
        let e3 = new Ut(ot.comparator), n2 = false;
        for (const s of t4.filters) {
          const t5 = s;
          t5.field.isKeyField() || ("array-contains" === t5.op || "array-contains-any" === t5.op ? n2 = true : e3 = e3.add(t5.field));
        }
        for (const n3 of t4.orderBy)
          n3.field.isKeyField() || (e3 = e3.add(n3.field));
        return e3.size + (n2 ? 1 : 0);
      }(e2) && (n = 1) : n = 0;
    })).next(() => n);
  }
  an(t2, e) {
    const n = new ur();
    for (const s of ht(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (null == t3)
        return null;
      const i = n.qe(s.kind);
      er.Te.ce(t3, i);
    }
    return n.$e();
  }
  on(t2) {
    const e = new ur();
    return er.Te.ce(t2, e.qe(0)), e.$e();
  }
  hn(t2, e) {
    const n = new ur();
    return er.Te.ce(_e(this.databaseId, e), n.qe(function(t3) {
      const e2 = ht(t3);
      return 0 === e2.length ? 0 : e2[e2.length - 1].kind;
    }(t2))), n.$e();
  }
  sn(t2, e, n) {
    if (null === n)
      return [];
    let s = [];
    s.push(new ur());
    let i = 0;
    for (const r of ht(t2)) {
      const t3 = n[i++];
      for (const n2 of s)
        if (this.ln(e, r.fieldPath) && me(t3))
          s = this.fn(s, r, t3);
        else {
          const e2 = n2.qe(r.kind);
          er.Te.ce(t3, e2);
        }
    }
    return this.dn(s);
  }
  nn(t2, e, n) {
    return this.sn(t2, e, n.position);
  }
  dn(t2) {
    const e = [];
    for (let n = 0; n < t2.length; ++n)
      e[n] = t2[n].$e();
    return e;
  }
  fn(t2, e, n) {
    const s = [...t2], i = [];
    for (const t3 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new ur();
        s2.seed(n2.$e()), er.Te.ce(t3, s2.qe(e.kind)), i.push(s2);
      }
    return i;
  }
  ln(t2, e) {
    return !!t2.filters.find((t3) => t3 instanceof $e && t3.field.isEqual(e) && ("in" === t3.op || "not-in" === t3.op));
  }
  getFieldIndexes(t2, e) {
    const n = yr(t2), s = pr(t2);
    return (e ? n.W("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.W()).next((t3) => {
      const e2 = [];
      return Et.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new _t(e3.sequenceNumber, new gt(qi(e3.readTime), new ut(ui(e3.documentKey)), e3.largestBatchId)) : _t.empty(), s2 = t5.fields.map(([t6, e4]) => new ft(ot.fromServerFormat(t6), e4));
          return new ct(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => 0 === t3.length ? null : (t3.sort((t4, e) => {
      const n = t4.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return 0 !== n ? n : X2(t4.collectionGroup, e.collectionGroup);
    }), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = yr(t2), i = pr(t2);
    return this._n(t2).next((t3) => s.W("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => Et.forEach(e2, (e3) => i.put(Hi(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return Et.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? Et.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), Et.forEach(i2, (n2) => this.wn(t2, e2, n2).next((e3) => {
        const i3 = this.mn(s, n2);
        return e3.isEqual(i3) ? Et.resolve() : this.gn(t2, s, n2, e3, i3);
      }))));
    });
  }
  yn(t2, e, n, s) {
    return gr(t2).put({
      indexId: s.indexId,
      uid: this.uid,
      arrayValue: s.arrayValue,
      directionalValue: s.directionalValue,
      orderedDocumentKey: this.hn(n, e.key),
      documentKey: e.key.path.toArray()
    });
  }
  pn(t2, e, n, s) {
    return gr(t2).delete([s.indexId, this.uid, s.arrayValue, s.directionalValue, this.hn(n, e.key), e.key.path.toArray()]);
  }
  wn(t2, e, n) {
    const s = gr(t2);
    let i = new Ut(ar);
    return s.Z({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, this.hn(n, e)])
    }, (t3, s2) => {
      i = i.add(new cr(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  mn(t2, e) {
    let n = new Ut(ar);
    const s = this.an(e, t2);
    if (null == s)
      return n;
    const i = at(e);
    if (null != i) {
      const r = t2.data.field(i.fieldPath);
      if (me(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new cr(e.indexId, t2.key, this.on(i2), s));
    } else
      n = n.add(new cr(e.indexId, t2.key, _r, s));
    return n;
  }
  gn(t2, e, n, s, i) {
    D2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const r = [];
    return function(t3, e2, n2, s2, i2) {
      const r2 = t3.getIterator(), o = e2.getIterator();
      let u = Kt(r2), c = Kt(o);
      for (; u || c; ) {
        let t4 = false, e3 = false;
        if (u && c) {
          const s3 = n2(u, c);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          null != u ? e3 = true : t4 = true;
        t4 ? (s2(c), c = Kt(o)) : e3 ? (i2(u), u = Kt(r2)) : (u = Kt(r2), c = Kt(o));
      }
    }(s, i, ar, (s2) => {
      r.push(this.yn(t2, e, n, s2));
    }, (s2) => {
      r.push(this.pn(t2, e, n, s2));
    }), Et.waitFor(r);
  }
  _n(t2) {
    let e = 1;
    return pr(t2).Z({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t2, e, n) {
    n = n.sort((t3, e2) => ar(t3, e2)).filter((t3, e2, n2) => !e2 || 0 !== ar(t3, n2[e2 - 1]));
    const s = [];
    s.push(t2);
    for (const i2 of n) {
      const n2 = ar(i2, t2), r = ar(i2, e);
      if (0 === n2)
        s[0] = t2.Ke();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.Ke());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t3 = 0; t3 < s.length; t3 += 2)
      i.push(IDBKeyRange.bound([s[t3].indexId, this.uid, s[t3].arrayValue, s[t3].directionalValue, _r, []], [s[t3 + 1].indexId, this.uid, s[t3 + 1].arrayValue, s[t3 + 1].directionalValue, _r, []]));
    return i;
  }
  getMinOffsetFromCollectionGroup(t2, e) {
    return this.getFieldIndexes(t2, e).next(Ir);
  }
  getMinOffset(t2, e) {
    return Et.mapArray(this.tn(e), (e2) => this.en(t2, e2).next((t3) => t3 || k2())).next(Ir);
  }
};
function mr(t2) {
  return xi(t2, "collectionParents");
}
function gr(t2) {
  return xi(t2, "indexEntries");
}
function yr(t2) {
  return xi(t2, "indexConfiguration");
}
function pr(t2) {
  return xi(t2, "indexState");
}
function Ir(t2) {
  M2(0 !== t2.length);
  let e = t2[0].indexState.offset, n = e.largestBatchId;
  for (let s = 1; s < t2.length; s++) {
    const i = t2[s].indexState.offset;
    yt(i, e) < 0 && (e = i), n < i.largestBatchId && (n = i.largestBatchId);
  }
  return new gt(e.readTime, e.documentKey, n);
}
var Tr = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Er = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Er(t2, Er.DEFAULT_COLLECTION_PERCENTILE, Er.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function Ar(t2, e, n) {
  const s = t2.store("mutations"), i = t2.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let u = 0;
  const c = s.Z({
    range: o
  }, (t3, e2, n2) => (u++, n2.delete()));
  r.push(c.next(() => {
    M2(1 === u);
  }));
  const a = [];
  for (const t3 of n.mutations) {
    const s2 = hi(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), a.push(t3.key);
  }
  return Et.waitFor(r).next(() => a);
}
function Rr(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw k2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Er.DEFAULT_COLLECTION_PERCENTILE = 10, Er.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Er.DEFAULT = new Er(41943040, Er.DEFAULT_COLLECTION_PERCENTILE, Er.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Er.DISABLED = new Er(-1, 0, 0);
var br = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.It = e, this.indexManager = n, this.referenceDelegate = s, this.In = {};
  }
  static oe(t2, e, n, s) {
    M2("" !== t2.uid);
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new br(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return vr(t2).Z({
      index: "userMutationsIndex",
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = Vr(t2), r = vr(t2);
    return r.add({}).next((o) => {
      M2("number" == typeof o);
      const u = new Ni(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => qs(t3.re, e3)), i2 = n2.mutations.map((e3) => qs(t3.re, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.It, this.userId, u), a = [];
      let h = new Ut((t3, e2) => X2(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = hi(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), a.push(r.put(c)), a.push(i.put(e2, li));
      }
      return h.forEach((e2) => {
        a.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.In[o] = u.keys();
      }), Et.waitFor(a).next(() => u);
    });
  }
  lookupMutationBatch(t2, e) {
    return vr(t2).get(e).next((t3) => t3 ? (M2(t3.userId === this.userId), Ki(this.It, t3)) : null);
  }
  Tn(t2, e) {
    return this.In[e] ? Et.resolve(this.In[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.In[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return vr(t2).Z({
      index: "userMutationsIndex",
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (M2(e2.batchId >= n), i = Ki(this.It, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return vr(t2).Z({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return vr(t2).W("userMutationsIndex", e).next((t3) => t3.map((t4) => Ki(this.It, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = ai(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return Vr(t2).Z({
      range: s
    }, (n2, s2, r) => {
      const [o, u, c] = n2, a = ui(u);
      if (o === this.userId && e.path.isEqual(a))
        return vr(t2).get(c).next((t3) => {
          if (!t3)
            throw k2();
          M2(t3.userId === this.userId), i.push(Ki(this.It, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Ut(X2);
    const s = [];
    return e.forEach((e2) => {
      const i = ai(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = Vr(t2).Z({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, u] = t3, c = ui(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(u) : i2.done();
      });
      s.push(o);
    }), Et.waitFor(s).next(() => this.En(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = ai(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new Ut(X2);
    return Vr(t2).Z({
      range: r
    }, (t3, e2, i2) => {
      const [r2, u, c] = t3, a = ui(u);
      r2 === this.userId && n.isPrefixOf(a) ? a.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.En(t2, o));
  }
  En(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(vr(t2).get(e2).next((t3) => {
        if (null === t3)
          throw k2();
        M2(t3.userId === this.userId), n.push(Ki(this.It, t3));
      }));
    }), Et.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return Ar(t2.ie, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.An(e.batchId);
    }), Et.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  An(t2) {
    delete this.In[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return Et.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return Vr(t2).Z({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = ui(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        M2(0 === s.length);
      });
    });
  }
  containsKey(t2, e) {
    return Pr(t2, this.userId, e);
  }
  Rn(t2) {
    return Sr(t2).get(this.userId).next((t3) => t3 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function Pr(t2, e, n) {
  const s = ai(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return Vr(t2).Z({
    range: r,
    X: true
  }, (t3, n2, s2) => {
    const [r2, u, c] = t3;
    r2 === e && u === i && (o = true), s2.done();
  }).next(() => o);
}
function vr(t2) {
  return xi(t2, "mutations");
}
function Vr(t2) {
  return xi(t2, "documentMutations");
}
function Sr(t2) {
  return xi(t2, "mutationQueues");
}
var Dr = class {
  constructor(t2) {
    this.bn = t2;
  }
  next() {
    return this.bn += 2, this.bn;
  }
  static Pn() {
    return new Dr(0);
  }
  static vn() {
    return new Dr(-1);
  }
};
var Cr = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.It = e;
  }
  allocateTargetId(t2) {
    return this.Vn(t2).next((e) => {
      const n = new Dr(e.highestTargetId);
      return e.highestTargetId = n.next(), this.Sn(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.Vn(t2).next((t3) => nt.fromTimestamp(new et(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.Vn(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.Vn(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Sn(t2, s)));
  }
  addTargetData(t2, e) {
    return this.Dn(t2, e).next(() => this.Vn(t2).next((n) => (n.targetCount += 1, this.Cn(e, n), this.Sn(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.Dn(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => xr(t2).delete(e.targetId)).next(() => this.Vn(t2)).next((e2) => (M2(e2.targetCount > 0), e2.targetCount -= 1, this.Sn(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return xr(t2).Z((r, o) => {
      const u = Gi(o);
      u.sequenceNumber <= e && null === n.get(u.targetId) && (s++, i.push(this.removeTargetData(t2, u)));
    }).next(() => Et.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return xr(t2).Z((t3, n) => {
      const s = Gi(n);
      e(s);
    });
  }
  Vn(t2) {
    return Nr(t2).get("targetGlobalKey").next((t3) => (M2(null !== t3), t3));
  }
  Sn(t2, e) {
    return Nr(t2).put("targetGlobalKey", e);
  }
  Dn(t2, e) {
    return xr(t2).put(Qi(this.It, e));
  }
  Cn(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.Vn(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Ce(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return xr(t2).Z({
      range: s,
      index: "queryTargetsIndex"
    }, (t3, n2, s2) => {
      const r = Gi(n2);
      Ne(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = kr(t2);
    return e.forEach((e2) => {
      const r = ii(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), Et.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = kr(t2);
    return Et.forEach(e, (e2) => {
      const i = ii(e2.path);
      return Et.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = kr(t2), s = IDBKeyRange.bound(
      [e],
      [e + 1],
      false,
      true
    );
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound(
      [e],
      [e + 1],
      false,
      true
    ), s = kr(t2);
    let i = ls();
    return s.Z({
      range: n,
      X: true
    }, (t3, e2, n2) => {
      const s2 = ui(t3[1]), r = new ut(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = ii(e.path), s = IDBKeyRange.bound(
      [n],
      [tt(n)],
      false,
      true
    );
    let i = 0;
    return kr(t2).Z({
      index: "documentTargetsIndex",
      X: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      0 !== t3 && (i++, s2.done());
    }).next(() => i > 0);
  }
  se(t2, e) {
    return xr(t2).get(e).next((t3) => t3 ? Gi(t3) : null);
  }
};
function xr(t2) {
  return xi(t2, "targets");
}
function Nr(t2) {
  return xi(t2, "targetGlobal");
}
function kr(t2) {
  return xi(t2, "targetDocuments");
}
function Mr([t2, e], [n, s]) {
  const i = X2(t2, n);
  return 0 === i ? X2(e, s) : i;
}
var Or = class {
  constructor(t2) {
    this.xn = t2, this.buffer = new Ut(Mr), this.Nn = 0;
  }
  kn() {
    return ++this.Nn;
  }
  Mn(t2) {
    const e = [t2, this.kn()];
    if (this.buffer.size < this.xn)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Mr(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Fr = class {
  constructor(t2, e, n) {
    this.garbageCollector = t2, this.asyncQueue = e, this.localStore = n, this.On = null;
  }
  start() {
    -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Fn(6e4);
  }
  stop() {
    this.On && (this.On.cancel(), this.On = null);
  }
  get started() {
    return null !== this.On;
  }
  Fn(t2) {
    D2("LruGarbageCollector", `Garbage collection scheduled in ${t2}ms`), this.On = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t2, async () => {
      this.On = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (t3) {
        vt(t3) ? D2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Tt(t3);
      }
      await this.Fn(3e5);
    });
  }
};
var $r = class {
  constructor(t2, e) {
    this.$n = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.$n.Bn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (0 === e)
      return Et.resolve(kt.at);
    const n = new Or(e);
    return this.$n.forEachTarget(t2, (t3) => n.Mn(t3.sequenceNumber)).next(() => this.$n.Ln(t2, (t3) => n.Mn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.$n.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.$n.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return -1 === this.params.cacheSizeCollectionThreshold ? (D2("LruGarbageCollector", "Garbage collection skipped; disabled"), Et.resolve(Tr)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (D2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), Tr) : this.Un(t2, e));
  }
  getCacheSize(t2) {
    return this.$n.getCacheSize(t2);
  }
  Un(t2, e) {
    let n, s, i, r, o, c, a;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (D2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (a = Date.now(), V2() <= LogLevel.DEBUG) {
        D2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (a - c) + `ms
Total Duration: ${a - h}ms`);
      }
      return Et.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Br = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new $r(t3, e2);
    }(this, e);
  }
  Bn(t2) {
    const e = this.qn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  qn(t2) {
    let e = 0;
    return this.Ln(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  Ln(t2, e) {
    return this.Kn(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Lr(t2, n);
  }
  removeReference(t2, e, n) {
    return Lr(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Lr(t2, e);
  }
  Gn(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Sr(t3).tt((s) => Pr(t3, s, e2).next((t4) => (t4 && (n = true), Et.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Kn(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Gn(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, nt.min()), kr(t2).delete([0, ii(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => Et.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Lr(t2, e);
  }
  Kn(t2, e) {
    const n = kr(t2);
    let s, i = kt.at;
    return n.Z({
      index: "documentTargetsIndex"
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      0 === t3 ? (i !== kt.at && e(new ut(ui(s)), i), i = o, s = r) : i = kt.at;
    }).next(() => {
      i !== kt.at && e(new ut(ui(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Lr(t2, e) {
  return kr(t2).put(
    function(t3, e2) {
      return {
        targetId: 0,
        path: ii(t3.path),
        sequenceNumber: e2
      };
    }(e, t2.currentSequenceNumber)
  );
}
var Ur = class {
  constructor() {
    this.changes = new ts((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, Ve.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return void 0 !== n ? Et.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var qr = class {
  constructor(t2) {
    this.It = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return jr(t2).put(n);
  }
  removeEntry(t2, e, n) {
    return jr(t2).delete(
      function(t3, e2) {
        const n2 = t3.path.toArray();
        return [
          n2.slice(0, n2.length - 2),
          n2[n2.length - 2],
          Li(e2),
          n2[n2.length - 1]
        ];
      }(e, n)
    );
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Qn(t2, n)));
  }
  getEntry(t2, e) {
    let n = Ve.newInvalidDocument(e);
    return jr(t2).Z({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Wr(e))
    }, (t3, s) => {
      n = this.jn(e, s);
    }).next(() => n);
  }
  Wn(t2, e) {
    let n = {
      size: 0,
      document: Ve.newInvalidDocument(e)
    };
    return jr(t2).Z({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Wr(e))
    }, (t3, s) => {
      n = {
        document: this.jn(e, s),
        size: Rr(s)
      };
    }).next(() => n);
  }
  getEntries(t2, e) {
    let n = ns();
    return this.zn(t2, e, (t3, e2) => {
      const s = this.jn(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Hn(t2, e) {
    let n = ns(), s = new $t(ut.comparator);
    return this.zn(t2, e, (t3, e2) => {
      const i = this.jn(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Rr(e2));
    }).next(() => ({
      documents: n,
      Jn: s
    }));
  }
  zn(t2, e, n) {
    if (e.isEmpty())
      return Et.resolve();
    let s = new Ut(Hr);
    e.forEach((t3) => s = s.add(t3));
    const i = IDBKeyRange.bound(Wr(s.first()), Wr(s.last())), r = s.getIterator();
    let o = r.getNext();
    return jr(t2).Z({
      index: "documentKeyIndex",
      range: i
    }, (t3, e2, s2) => {
      const i2 = ut.fromSegments([...e2.prefixPath, e2.collectionGroup, e2.documentId]);
      for (; o && Hr(o, i2) < 0; )
        n(o, null), o = r.getNext();
      o && o.isEqual(i2) && (n(o, e2), o = r.hasNext() ? r.getNext() : null), o ? s2.j(Wr(o)) : s2.done();
    }).next(() => {
      for (; o; )
        n(o, null), o = r.hasNext() ? r.getNext() : null;
    });
  }
  getAllFromCollection(t2, e, n) {
    const s = [e.popLast().toArray(), e.lastSegment(), Li(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], i = [e.popLast().toArray(), e.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
    return jr(t2).W(IDBKeyRange.bound(s, i, true)).next((t3) => {
      let e2 = ns();
      for (const n2 of t3) {
        const t4 = this.jn(ut.fromSegments(n2.prefixPath.concat(n2.collectionGroup, n2.documentId)), n2);
        e2 = e2.insert(t4.key, t4);
      }
      return e2;
    });
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    let i = ns();
    const r = zr(e, n), o = zr(e, gt.max());
    return jr(t2).Z({
      index: "collectionGroupIndex",
      range: IDBKeyRange.bound(r, o, true)
    }, (t3, e2, n2) => {
      const r2 = this.jn(ut.fromSegments(e2.prefixPath.concat(e2.collectionGroup, e2.documentId)), e2);
      i = i.insert(r2.key, r2), i.size === s && n2.done();
    }).next(() => i);
  }
  newChangeBuffer(t2) {
    return new Gr(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Qr(t2).get("remoteDocumentGlobalKey").next((t3) => (M2(!!t3), t3));
  }
  Qn(t2, e) {
    return Qr(t2).put("remoteDocumentGlobalKey", e);
  }
  jn(t2, e) {
    if (e) {
      const t3 = $i(this.It, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(nt.min())))
        return t3;
    }
    return Ve.newInvalidDocument(t2);
  }
};
function Kr(t2) {
  return new qr(t2);
}
var Gr = class extends Ur {
  constructor(t2, e) {
    super(), this.Yn = t2, this.trackRemovals = e, this.Xn = new ts((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new Ut((t3, e2) => X2(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Xn.get(i);
      if (e.push(this.Yn.removeEntry(t2, i, o.readTime)), r.isValidDocument()) {
        const u = Bi(this.Yn.It, r);
        s = s.add(i.path.popLast());
        const c = Rr(u);
        n += c - o.size, e.push(this.Yn.addEntry(t2, i, u));
      } else if (n -= o.size, this.trackRemovals) {
        const n2 = Bi(this.Yn.It, r.convertToNoDocument(nt.min()));
        e.push(this.Yn.addEntry(t2, i, n2));
      }
    }), s.forEach((n2) => {
      e.push(this.Yn.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Yn.updateMetadata(t2, n)), Et.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Yn.Wn(t2, e).next((t3) => (this.Xn.set(e, {
      size: t3.size,
      readTime: t3.document.readTime
    }), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Yn.Hn(t2, e).next(({ documents: t3, Jn: e2 }) => (e2.forEach((e3, n) => {
      this.Xn.set(e3, {
        size: n,
        readTime: t3.get(e3).readTime
      });
    }), t3));
  }
};
function Qr(t2) {
  return xi(t2, "remoteDocumentGlobal");
}
function jr(t2) {
  return xi(t2, "remoteDocumentsV14");
}
function Wr(t2) {
  const e = t2.path.toArray();
  return [
    e.slice(0, e.length - 2),
    e[e.length - 2],
    e[e.length - 1]
  ];
}
function zr(t2, e) {
  const n = e.documentKey.path.toArray();
  return [
    t2,
    Li(e.readTime),
    n.slice(0, n.length - 2),
    n.length > 0 ? n[n.length - 1] : ""
  ];
}
function Hr(t2, e) {
  const n = t2.path.toArray(), s = e.path.toArray();
  let i = 0;
  for (let t3 = 0; t3 < n.length - 2 && t3 < s.length - 2; ++t3)
    if (i = X2(n[t3], s[t3]), i)
      return i;
  return i = X2(n.length, s.length), i || (i = X2(n[n.length - 2], s[s.length - 2]), i || X2(n[n.length - 1], s[s.length - 1]));
}
var Jr = class {
  constructor(t2, e) {
    this.overlayedDocument = t2, this.mutatedFields = e;
  }
};
var Yr = class {
  constructor(t2, e, n, s) {
    this.remoteDocumentCache = t2, this.mutationQueue = e, this.documentOverlayCache = n, this.indexManager = s;
  }
  getDocument(t2, e) {
    let n = null;
    return this.documentOverlayCache.getOverlay(t2, e).next((s) => (n = s, this.getBaseDocument(t2, e, n))).next((t3) => (null !== n && Bn(n.mutation, t3, Gt.empty(), et.now()), t3));
  }
  getDocuments(t2, e) {
    return this.remoteDocumentCache.getEntries(t2, e).next((e2) => this.getLocalViewOfDocuments(t2, e2, ls()).next(() => e2));
  }
  getLocalViewOfDocuments(t2, e, n = ls()) {
    const s = os();
    return this.populateOverlays(t2, s, e).next(() => this.computeViews(t2, e, s, n).next((t3) => {
      let e2 = is();
      return t3.forEach((t4, n2) => {
        e2 = e2.insert(t4, n2.overlayedDocument);
      }), e2;
    }));
  }
  getOverlayedDocuments(t2, e) {
    const n = os();
    return this.populateOverlays(t2, n, e).next(() => this.computeViews(t2, e, n, ls()));
  }
  populateOverlays(t2, e, n) {
    const s = [];
    return n.forEach((t3) => {
      e.has(t3) || s.push(t3);
    }), this.documentOverlayCache.getOverlays(t2, s).next((t3) => {
      t3.forEach((t4, n2) => {
        e.set(t4, n2);
      });
    });
  }
  computeViews(t2, e, n, s) {
    let i = ns();
    const r = cs(), o = cs();
    return e.forEach((t3, e2) => {
      const o2 = n.get(e2.key);
      s.has(e2.key) && (void 0 === o2 || o2.mutation instanceof Kn) ? i = i.insert(e2.key, e2) : void 0 !== o2 && (r.set(e2.key, o2.mutation.getFieldMask()), Bn(o2.mutation, e2, o2.mutation.getFieldMask(), et.now()));
    }), this.recalculateAndSaveOverlays(t2, i).next((t3) => (t3.forEach((t4, e2) => r.set(t4, e2)), e.forEach((t4, e2) => {
      var n2;
      return o.set(t4, new Jr(e2, null !== (n2 = r.get(t4)) && void 0 !== n2 ? n2 : null));
    }), o));
  }
  recalculateAndSaveOverlays(t2, e) {
    const n = cs();
    let s = new $t((t3, e2) => t3 - e2), i = ls();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => {
      for (const i2 of t3)
        i2.keys().forEach((t4) => {
          const r = e.get(t4);
          if (null === r)
            return;
          let o = n.get(t4) || Gt.empty();
          o = i2.applyToLocalView(r, o), n.set(t4, o);
          const u = (s.get(i2.batchId) || ls()).add(t4);
          s = s.insert(i2.batchId, u);
        });
    }).next(() => {
      const r = [], o = s.getReverseIterator();
      for (; o.hasNext(); ) {
        const s2 = o.getNext(), u = s2.key, c = s2.value, a = us();
        c.forEach((t3) => {
          if (!i.has(t3)) {
            const s3 = Fn(e.get(t3), n.get(t3));
            null !== s3 && a.set(t3, s3), i = i.add(t3);
          }
        }), r.push(this.documentOverlayCache.saveOverlays(t2, u, a));
      }
      return Et.waitFor(r);
    }).next(() => n);
  }
  recalculateAndSaveOverlaysForDocumentKeys(t2, e) {
    return this.remoteDocumentCache.getEntries(t2, e).next((e2) => this.recalculateAndSaveOverlays(t2, e2));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return ut.isDocumentKey(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
    }(e) ? this.getDocumentsMatchingDocumentQuery(t2, e.path) : rn(e) ? this.getDocumentsMatchingCollectionGroupQuery(t2, e, n) : this.getDocumentsMatchingCollectionQuery(t2, e, n);
  }
  getNextDocuments(t2, e, n, s) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t2, e, n, s).next((i) => {
      const r = s - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t2, e, n.largestBatchId, s - i.size) : Et.resolve(os());
      let o = -1, u = i;
      return r.next((e2) => Et.forEach(e2, (e3, n2) => (o < n2.largestBatchId && (o = n2.largestBatchId), i.get(e3) ? Et.resolve() : this.getBaseDocument(t2, e3, n2).next((t3) => {
        u = u.insert(e3, t3);
      }))).next(() => this.populateOverlays(t2, e2, i)).next(() => this.computeViews(t2, u, e2, ls())).next((t3) => ({
        batchId: o,
        changes: rs(t3)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t2, e) {
    return this.getDocument(t2, new ut(e)).next((t3) => {
      let e2 = is();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t2, e, n) {
    const s = e.collectionGroup;
    let i = is();
    return this.indexManager.getCollectionParents(t2, s).next((r) => Et.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new Xe(
          e2,
          null,
          t3.explicitOrderBy.slice(),
          t3.filters.slice(),
          t3.limit,
          t3.limitType,
          t3.startAt,
          t3.endAt
        );
      }(e, r2.child(s));
      return this.getDocumentsMatchingCollectionQuery(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  getDocumentsMatchingCollectionQuery(t2, e, n) {
    let s;
    return this.remoteDocumentCache.getAllFromCollection(t2, e.path, n).next((i) => (s = i, this.documentOverlayCache.getOverlaysForCollection(t2, e.path, n.largestBatchId))).next((t3) => {
      t3.forEach((t4, e2) => {
        const n3 = e2.getKey();
        null === s.get(n3) && (s = s.insert(n3, Ve.newInvalidDocument(n3)));
      });
      let n2 = is();
      return s.forEach((s2, i) => {
        const r = t3.get(s2);
        void 0 !== r && Bn(r.mutation, i, Gt.empty(), et.now()), fn(e, i) && (n2 = n2.insert(s2, i));
      }), n2;
    });
  }
  getBaseDocument(t2, e, n) {
    return null === n || 1 === n.mutation.type ? this.remoteDocumentCache.getEntry(t2, e) : Et.resolve(Ve.newInvalidDocument(e));
  }
};
var Xr = class {
  constructor(t2) {
    this.It = t2, this.Zn = /* @__PURE__ */ new Map(), this.ts = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return Et.resolve(this.Zn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Zn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Ss(n.createTime)
    }), Et.resolve();
  }
  getNamedQuery(t2, e) {
    return Et.resolve(this.ts.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.ts.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: ji(t3.bundledQuery),
        readTime: Ss(t3.readTime)
      };
    }(e)), Et.resolve();
  }
};
var Zr = class {
  constructor() {
    this.overlays = new $t(ut.comparator), this.es = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return Et.resolve(this.overlays.get(e));
  }
  getOverlays(t2, e) {
    const n = os();
    return Et.forEach(e, (e2) => this.getOverlay(t2, e2).next((t3) => {
      null !== t3 && n.set(e2, t3);
    })).next(() => n);
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2, s) => {
      this.ue(t2, e, s);
    }), Et.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.es.get(n);
    return void 0 !== s && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.es.delete(n)), Et.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = os(), i = e.length + 1, r = new ut(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return Et.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new $t((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        null === e2 && (e2 = os(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = os(), u = i.getIterator();
    for (; u.hasNext(); ) {
      if (u.getNext().value.forEach((t3, e2) => o.set(t3, e2)), o.size() >= s)
        break;
    }
    return Et.resolve(o);
  }
  ue(t2, e, n) {
    const s = this.overlays.get(n.key);
    if (null !== s) {
      const t3 = this.es.get(s.largestBatchId).delete(n.key);
      this.es.set(s.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n.key, new Mi(e, n));
    let i = this.es.get(e);
    void 0 === i && (i = ls(), this.es.set(e, i)), this.es.set(e, i.add(n.key));
  }
};
var to = class {
  constructor() {
    this.ns = new Ut(eo.ss), this.rs = new Ut(eo.os);
  }
  isEmpty() {
    return this.ns.isEmpty();
  }
  addReference(t2, e) {
    const n = new eo(t2, e);
    this.ns = this.ns.add(n), this.rs = this.rs.add(n);
  }
  us(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.cs(new eo(t2, e));
  }
  hs(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  ls(t2) {
    const e = new ut(new it([])), n = new eo(e, t2), s = new eo(e, t2 + 1), i = [];
    return this.rs.forEachInRange([n, s], (t3) => {
      this.cs(t3), i.push(t3.key);
    }), i;
  }
  fs() {
    this.ns.forEach((t2) => this.cs(t2));
  }
  cs(t2) {
    this.ns = this.ns.delete(t2), this.rs = this.rs.delete(t2);
  }
  ds(t2) {
    const e = new ut(new it([])), n = new eo(e, t2), s = new eo(e, t2 + 1);
    let i = ls();
    return this.rs.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new eo(t2, 0), n = this.ns.firstAfterOrEqual(e);
    return null !== n && t2.isEqual(n.key);
  }
};
var eo = class {
  constructor(t2, e) {
    this.key = t2, this._s = e;
  }
  static ss(t2, e) {
    return ut.comparator(t2.key, e.key) || X2(t2._s, e._s);
  }
  static os(t2, e) {
    return X2(t2._s, e._s) || ut.comparator(t2.key, e.key);
  }
};
var no = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.mutationQueue = [], this.ws = 1, this.gs = new Ut(eo.ss);
  }
  checkEmpty(t2) {
    return Et.resolve(0 === this.mutationQueue.length);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.ws;
    this.ws++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const r = new Ni(i, e, n, s);
    this.mutationQueue.push(r);
    for (const e2 of s)
      this.gs = this.gs.add(new eo(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return Et.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return Et.resolve(this.ys(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.ps(n), i = s < 0 ? 0 : s;
    return Et.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return Et.resolve(0 === this.mutationQueue.length ? -1 : this.ws - 1);
  }
  getAllMutationBatches(t2) {
    return Et.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new eo(e, 0), s = new eo(e, Number.POSITIVE_INFINITY), i = [];
    return this.gs.forEachInRange([n, s], (t3) => {
      const e2 = this.ys(t3._s);
      i.push(e2);
    }), Et.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Ut(X2);
    return e.forEach((t3) => {
      const e2 = new eo(t3, 0), s = new eo(t3, Number.POSITIVE_INFINITY);
      this.gs.forEachInRange([e2, s], (t4) => {
        n = n.add(t4._s);
      });
    }), Et.resolve(this.Is(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    ut.isDocumentKey(i) || (i = i.child(""));
    const r = new eo(new ut(i), 0);
    let o = new Ut(X2);
    return this.gs.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3._s)), true);
    }, r), Et.resolve(this.Is(o));
  }
  Is(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.ys(t3);
      null !== n && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    M2(0 === this.Ts(e.batchId, "removed")), this.mutationQueue.shift();
    let n = this.gs;
    return Et.forEach(e.mutations, (s) => {
      const i = new eo(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.gs = n;
    });
  }
  An(t2) {
  }
  containsKey(t2, e) {
    const n = new eo(e, 0), s = this.gs.firstAfterOrEqual(n);
    return Et.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.mutationQueue.length, Et.resolve();
  }
  Ts(t2, e) {
    return this.ps(t2);
  }
  ps(t2) {
    if (0 === this.mutationQueue.length)
      return 0;
    return t2 - this.mutationQueue[0].batchId;
  }
  ys(t2) {
    const e = this.ps(t2);
    if (e < 0 || e >= this.mutationQueue.length)
      return null;
    return this.mutationQueue[e];
  }
};
var so = class {
  constructor(t2) {
    this.Es = t2, this.docs = new $t(ut.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.Es(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return Et.resolve(n ? n.document.mutableCopy() : Ve.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = ns();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : Ve.newInvalidDocument(t3));
    }), Et.resolve(n);
  }
  getAllFromCollection(t2, e, n) {
    let s = ns();
    const i = new ut(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t3.path))
        break;
      t3.path.length > e.length + 1 || (yt(mt(i2), n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return Et.resolve(s);
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    k2();
  }
  As(t2, e) {
    return Et.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new io(this);
  }
  getSize(t2) {
    return Et.resolve(this.size);
  }
};
var io = class extends Ur {
  constructor(t2) {
    super(), this.Yn = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.Yn.addEntry(t2, s)) : this.Yn.removeEntry(n);
    }), Et.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Yn.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Yn.getEntries(t2, e);
  }
};
var ro = class {
  constructor(t2) {
    this.persistence = t2, this.Rs = new ts((t3) => Ce(t3), Ne), this.lastRemoteSnapshotVersion = nt.min(), this.highestTargetId = 0, this.bs = 0, this.Ps = new to(), this.targetCount = 0, this.vs = Dr.Pn();
  }
  forEachTarget(t2, e) {
    return this.Rs.forEach((t3, n) => e(n)), Et.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return Et.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return Et.resolve(this.bs);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.vs.next(), Et.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.bs && (this.bs = e), Et.resolve();
  }
  Dn(t2) {
    this.Rs.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.vs = new Dr(e), this.highestTargetId = e), t2.sequenceNumber > this.bs && (this.bs = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.Dn(e), this.targetCount += 1, Et.resolve();
  }
  updateTargetData(t2, e) {
    return this.Dn(e), Et.resolve();
  }
  removeTargetData(t2, e) {
    return this.Rs.delete(e.target), this.Ps.ls(e.targetId), this.targetCount -= 1, Et.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Rs.forEach((r, o) => {
      o.sequenceNumber <= e && null === n.get(o.targetId) && (this.Rs.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), Et.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return Et.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Rs.get(e) || null;
    return Et.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.Ps.us(e, n), Et.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.Ps.hs(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), Et.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.Ps.ls(e), Et.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.Ps.ds(e);
    return Et.resolve(n);
  }
  containsKey(t2, e) {
    return Et.resolve(this.Ps.containsKey(e));
  }
};
var oo = class {
  constructor(t2, e) {
    this.Vs = {}, this.overlays = {}, this.Ss = new kt(0), this.Ds = false, this.Ds = true, this.referenceDelegate = t2(this), this.Cs = new ro(this);
    this.indexManager = new fr(), this.remoteDocumentCache = function(t3) {
      return new so(t3);
    }((t3) => this.referenceDelegate.xs(t3)), this.It = new Fi(e), this.Ns = new Xr(this.It);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Ds = false, Promise.resolve();
  }
  get started() {
    return this.Ds;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new Zr(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.Vs[t2.toKey()];
    return n || (n = new no(e, this.referenceDelegate), this.Vs[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.Cs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.Ns;
  }
  runTransaction(t2, e, n) {
    D2("MemoryPersistence", "Starting transaction:", t2);
    const s = new uo(this.Ss.next());
    return this.referenceDelegate.ks(), n(s).next((t3) => this.referenceDelegate.Ms(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Os(t2, e) {
    return Et.or(Object.values(this.Vs).map((n) => () => n.containsKey(t2, e)));
  }
};
var uo = class extends It {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var co = class {
  constructor(t2) {
    this.persistence = t2, this.Fs = new to(), this.$s = null;
  }
  static Bs(t2) {
    return new co(t2);
  }
  get Ls() {
    if (this.$s)
      return this.$s;
    throw k2();
  }
  addReference(t2, e, n) {
    return this.Fs.addReference(n, e), this.Ls.delete(n.toString()), Et.resolve();
  }
  removeReference(t2, e, n) {
    return this.Fs.removeReference(n, e), this.Ls.add(n.toString()), Et.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.Ls.add(e.toString()), Et.resolve();
  }
  removeTarget(t2, e) {
    this.Fs.ls(e.targetId).forEach((t3) => this.Ls.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.Ls.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  ks() {
    this.$s = /* @__PURE__ */ new Set();
  }
  Ms(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return Et.forEach(this.Ls, (n) => {
      const s = ut.fromPath(n);
      return this.Us(t2, s).next((t3) => {
        t3 || e.removeEntry(s, nt.min());
      });
    }).next(() => (this.$s = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.Us(t2, e).next((t3) => {
      t3 ? this.Ls.delete(e.toString()) : this.Ls.add(e.toString());
    });
  }
  xs(t2) {
    return 0;
  }
  Us(t2, e) {
    return Et.or([() => Et.resolve(this.Fs.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Os(t2, e)]);
  }
};
var ao = class {
  constructor(t2) {
    this.It = t2;
  }
  $(t2, e, n, s) {
    const i = new At("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore("owner");
    }(t2), function(t3) {
      t3.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t3.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", ci, {
        unique: true
      }), t3.createObjectStore("documentMutations");
    }(t2), ho(t2), function(t3) {
      t3.createObjectStore("remoteDocuments");
    }(t2));
    let r = Et.resolve();
    return n < 3 && s >= 3 && (0 !== n && (!function(t3) {
      t3.deleteObjectStore("targetDocuments"), t3.deleteObjectStore("targets"), t3.deleteObjectStore("targetGlobal");
    }(t2), ho(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: nt.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (0 !== n && (r = r.next(() => function(t3, e2) {
      return e2.store("mutations").W().next((n2) => {
        t3.deleteObjectStore("mutations");
        t3.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", ci, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t4) => s2.put(t4));
        return Et.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.qs(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore("remoteDocumentGlobal");
    }(t2), this.Ks(i)))), n < 7 && s >= 7 && (r = r.next(() => this.Gs(i))), n < 8 && s >= 8 && (r = r.next(() => this.Qs(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2);
    })), n < 10 && s >= 10 && (r = r.next(() => this.js(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t2), function(t3) {
        t3.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore("documentOverlays", {
          keyPath: Ai
        });
        e2.createIndex("collectionPathOverlayIndex", Ri, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", bi, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => function(t3) {
      const e2 = t3.createObjectStore("remoteDocumentsV14", {
        keyPath: fi
      });
      e2.createIndex("documentKeyIndex", di), e2.createIndex("collectionGroupIndex", _i);
    }(t2)).next(() => this.Ws(t2, i)).next(() => t2.deleteObjectStore("remoteDocuments"))), n < 14 && s >= 14 && (r = r.next(() => this.zs(t2, i))), n < 15 && s >= 15 && (r = r.next(() => function(t3) {
      t3.createObjectStore("indexConfiguration", {
        keyPath: "indexId",
        autoIncrement: true
      }).createIndex("collectionGroupIndex", "collectionGroup", {
        unique: false
      });
      t3.createObjectStore("indexState", {
        keyPath: pi
      }).createIndex("sequenceNumberIndex", Ii, {
        unique: false
      });
      t3.createObjectStore("indexEntries", {
        keyPath: Ti
      }).createIndex("documentKeyIndex", Ei, {
        unique: false
      });
    }(t2))), r;
  }
  Ks(t2) {
    let e = 0;
    return t2.store("remoteDocuments").Z((t3, n) => {
      e += Rr(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t2.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  qs(t2) {
    const e = t2.store("mutationQueues"), n = t2.store("mutations");
    return e.W().next((e2) => Et.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.W("userMutationsIndex", s).next((n2) => Et.forEach(n2, (n3) => {
        M2(n3.userId === e3.userId);
        const s2 = Ki(this.It, n3);
        return Ar(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  Gs(t2) {
    const e = t2.store("targetDocuments"), n = t2.store("remoteDocuments");
    return t2.store("targetGlobal").get("targetGlobalKey").next((t3) => {
      const s = [];
      return n.Z((n2, i) => {
        const r = new it(n2), o = function(t4) {
          return [0, ii(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? Et.resolve() : ((n4) => e.put({
          targetId: 0,
          path: ii(n4),
          sequenceNumber: t3.highestListenSequenceNumber
        }))(r)));
      }).next(() => Et.waitFor(s));
    });
  }
  Qs(t2, e) {
    t2.createObjectStore("collectionParents", {
      keyPath: yi
    });
    const n = e.store("collectionParents"), s = new dr(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: ii(s2)
        });
      }
    };
    return e.store("remoteDocuments").Z({
      X: true
    }, (t3, e2) => {
      const n2 = new it(t3);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").Z({
      X: true
    }, ([t3, e2, n2], s2) => {
      const r = ui(e2);
      return i(r.popLast());
    }));
  }
  js(t2) {
    const e = t2.store("targets");
    return e.Z((t3, n) => {
      const s = Gi(n), i = Qi(this.It, s);
      return e.put(i);
    });
  }
  Ws(t2, e) {
    const n = e.store("remoteDocuments"), s = [];
    return n.Z((t3, n2) => {
      const i = e.store("remoteDocumentsV14"), r = (o = n2, o.document ? new ut(it.fromString(o.document.name).popFirst(5)) : o.noDocument ? ut.fromSegments(o.noDocument.path) : o.unknownDocument ? ut.fromSegments(o.unknownDocument.path) : k2()).path.toArray();
      var o;
      const u = {
        prefixPath: r.slice(0, r.length - 2),
        collectionGroup: r[r.length - 2],
        documentId: r[r.length - 1],
        readTime: n2.readTime || [0, 0],
        unknownDocument: n2.unknownDocument,
        noDocument: n2.noDocument,
        document: n2.document,
        hasCommittedMutations: !!n2.hasCommittedMutations
      };
      s.push(i.put(u));
    }).next(() => Et.waitFor(s));
  }
  zs(t2, e) {
    const n = e.store("mutations"), s = Kr(this.It), i = new oo(co.Bs, this.It.re);
    return n.W().next((t3) => {
      const n2 = /* @__PURE__ */ new Map();
      return t3.forEach((t4) => {
        var e2;
        let s2 = null !== (e2 = n2.get(t4.userId)) && void 0 !== e2 ? e2 : ls();
        Ki(this.It, t4).keys().forEach((t5) => s2 = s2.add(t5)), n2.set(t4.userId, s2);
      }), Et.forEach(n2, (t4, n3) => {
        const r = new b(n3), o = Zi.oe(this.It, r), u = i.getIndexManager(r), c = br.oe(r, this.It, u, i.referenceDelegate);
        return new Yr(s, c, o, u).recalculateAndSaveOverlaysForDocumentKeys(new Ci(e, kt.at), t4).next();
      });
    });
  }
};
function ho(t2) {
  t2.createObjectStore("targetDocuments", {
    keyPath: mi
  }).createIndex("documentTargetsIndex", gi, {
    unique: true
  });
  t2.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", wi, {
    unique: true
  }), t2.createObjectStore("targetGlobal");
}
var lo = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var fo = class {
  constructor(t2, e, n, s, i, r, o, u, c, a, h = 15) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Hs = i, this.window = r, this.document = o, this.Js = c, this.Ys = a, this.Xs = h, this.Ss = null, this.Ds = false, this.isPrimary = false, this.networkEnabled = true, this.Zs = null, this.inForeground = false, this.ti = null, this.ei = null, this.ni = Number.NEGATIVE_INFINITY, this.si = (t3) => Promise.resolve(), !fo.C())
      throw new B2($.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Br(this, s), this.ii = e + "main", this.It = new Fi(u), this.ri = new Rt(this.ii, this.Xs, new ao(this.It)), this.Cs = new Cr(this.referenceDelegate, this.It), this.remoteDocumentCache = Kr(this.It), this.Ns = new Ji(), this.window && this.window.localStorage ? this.oi = this.window.localStorage : (this.oi = null, false === a && C2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.ui().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new B2($.FAILED_PRECONDITION, lo);
      return this.ci(), this.ai(), this.hi(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.Cs.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Ss = new kt(t2, this.Js);
    }).then(() => {
      this.Ds = true;
    }).catch((t2) => (this.ri && this.ri.close(), Promise.reject(t2)));
  }
  li(t2) {
    return this.si = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.ri.L(async (e) => {
      null === e.newVersion && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Hs.enqueueAndForget(async () => {
      this.started && await this.ui();
    }));
  }
  ui() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => wo(t2).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.fi(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Hs.enqueueRetryable(() => this.si(false)));
        });
    }).next(() => this.di(t2)).next((e) => this.isPrimary && !e ? this._i(t2).next(() => false) : !!e && this.wi(t2).next(() => true))).catch((t2) => {
      if (vt(t2))
        return D2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return D2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Hs.enqueueRetryable(() => this.si(t2)), this.isPrimary = t2;
    });
  }
  fi(t2) {
    return _o(t2).get("owner").next((t3) => Et.resolve(this.mi(t3)));
  }
  gi(t2) {
    return wo(t2).delete(this.clientId);
  }
  async yi() {
    if (this.isPrimary && !this.pi(this.ni, 18e5)) {
      this.ni = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = xi(t3, "clientMetadata");
        return e.W().next((t4) => {
          const n = this.Ii(t4, 18e5), s = t4.filter((t5) => -1 === n.indexOf(t5));
          return Et.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.oi)
        for (const e of t2)
          this.oi.removeItem(this.Ti(e.clientId));
    }
  }
  hi() {
    this.ei = this.Hs.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.ui().then(() => this.yi()).then(() => this.hi()));
  }
  mi(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  di(t2) {
    if (this.Ys)
      return Et.resolve(true);
    return _o(t2).get("owner").next((e) => {
      if (null !== e && this.pi(e.leaseTimestampMs, 5e3) && !this.Ei(e.ownerId)) {
        if (this.mi(e) && this.networkEnabled)
          return true;
        if (!this.mi(e)) {
          if (!e.allowTabSynchronization)
            throw new B2($.FAILED_PRECONDITION, lo);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || wo(t2).W().next((t3) => void 0 === this.Ii(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }));
    }).next((t3) => (this.isPrimary !== t3 && D2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Ds = false, this.Ai(), this.ei && (this.ei.cancel(), this.ei = null), this.Ri(), this.bi(), await this.ri.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t2) => {
      const e = new Ci(t2, kt.at);
      return this._i(e).next(() => this.gi(e));
    }), this.ri.close(), this.Pi();
  }
  Ii(t2, e) {
    return t2.filter((t3) => this.pi(t3.updateTimeMs, e) && !this.Ei(t3.clientId));
  }
  vi() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => wo(t2).W().next((t3) => this.Ii(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Ds;
  }
  getMutationQueue(t2, e) {
    return br.oe(t2, this.It, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.Cs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getIndexManager(t2) {
    return new wr(t2, this.It.re.databaseId);
  }
  getDocumentOverlayCache(t2) {
    return Zi.oe(this.It, t2);
  }
  getBundleCache() {
    return this.Ns;
  }
  runTransaction(t2, e, n) {
    D2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = "readonly" === e ? "readonly" : "readwrite", i = 15 === (r = this.Xs) ? Di : 14 === r ? Si : 13 === r ? Vi : 12 === r ? vi : 11 === r ? Pi : void k2();
    var r;
    let o;
    return this.ri.runTransaction(t2, s, i, (s2) => (o = new Ci(s2, this.Ss ? this.Ss.next() : kt.at), "readwrite-primary" === e ? this.fi(o).next((t3) => !!t3 || this.di(o)).next((e2) => {
      if (!e2)
        throw C2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Hs.enqueueRetryable(() => this.si(false)), new B2($.FAILED_PRECONDITION, pt);
      return n(o);
    }).next((t3) => this.wi(o).next(() => t3)) : this.Vi(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  Vi(t2) {
    return _o(t2).get("owner").next((t3) => {
      if (null !== t3 && this.pi(t3.leaseTimestampMs, 5e3) && !this.Ei(t3.ownerId) && !this.mi(t3) && !(this.Ys || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new B2($.FAILED_PRECONDITION, lo);
    });
  }
  wi(t2) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return _o(t2).put("owner", e);
  }
  static C() {
    return Rt.C();
  }
  _i(t2) {
    const e = _o(t2);
    return e.get("owner").next((t3) => this.mi(t3) ? (D2("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : Et.resolve());
  }
  pi(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (C2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  ci() {
    null !== this.document && "function" == typeof this.document.addEventListener && (this.ti = () => {
      this.Hs.enqueueAndForget(() => (this.inForeground = "visible" === this.document.visibilityState, this.ui()));
    }, this.document.addEventListener("visibilitychange", this.ti), this.inForeground = "visible" === this.document.visibilityState);
  }
  Ri() {
    this.ti && (this.document.removeEventListener("visibilitychange", this.ti), this.ti = null);
  }
  ai() {
    var t2;
    "function" == typeof (null === (t2 = this.window) || void 0 === t2 ? void 0 : t2.addEventListener) && (this.Zs = () => {
      this.Ai(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Hs.enterRestrictedMode(true), this.Hs.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Zs));
  }
  bi() {
    this.Zs && (this.window.removeEventListener("pagehide", this.Zs), this.Zs = null);
  }
  Ei(t2) {
    var e;
    try {
      const n = null !== (null === (e = this.oi) || void 0 === e ? void 0 : e.getItem(this.Ti(t2)));
      return D2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return C2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  Ai() {
    if (this.oi)
      try {
        this.oi.setItem(this.Ti(this.clientId), String(Date.now()));
      } catch (t2) {
        C2("Failed to set zombie client id.", t2);
      }
  }
  Pi() {
    if (this.oi)
      try {
        this.oi.removeItem(this.Ti(this.clientId));
      } catch (t2) {
      }
  }
  Ti(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function _o(t2) {
  return xi(t2, "owner");
}
function wo(t2) {
  return xi(t2, "clientMetadata");
}
function mo(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var go = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Si = n, this.Di = s;
  }
  static Ci(t2, e) {
    let n = ls(), s = ls();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new go(t2, e.fromCache, n, s);
  }
};
var yo = class {
  constructor() {
    this.xi = false;
  }
  initialize(t2, e) {
    this.Ni = t2, this.indexManager = e, this.xi = true;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return this.ki(t2, e).next((i) => i || this.Mi(t2, e, s, n)).next((n2) => n2 || this.Oi(t2, e));
  }
  ki(t2, e) {
    if (en(e))
      return Et.resolve(null);
    let n = un(e);
    return this.indexManager.getIndexType(t2, n).next((s) => 0 === s ? null : (null !== e.limit && 1 === s && (e = cn(e, null, "F"), n = un(e)), this.indexManager.getDocumentsMatchingTarget(t2, n).next((s2) => {
      const i = ls(...s2);
      return this.Ni.getDocuments(t2, i).next((s3) => this.indexManager.getMinOffset(t2, n).next((n2) => {
        const r = this.Fi(e, s3);
        return this.$i(e, r, i, n2.readTime) ? this.ki(t2, cn(e, null, "F")) : this.Bi(t2, r, e, n2);
      }));
    })));
  }
  Mi(t2, e, n, s) {
    return en(e) || s.isEqual(nt.min()) ? this.Oi(t2, e) : this.Ni.getDocuments(t2, n).next((i) => {
      const r = this.Fi(e, i);
      return this.$i(e, r, n, s) ? this.Oi(t2, e) : (V2() <= LogLevel.DEBUG && D2("QueryEngine", "Re-using previous result from %s to execute query: %s", s.toString(), ln(e)), this.Bi(t2, r, e, wt(s, -1)));
    });
  }
  Fi(t2, e) {
    let n = new Ut(_n(t2));
    return e.forEach((e2, s) => {
      fn(t2, s) && (n = n.add(s));
    }), n;
  }
  $i(t2, e, n, s) {
    if (null === t2.limit)
      return false;
    if (n.size !== e.size)
      return true;
    const i = "F" === t2.limitType ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Oi(t2, e) {
    return V2() <= LogLevel.DEBUG && D2("QueryEngine", "Using full collection scan to execute query:", ln(e)), this.Ni.getDocumentsMatchingQuery(t2, e, gt.min());
  }
  Bi(t2, e, n, s) {
    return this.Ni.getDocumentsMatchingQuery(t2, n, s).next((t3) => (e.forEach((e2) => {
      t3 = t3.insert(e2.key, e2);
    }), t3));
  }
};
var po = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Li = e, this.It = s, this.Ui = new $t(X2), this.qi = new ts((t3) => Ce(t3), Ne), this.Ki = /* @__PURE__ */ new Map(), this.Gi = t2.getRemoteDocumentCache(), this.Cs = t2.getTargetCache(), this.Ns = t2.getBundleCache(), this.Qi(n);
  }
  Qi(t2) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t2), this.indexManager = this.persistence.getIndexManager(t2), this.mutationQueue = this.persistence.getMutationQueue(t2, this.indexManager), this.localDocuments = new Yr(this.Gi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Gi.setIndexManager(this.indexManager), this.Li.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Ui));
  }
};
function Io(t2, e, n, s) {
  return new po(t2, e, n, s);
}
async function To(t2, e) {
  const n = F(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.mutationQueue.getAllMutationBatches(t3).next((i) => (s = i, n.Qi(e), n.mutationQueue.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = ls();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.localDocuments.getDocuments(t3, o).next((t4) => ({
        ji: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function Eo(t2, e) {
  const n = F(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Gi.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = Et.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          M2(null !== r2), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.mutationQueue.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.mutationQueue.performConsistencyCheck(t3)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(t3, s, e.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t3, function(t4) {
      let e2 = ls();
      for (let n2 = 0; n2 < t4.mutationResults.length; ++n2) {
        t4.mutationResults[n2].transformResults.length > 0 && (e2 = e2.add(t4.batch.mutations[n2].key));
      }
      return e2;
    }(e))).next(() => n.localDocuments.getDocuments(t3, s));
  });
}
function Ao(t2) {
  const e = F(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.Cs.getLastRemoteSnapshotVersion(t3));
}
function Ro(t2, e) {
  const n = F(t2), s = e.snapshotVersion;
  let i = n.Ui;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Gi.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Ui;
    const o = [];
    e.targetChanges.forEach((r2, u2) => {
      const c2 = i.get(u2);
      if (!c2)
        return;
      o.push(n.Cs.removeMatchingKeys(t3, r2.removedDocuments, u2).next(() => n.Cs.addMatchingKeys(t3, r2.addedDocuments, u2)));
      let a = c2.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(u2) ? a = a.withResumeToken(jt.EMPTY_BYTE_STRING, nt.min()).withLastLimboFreeSnapshotVersion(nt.min()) : r2.resumeToken.approximateByteSize() > 0 && (a = a.withResumeToken(r2.resumeToken, s)), i = i.insert(u2, a), function(t4, e2, n2) {
        if (0 === t4.resumeToken.approximateByteSize())
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(c2, a, r2) && o.push(n.Cs.updateTargetData(t3, a));
    });
    let u = ns(), c = ls();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(bo(t3, r, e.documentUpdates).next((t4) => {
      u = t4.Wi, c = t4.zi;
    })), !s.isEqual(nt.min())) {
      const e2 = n.Cs.getLastRemoteSnapshotVersion(t3).next((e3) => n.Cs.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return Et.waitFor(o).next(() => r.apply(t3)).next(() => n.localDocuments.getLocalViewOfDocuments(t3, u, c)).next(() => u);
  }).then((t3) => (n.Ui = i, t3));
}
function bo(t2, e, n) {
  let s = ls(), i = ls();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = ns();
    return n.forEach((n2, r) => {
      const o = t3.get(n2);
      r.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n2)), r.isNoDocument() && r.version.isEqual(nt.min()) ? (e.removeEntry(n2, r.readTime), s2 = s2.insert(n2, r)) : !o.isValidDocument() || r.version.compareTo(o.version) > 0 || 0 === r.version.compareTo(o.version) && o.hasPendingWrites ? (e.addEntry(r), s2 = s2.insert(n2, r)) : D2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", o.version, " Watch version:", r.version);
    }), {
      Wi: s2,
      zi: i
    };
  });
}
function Po(t2, e) {
  const n = F(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (void 0 === e && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t3, e)));
}
function vo(t2, e) {
  const n = F(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.Cs.getTargetData(t3, e).next((i) => i ? (s = i, Et.resolve(s)) : n.Cs.allocateTargetId(t3).next((i2) => (s = new Oi(e, i2, 0, t3.currentSequenceNumber), n.Cs.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.Ui.get(t3.targetId);
    return (null === s || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Ui = n.Ui.insert(t3.targetId, t3), n.qi.set(e, t3.targetId)), t3;
  });
}
async function Vo(t2, e, n) {
  const s = F(t2), i = s.Ui.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!vt(t3))
      throw t3;
    D2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.Ui = s.Ui.remove(e), s.qi.delete(i.target);
}
function So(t2, e, n) {
  const s = F(t2);
  let i = nt.min(), r = ls();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = F(t4), i2 = s2.qi.get(n2);
    return void 0 !== i2 ? Et.resolve(s2.Ui.get(i2)) : s2.Cs.getTargetData(e2, n2);
  }(s, t3, un(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.Cs.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Li.getDocumentsMatchingQuery(t3, e, n ? i : nt.min(), n ? r : ls())).next((t4) => (xo(s, dn(e), t4), {
    documents: t4,
    Hi: r
  })));
}
function Do(t2, e) {
  const n = F(t2), s = F(n.Cs), i = n.Ui.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.se(t3, e).next((t4) => t4 ? t4.target : null));
}
function Co(t2, e) {
  const n = F(t2), s = n.Ki.get(e) || nt.min();
  return n.persistence.runTransaction("Get new document changes", "readonly", (t3) => n.Gi.getAllFromCollectionGroup(
    t3,
    e,
    wt(s, -1),
    Number.MAX_SAFE_INTEGER
  )).then((t3) => (xo(n, e, t3), t3));
}
function xo(t2, e, n) {
  let s = nt.min();
  n.forEach((t3, e2) => {
    e2.readTime.compareTo(s) > 0 && (s = e2.readTime);
  }), t2.Ki.set(e, s);
}
async function No(t2, e, n, s) {
  const i = F(t2);
  let r = ls(), o = ns();
  for (const t3 of n) {
    const n2 = e.Ji(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.Yi(t3);
    s2.setReadTime(e.Xi(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const u = i.Gi.newChangeBuffer({
    trackRemovals: true
  }), c = await vo(i, function(t3) {
    return un(tn(it.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => bo(t3, u, o).next((e2) => (u.apply(t3), e2)).next((e2) => i.Cs.removeMatchingKeysForTargetId(t3, c.targetId).next(() => i.Cs.addMatchingKeys(t3, r, c.targetId)).next(() => i.localDocuments.getLocalViewOfDocuments(t3, e2.Wi, e2.zi)).next(() => e2.Wi)));
}
async function ko(t2, e, n = ls()) {
  const s = await vo(t2, un(ji(e.bundledQuery))), i = F(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = Ss(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Ns.saveNamedQuery(t3, e);
    const o = s.withResumeToken(jt.EMPTY_BYTE_STRING, r);
    return i.Ui = i.Ui.insert(o.targetId, o), i.Cs.updateTargetData(t3, o).next(() => i.Cs.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.Cs.addMatchingKeys(t3, n, s.targetId)).next(() => i.Ns.saveNamedQuery(t3, e));
  });
}
function Mo(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Oo(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Fo(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var $o = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Zi(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = "object" == typeof s && -1 !== ["pending", "acknowledged", "rejected"].indexOf(s.state) && (void 0 === s.error || "object" == typeof s.error);
    return r && s.error && (r = "string" == typeof s.error.message && "string" == typeof s.error.code, r && (i = new B2(s.error.code, s.error.message))), r ? new $o(t2, e, s.state, i) : (C2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  tr() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Bo = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Zi(t2, e) {
    const n = JSON.parse(e);
    let s, i = "object" == typeof n && -1 !== ["not-current", "current", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error);
    return i && n.error && (i = "string" == typeof n.error.message && "string" == typeof n.error.code, i && (s = new B2(n.error.code, n.error.message))), i ? new Bo(t2, n.state, s) : (C2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  tr() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Lo = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Zi(t2, e) {
    const n = JSON.parse(e);
    let s = "object" == typeof n && n.activeTargetIds instanceof Array, i = ds();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = ie(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Lo(t2, i) : (C2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Uo = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Zi(t2) {
    const e = JSON.parse(t2);
    return "object" == typeof e && -1 !== ["Unknown", "Online", "Offline"].indexOf(e.onlineState) && "string" == typeof e.clientId ? new Uo(e.clientId, e.onlineState) : (C2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var qo = class {
  constructor() {
    this.activeTargetIds = ds();
  }
  er(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  nr(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  tr() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Ko = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Hs = e, this.persistenceKey = n, this.sr = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.ir = this.rr.bind(this), this.ur = new $t(X2), this.started = false, this.cr = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.ar = Mo(this.persistenceKey, this.sr), this.hr = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.ur = this.ur.insert(this.sr, new qo()), this.lr = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.dr = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this._r = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.wr = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.mr = function(t3) {
      return `firestore_bundle_loaded_v2_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.ir);
  }
  static C(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.vi();
    for (const e2 of t2) {
      if (e2 === this.sr)
        continue;
      const t3 = this.getItem(Mo(this.persistenceKey, e2));
      if (t3) {
        const n = Lo.Zi(e2, t3);
        n && (this.ur = this.ur.insert(n.clientId, n));
      }
    }
    this.gr();
    const e = this.storage.getItem(this.wr);
    if (e) {
      const t3 = this.yr(e);
      t3 && this.pr(t3);
    }
    for (const t3 of this.cr)
      this.rr(t3);
    this.cr = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.hr, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.Ir(this.ur);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.ur.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.Tr(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.Tr(t2, e, n), this.Er(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(Fo(this.persistenceKey, t2));
      if (n) {
        const s = Bo.Zi(t2, n);
        s && (e = s.state);
      }
    }
    return this.Ar.er(t2), this.gr(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Ar.nr(t2), this.gr();
  }
  isLocalQueryTarget(t2) {
    return this.Ar.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(Fo(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Rr(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.Er(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.br(t2);
  }
  notifyBundleLoaded(t2) {
    this.Pr(t2);
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.ir), this.removeItem(this.ar), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return D2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    D2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    D2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  rr(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (D2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.ar)
        return void C2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Hs.enqueueRetryable(async () => {
        if (this.started) {
          if (null !== e.key) {
            if (this.lr.test(e.key)) {
              if (null == e.newValue) {
                const t3 = this.vr(e.key);
                return this.Vr(t3, null);
              }
              {
                const t3 = this.Sr(e.key, e.newValue);
                if (t3)
                  return this.Vr(t3.clientId, t3);
              }
            } else if (this.dr.test(e.key)) {
              if (null !== e.newValue) {
                const t3 = this.Dr(e.key, e.newValue);
                if (t3)
                  return this.Cr(t3);
              }
            } else if (this._r.test(e.key)) {
              if (null !== e.newValue) {
                const t3 = this.Nr(e.key, e.newValue);
                if (t3)
                  return this.kr(t3);
              }
            } else if (e.key === this.wr) {
              if (null !== e.newValue) {
                const t3 = this.yr(e.newValue);
                if (t3)
                  return this.pr(t3);
              }
            } else if (e.key === this.hr) {
              const t3 = function(t4) {
                let e2 = kt.at;
                if (null != t4)
                  try {
                    const n = JSON.parse(t4);
                    M2("number" == typeof n), e2 = n;
                  } catch (t5) {
                    C2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== kt.at && this.sequenceNumberHandler(t3);
            } else if (e.key === this.mr) {
              const t3 = this.Mr(e.newValue);
              await Promise.all(t3.map((t4) => this.syncEngine.Or(t4)));
            }
          }
        } else
          this.cr.push(e);
      });
    }
  }
  get Ar() {
    return this.ur.get(this.sr);
  }
  gr() {
    this.setItem(this.ar, this.Ar.tr());
  }
  Tr(t2, e, n) {
    const s = new $o(this.currentUser, t2, e, n), i = Oo(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.tr());
  }
  Er(t2) {
    const e = Oo(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  br(t2) {
    const e = {
      clientId: this.sr,
      onlineState: t2
    };
    this.storage.setItem(this.wr, JSON.stringify(e));
  }
  Rr(t2, e, n) {
    const s = Fo(this.persistenceKey, t2), i = new Bo(t2, e, n);
    this.setItem(s, i.tr());
  }
  Pr(t2) {
    const e = JSON.stringify(Array.from(t2));
    this.setItem(this.mr, e);
  }
  vr(t2) {
    const e = this.lr.exec(t2);
    return e ? e[1] : null;
  }
  Sr(t2, e) {
    const n = this.vr(t2);
    return Lo.Zi(n, e);
  }
  Dr(t2, e) {
    const n = this.dr.exec(t2), s = Number(n[1]), i = void 0 !== n[2] ? n[2] : null;
    return $o.Zi(new b(i), s, e);
  }
  Nr(t2, e) {
    const n = this._r.exec(t2), s = Number(n[1]);
    return Bo.Zi(s, e);
  }
  yr(t2) {
    return Uo.Zi(t2);
  }
  Mr(t2) {
    return JSON.parse(t2);
  }
  async Cr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.Fr(t2.batchId, t2.state, t2.error);
    D2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  kr(t2) {
    return this.syncEngine.$r(t2.targetId, t2.state, t2.error);
  }
  Vr(t2, e) {
    const n = e ? this.ur.insert(t2, e) : this.ur.remove(t2), s = this.Ir(this.ur), i = this.Ir(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.Br(r, o).then(() => {
      this.ur = n;
    });
  }
  pr(t2) {
    this.ur.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  Ir(t2) {
    let e = ds();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Go = class {
  constructor() {
    this.Lr = new qo(), this.Ur = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.Lr.er(t2), this.Ur[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.Ur[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.Lr.nr(t2);
  }
  isLocalQueryTarget(t2) {
    return this.Lr.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.Ur[t2];
  }
  getAllActiveQueryTargets() {
    return this.Lr.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.Lr.activeTargetIds.has(t2);
  }
  start() {
    return this.Lr = new qo(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded(t2) {
  }
};
var Qo = class {
  qr(t2) {
  }
  shutdown() {
  }
};
var jo = class {
  constructor() {
    this.Kr = () => this.Gr(), this.Qr = () => this.jr(), this.Wr = [], this.zr();
  }
  qr(t2) {
    this.Wr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Kr), window.removeEventListener("offline", this.Qr);
  }
  zr() {
    window.addEventListener("online", this.Kr), window.addEventListener("offline", this.Qr);
  }
  Gr() {
    D2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Wr)
      t2(0);
  }
  jr() {
    D2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Wr)
      t2(1);
  }
  static C() {
    return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
  }
};
var Wo = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var zo = class {
  constructor(t2) {
    this.Hr = t2.Hr, this.Jr = t2.Jr;
  }
  Yr(t2) {
    this.Xr = t2;
  }
  Zr(t2) {
    this.eo = t2;
  }
  onMessage(t2) {
    this.no = t2;
  }
  close() {
    this.Jr();
  }
  send(t2) {
    this.Hr(t2);
  }
  so() {
    this.Xr();
  }
  io(t2) {
    this.eo(t2);
  }
  ro(t2) {
    this.no(t2);
  }
};
var Ho = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.oo = e + "://" + t2.host, this.uo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  co(t2, e, n, s, i) {
    const r = this.ao(t2, e);
    D2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.ho(o, s, i), this.lo(t2, r, o, n).then((t3) => (D2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw x2("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  fo(t2, e, n, s, i, r) {
    return this.co(t2, e, n, s, i);
  }
  ho(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + P2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  ao(t2, e) {
    const n = Wo[t2];
    return `${this.oo}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  lo(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              D2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              D2("Connection", 'RPC "' + t2 + '" timed out'), r(new B2($.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (D2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values($).indexOf(e4) >= 0 ? e4 : $.UNKNOWN;
                  }(t3.status);
                  r(new B2(e3, t3.message));
                } else
                  r(new B2($.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new B2($.UNAVAILABLE, "Connection failed."));
              break;
            default:
              k2();
          }
        } finally {
          D2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const u = JSON.stringify(s);
      o.send(e, "POST", u, n, 15);
    });
  }
  _o(t2, e, n) {
    const s = [this.oo, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.ho(o.initMessageHeaders, e, n), o.encodeInitMessageHeaders = true;
    const u = s.join("");
    D2("Connection", "Creating WebChannel: " + u, o);
    const c = i.createWebChannel(u, o);
    let a = false, h = false;
    const l2 = new zo({
      Hr: (t3) => {
        h ? D2("Connection", "Not sending because WebChannel is closed:", t3) : (a || (D2("Connection", "Opening WebChannel transport."), c.open(), a = true), D2("Connection", "WebChannel sending:", t3), c.send(t3));
      },
      Jr: () => c.close()
    }), f = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return f(c, WebChannel.EventType.OPEN, () => {
      h || D2("Connection", "WebChannel transport opened.");
    }), f(c, WebChannel.EventType.CLOSE, () => {
      h || (h = true, D2("Connection", "WebChannel transport closed"), l2.io());
    }), f(c, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, x2("Connection", "WebChannel transport errored:", t3), l2.io(new B2($.UNAVAILABLE, "The operation could not be completed")));
    }), f(c, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        M2(!!n2);
        const s2 = n2, i2 = s2.error || (null === (e2 = s2[0]) || void 0 === e2 ? void 0 : e2.error);
        if (i2) {
          D2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = Jn[t5];
            if (void 0 !== e4)
              return Zn(e4);
          }(t4), n3 = i2.message;
          void 0 === e3 && (e3 = $.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.io(new B2(e3, n3)), c.close();
        } else
          D2("Connection", "WebChannel received:", n2), l2.ro(n2);
      }
    }), f(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? D2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && D2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.so();
    }, 0), l2;
  }
};
function Jo() {
  return "undefined" != typeof window ? window : null;
}
function Yo() {
  return "undefined" != typeof document ? document : null;
}
function Xo(t2) {
  return new bs(t2, true);
}
var Zo = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Hs = t2, this.timerId = e, this.wo = n, this.mo = s, this.yo = i, this.po = 0, this.Io = null, this.To = Date.now(), this.reset();
  }
  reset() {
    this.po = 0;
  }
  Eo() {
    this.po = this.yo;
  }
  Ao(t2) {
    this.cancel();
    const e = Math.floor(this.po + this.Ro()), n = Math.max(0, Date.now() - this.To), s = Math.max(0, e - n);
    s > 0 && D2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.po} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Io = this.Hs.enqueueAfterDelay(this.timerId, s, () => (this.To = Date.now(), t2())), this.po *= this.mo, this.po < this.wo && (this.po = this.wo), this.po > this.yo && (this.po = this.yo);
  }
  bo() {
    null !== this.Io && (this.Io.skipDelay(), this.Io = null);
  }
  cancel() {
    null !== this.Io && (this.Io.cancel(), this.Io = null);
  }
  Ro() {
    return (Math.random() - 0.5) * this.po;
  }
};
var tu = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.Hs = t2, this.Po = n, this.vo = s, this.Vo = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = u, this.state = 0, this.So = 0, this.Do = null, this.Co = null, this.stream = null, this.xo = new Zo(t2, e);
  }
  No() {
    return 1 === this.state || 5 === this.state || this.ko();
  }
  ko() {
    return 2 === this.state || 3 === this.state;
  }
  start() {
    4 !== this.state ? this.auth() : this.Mo();
  }
  async stop() {
    this.No() && await this.close(0);
  }
  Oo() {
    this.state = 0, this.xo.reset();
  }
  Fo() {
    this.ko() && null === this.Do && (this.Do = this.Hs.enqueueAfterDelay(this.Po, 6e4, () => this.$o()));
  }
  Bo(t2) {
    this.Lo(), this.stream.send(t2);
  }
  async $o() {
    if (this.ko())
      return this.close(0);
  }
  Lo() {
    this.Do && (this.Do.cancel(), this.Do = null);
  }
  Uo() {
    this.Co && (this.Co.cancel(), this.Co = null);
  }
  async close(t2, e) {
    this.Lo(), this.Uo(), this.xo.cancel(), this.So++, 4 !== t2 ? this.xo.reset() : e && e.code === $.RESOURCE_EXHAUSTED ? (C2(e.toString()), C2("Using maximum backoff delay to prevent overloading the backend."), this.xo.Eo()) : e && e.code === $.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.qo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Zr(e);
  }
  qo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Ko(this.So), e = this.So;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.So === e && this.Go(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new B2($.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.Qo(t3);
      });
    });
  }
  Go(t2, e) {
    const n = this.Ko(this.So);
    this.stream = this.jo(t2, e), this.stream.Yr(() => {
      n(() => (this.state = 2, this.Co = this.Hs.enqueueAfterDelay(this.vo, 1e4, () => (this.ko() && (this.state = 3), Promise.resolve())), this.listener.Yr()));
    }), this.stream.Zr((t3) => {
      n(() => this.Qo(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  Mo() {
    this.state = 5, this.xo.Ao(async () => {
      this.state = 0, this.start();
    });
  }
  Qo(t2) {
    return D2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Ko(t2) {
    return (e) => {
      this.Hs.enqueueAndForget(() => this.So === t2 ? e() : (D2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var eu = class extends tu {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.It = i;
  }
  jo(t2, e) {
    return this.Vo._o("Listen", t2, e);
  }
  onMessage(t2) {
    this.xo.reset();
    const e = Us(this.It, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return nt.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? nt.min() : e2.readTime ? Ss(e2.readTime) : nt.min();
    }(t2);
    return this.listener.Wo(e, n);
  }
  zo(t2) {
    const e = {};
    e.database = Os(this.It), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = ke(s) ? {
        documents: Qs(t3, s)
      } : {
        query: js(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = vs(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(nt.min()) > 0 && (n2.readTime = Ps(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.It, t2);
    const n = zs(this.It, t2);
    n && (e.labels = n), this.Bo(e);
  }
  Ho(t2) {
    const e = {};
    e.database = Os(this.It), e.removeTarget = t2, this.Bo(e);
  }
};
var nu = class extends tu {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.It = i, this.Jo = false;
  }
  get Yo() {
    return this.Jo;
  }
  start() {
    this.Jo = false, this.lastStreamToken = void 0, super.start();
  }
  qo() {
    this.Jo && this.Xo([]);
  }
  jo(t2, e) {
    return this.Vo._o("Write", t2, e);
  }
  onMessage(t2) {
    if (M2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Jo) {
      this.xo.reset();
      const e = Gs(t2.writeResults, t2.commitTime), n = Ss(t2.commitTime);
      return this.listener.Zo(n, e);
    }
    return M2(!t2.writeResults || 0 === t2.writeResults.length), this.Jo = true, this.listener.tu();
  }
  eu() {
    const t2 = {};
    t2.database = Os(this.It), this.Bo(t2);
  }
  Xo(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => qs(this.It, t3))
    };
    this.Bo(e);
  }
};
var su = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.Vo = n, this.It = s, this.nu = false;
  }
  su() {
    if (this.nu)
      throw new B2($.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  co(t2, e, n) {
    return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.Vo.co(t2, e, n, s, i)).catch((t3) => {
      throw "FirebaseError" === t3.name ? (t3.code === $.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new B2($.UNKNOWN, t3.toString());
    });
  }
  fo(t2, e, n, s) {
    return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, r]) => this.Vo.fo(t2, e, n, i, r, s)).catch((t3) => {
      throw "FirebaseError" === t3.name ? (t3.code === $.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new B2($.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.nu = true;
  }
};
var iu = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.iu = 0, this.ru = null, this.ou = true;
  }
  uu() {
    0 === this.iu && (this.cu("Unknown"), this.ru = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ru = null, this.au("Backend didn't respond within 10 seconds."), this.cu("Offline"), Promise.resolve())));
  }
  hu(t2) {
    "Online" === this.state ? this.cu("Unknown") : (this.iu++, this.iu >= 1 && (this.lu(), this.au(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.cu("Offline")));
  }
  set(t2) {
    this.lu(), this.iu = 0, "Online" === t2 && (this.ou = false), this.cu(t2);
  }
  cu(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  au(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.ou ? (C2(e), this.ou = false) : D2("OnlineStateTracker", e);
  }
  lu() {
    null !== this.ru && (this.ru.cancel(), this.ru = null);
  }
};
var ru = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.fu = [], this.du = /* @__PURE__ */ new Map(), this._u = /* @__PURE__ */ new Set(), this.wu = [], this.mu = i, this.mu.qr((t3) => {
      n.enqueueAndForget(async () => {
        _u(this) && (D2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = F(t4);
          e2._u.add(4), await uu(e2), e2.gu.set("Unknown"), e2._u.delete(4), await ou(e2);
        }(this));
      });
    }), this.gu = new iu(n, s);
  }
};
async function ou(t2) {
  if (_u(t2))
    for (const e of t2.wu)
      await e(true);
}
async function uu(t2) {
  for (const e of t2.wu)
    await e(false);
}
function cu(t2, e) {
  const n = F(t2);
  n.du.has(e.targetId) || (n.du.set(e.targetId, e), du(n) ? fu(n) : xu(n).ko() && hu(n, e));
}
function au(t2, e) {
  const n = F(t2), s = xu(n);
  n.du.delete(e), s.ko() && lu(n, e), 0 === n.du.size && (s.ko() ? s.Fo() : _u(n) && n.gu.set("Unknown"));
}
function hu(t2, e) {
  t2.yu.Ot(e.targetId), xu(t2).zo(e);
}
function lu(t2, e) {
  t2.yu.Ot(e), xu(t2).Ho(e);
}
function fu(t2) {
  t2.yu = new Is({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    se: (e) => t2.du.get(e) || null
  }), xu(t2).start(), t2.gu.uu();
}
function du(t2) {
  return _u(t2) && !xu(t2).No() && t2.du.size > 0;
}
function _u(t2) {
  return 0 === F(t2)._u.size;
}
function wu(t2) {
  t2.yu = void 0;
}
async function mu(t2) {
  t2.du.forEach((e, n) => {
    hu(t2, e);
  });
}
async function gu(t2, e) {
  wu(t2), du(t2) ? (t2.gu.hu(e), fu(t2)) : t2.gu.set("Unknown");
}
async function yu(t2, e, n) {
  if (t2.gu.set("Online"), e instanceof ys && 2 === e.state && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.du.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.du.delete(s), t3.yu.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      D2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await pu(t2, n2);
    }
  else if (e instanceof ms ? t2.yu.Gt(e) : e instanceof gs ? t2.yu.Yt(e) : t2.yu.Wt(e), !n.isEqual(nt.min()))
    try {
      const e2 = await Ao(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.yu.te(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.du.get(s);
            i && t3.du.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.du.get(e4);
          if (!n3)
            return;
          t3.du.set(e4, n3.withResumeToken(jt.EMPTY_BYTE_STRING, n3.snapshotVersion)), lu(t3, e4);
          const s = new Oi(n3.target, e4, 1, n3.sequenceNumber);
          hu(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      D2("RemoteStore", "Failed to raise snapshot:", e2), await pu(t2, e2);
    }
}
async function pu(t2, e, n) {
  if (!vt(e))
    throw e;
  t2._u.add(1), await uu(t2), t2.gu.set("Offline"), n || (n = () => Ao(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    D2("RemoteStore", "Retrying IndexedDB access"), await n(), t2._u.delete(1), await ou(t2);
  });
}
function Iu(t2, e) {
  return e().catch((n) => pu(t2, n, e));
}
async function Tu(t2) {
  const e = F(t2), n = Nu(e);
  let s = e.fu.length > 0 ? e.fu[e.fu.length - 1].batchId : -1;
  for (; Eu(e); )
    try {
      const t3 = await Po(e.localStore, s);
      if (null === t3) {
        0 === e.fu.length && n.Fo();
        break;
      }
      s = t3.batchId, Au(e, t3);
    } catch (t3) {
      await pu(e, t3);
    }
  Ru(e) && bu(e);
}
function Eu(t2) {
  return _u(t2) && t2.fu.length < 10;
}
function Au(t2, e) {
  t2.fu.push(e);
  const n = Nu(t2);
  n.ko() && n.Yo && n.Xo(e.mutations);
}
function Ru(t2) {
  return _u(t2) && !Nu(t2).No() && t2.fu.length > 0;
}
function bu(t2) {
  Nu(t2).start();
}
async function Pu(t2) {
  Nu(t2).eu();
}
async function vu(t2) {
  const e = Nu(t2);
  for (const n of t2.fu)
    e.Xo(n.mutations);
}
async function Vu(t2, e, n) {
  const s = t2.fu.shift(), i = ki.from(s, e, n);
  await Iu(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Tu(t2);
}
async function Su(t2, e) {
  e && Nu(t2).Yo && await async function(t3, e2) {
    if (n = e2.code, Xn(n) && n !== $.ABORTED) {
      const n2 = t3.fu.shift();
      Nu(t3).Oo(), await Iu(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Tu(t3);
    }
    var n;
  }(t2, e), Ru(t2) && bu(t2);
}
async function Du(t2, e) {
  const n = F(t2);
  n.asyncQueue.verifyOperationInProgress(), D2("RemoteStore", "RemoteStore received new credentials");
  const s = _u(n);
  n._u.add(3), await uu(n), s && n.gu.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n._u.delete(3), await ou(n);
}
async function Cu(t2, e) {
  const n = F(t2);
  e ? (n._u.delete(2), await ou(n)) : e || (n._u.add(2), await uu(n), n.gu.set("Unknown"));
}
function xu(t2) {
  return t2.pu || (t2.pu = function(t3, e, n) {
    const s = F(t3);
    return s.su(), new eu(e, s.Vo, s.authCredentials, s.appCheckCredentials, s.It, n);
  }(t2.datastore, t2.asyncQueue, {
    Yr: mu.bind(null, t2),
    Zr: gu.bind(null, t2),
    Wo: yu.bind(null, t2)
  }), t2.wu.push(async (e) => {
    e ? (t2.pu.Oo(), du(t2) ? fu(t2) : t2.gu.set("Unknown")) : (await t2.pu.stop(), wu(t2));
  })), t2.pu;
}
function Nu(t2) {
  return t2.Iu || (t2.Iu = function(t3, e, n) {
    const s = F(t3);
    return s.su(), new nu(e, s.Vo, s.authCredentials, s.appCheckCredentials, s.It, n);
  }(t2.datastore, t2.asyncQueue, {
    Yr: Pu.bind(null, t2),
    Zr: Su.bind(null, t2),
    tu: vu.bind(null, t2),
    Zo: Vu.bind(null, t2)
  }), t2.wu.push(async (e) => {
    e ? (t2.Iu.Oo(), await Tu(t2)) : (await t2.Iu.stop(), t2.fu.length > 0 && (D2("RemoteStore", `Stopping write stream with ${t2.fu.length} pending writes`), t2.fu = []));
  })), t2.Iu;
}
var ku = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new L2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new ku(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new B2($.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Mu(t2, e) {
  if (C2("AsyncQueue", `${e}: ${t2}`), vt(t2))
    return new B2($.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Ou = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || ut.comparator(e.key, n.key) : (t3, e) => ut.comparator(t3.key, e.key), this.keyedMap = is(), this.sortedSet = new $t(this.comparator);
  }
  static emptySet(t2) {
    return new Ou(t2.comparator);
  }
  has(t2) {
    return null != this.keyedMap.get(t2);
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Ou))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), 0 === t2.length ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Ou();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var Fu = class {
  constructor() {
    this.Tu = new $t(ut.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.Tu.get(e);
    n ? 0 !== t2.type && 3 === n.type ? this.Tu = this.Tu.insert(e, t2) : 3 === t2.type && 1 !== n.type ? this.Tu = this.Tu.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : 2 === t2.type && 2 === n.type ? this.Tu = this.Tu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : 2 === t2.type && 0 === n.type ? this.Tu = this.Tu.insert(e, {
      type: 0,
      doc: t2.doc
    }) : 1 === t2.type && 0 === n.type ? this.Tu = this.Tu.remove(e) : 1 === t2.type && 2 === n.type ? this.Tu = this.Tu.insert(e, {
      type: 1,
      doc: n.doc
    }) : 0 === t2.type && 1 === n.type ? this.Tu = this.Tu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : k2() : this.Tu = this.Tu.insert(e, t2);
  }
  Eu() {
    const t2 = [];
    return this.Tu.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var $u = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = u;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new $u(
      t2,
      e,
      Ou.emptySet(e),
      i,
      n,
      s,
      true,
      false
    );
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && an(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Bu = class {
  constructor() {
    this.Au = void 0, this.listeners = [];
  }
};
var Lu = class {
  constructor() {
    this.queries = new ts((t2) => hn(t2), an), this.onlineState = "Unknown", this.Ru = /* @__PURE__ */ new Set();
  }
};
async function Uu(t2, e) {
  const n = F(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Bu()), i)
    try {
      r.Au = await n.onListen(s);
    } catch (t3) {
      const n2 = Mu(t3, `Initialization of query '${ln(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.bu(n.onlineState), r.Au) {
    e.Pu(r.Au) && Qu(n);
  }
}
async function qu(t2, e) {
  const n = F(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = 0 === r.listeners.length);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Ku(t2, e) {
  const n = F(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Pu(t3) && (s = true);
      i.Au = t3;
    }
  }
  s && Qu(n);
}
function Gu(t2, e, n) {
  const s = F(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Qu(t2) {
  t2.Ru.forEach((t3) => {
    t3.next();
  });
}
var ju = class {
  constructor(t2, e, n) {
    this.query = t2, this.vu = e, this.Vu = false, this.Su = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Pu(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        3 !== n.type && e2.push(n);
      t2 = new $u(
        t2.query,
        t2.docs,
        t2.oldDocs,
        e2,
        t2.mutatedKeys,
        t2.fromCache,
        t2.syncStateChanged,
        true
      );
    }
    let e = false;
    return this.Vu ? this.Du(t2) && (this.vu.next(t2), e = true) : this.Cu(t2, this.onlineState) && (this.xu(t2), e = true), this.Su = t2, e;
  }
  onError(t2) {
    this.vu.error(t2);
  }
  bu(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Su && !this.Vu && this.Cu(this.Su, t2) && (this.xu(this.Su), e = true), e;
  }
  Cu(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = "Offline" !== e;
    return (!this.options.Nu || !n) && (!t2.docs.isEmpty() || "Offline" === e);
  }
  Du(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Su && this.Su.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && true === this.options.includeMetadataChanges;
  }
  xu(t2) {
    t2 = $u.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.Vu = true, this.vu.next(t2);
  }
};
var Wu = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  ku() {
    return "metadata" in this.payload;
  }
};
var zu = class {
  constructor(t2) {
    this.It = t2;
  }
  Ji(t2) {
    return Ns(this.It, t2);
  }
  Yi(t2) {
    return t2.metadata.exists ? Bs(this.It, t2.document, false) : Ve.newNoDocument(this.Ji(t2.metadata.name), this.Xi(t2.metadata.readTime));
  }
  Xi(t2) {
    return Ss(t2);
  }
};
var Hu = class {
  constructor(t2, e, n) {
    this.Mu = t2, this.localStore = e, this.It = n, this.queries = [], this.documents = [], this.collectionGroups = /* @__PURE__ */ new Set(), this.progress = Ju(t2);
  }
  Ou(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    if (t2.payload.namedQuery)
      this.queries.push(t2.payload.namedQuery);
    else if (t2.payload.documentMetadata) {
      this.documents.push({
        metadata: t2.payload.documentMetadata
      }), t2.payload.documentMetadata.exists || ++e;
      const n = it.fromString(t2.payload.documentMetadata.name);
      this.collectionGroups.add(n.get(n.length - 2));
    } else
      t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e);
    return e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  Fu(t2) {
    const e = /* @__PURE__ */ new Map(), n = new zu(this.It);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Ji(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || ls()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await No(this.localStore, new zu(this.It), this.documents, this.Mu.id), e = this.Fu(this.documents);
    for (const t3 of this.queries)
      await ko(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", {
      progress: this.progress,
      $u: this.collectionGroups,
      Bu: t2
    };
  }
};
function Ju(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Yu = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Xu = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Zu = class {
  constructor(t2, e) {
    this.query = t2, this.Lu = e, this.Uu = null, this.current = false, this.qu = ls(), this.mutatedKeys = ls(), this.Ku = _n(t2), this.Gu = new Ou(this.Ku);
  }
  get Qu() {
    return this.Lu;
  }
  ju(t2, e) {
    const n = e ? e.Wu : new Fu(), s = e ? e.Gu : this.Gu;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const u = "F" === this.query.limitType && s.size === this.query.limit ? s.last() : null, c = "L" === this.query.limitType && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const a = s.get(t3), h = fn(this.query, e2) ? e2 : null, l2 = !!a && this.mutatedKeys.has(a.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (a && h) {
        a.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.zu(a, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (u && this.Ku(h, u) > 0 || c && this.Ku(h, c) < 0) && (o = true));
      } else
        !a && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : a && !h && (n.track({
          type: 1,
          doc: a
        }), d = true, (u || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), null !== this.query.limit)
      for (; r.size > this.query.limit; ) {
        const t3 = "F" === this.query.limitType ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Gu: r,
      Wu: n,
      $i: o,
      mutatedKeys: i
    };
  }
  zu(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Gu;
    this.Gu = t2.Gu, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Wu.Eu();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return k2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Ku(t3.doc, e2.doc)), this.Hu(n);
    const r = e ? this.Ju() : [], o = 0 === this.qu.size && this.current ? 1 : 0, u = o !== this.Uu;
    if (this.Uu = o, 0 !== i.length || u) {
      return {
        snapshot: new $u(
          this.query,
          t2.Gu,
          s,
          i,
          t2.mutatedKeys,
          0 === o,
          u,
          false
        ),
        Yu: r
      };
    }
    return {
      Yu: r
    };
  }
  bu(t2) {
    return this.current && "Offline" === t2 ? (this.current = false, this.applyChanges(
      {
        Gu: this.Gu,
        Wu: new Fu(),
        mutatedKeys: this.mutatedKeys,
        $i: false
      },
      false
    )) : {
      Yu: []
    };
  }
  Xu(t2) {
    return !this.Lu.has(t2) && (!!this.Gu.has(t2) && !this.Gu.get(t2).hasLocalMutations);
  }
  Hu(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.Lu = this.Lu.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.Lu = this.Lu.delete(t3)), this.current = t2.current);
  }
  Ju() {
    if (!this.current)
      return [];
    const t2 = this.qu;
    this.qu = ls(), this.Gu.forEach((t3) => {
      this.Xu(t3.key) && (this.qu = this.qu.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.qu.has(t3) || e.push(new Xu(t3));
    }), this.qu.forEach((n) => {
      t2.has(n) || e.push(new Yu(n));
    }), e;
  }
  Zu(t2) {
    this.Lu = t2.Hi, this.qu = ls();
    const e = this.ju(t2.documents);
    return this.applyChanges(e, true);
  }
  tc() {
    return $u.fromInitialDocuments(this.query, this.Gu, this.mutatedKeys, 0 === this.Uu);
  }
};
var tc2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var ec2 = class {
  constructor(t2) {
    this.key = t2, this.ec = false;
  }
};
var nc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.nc = {}, this.sc = new ts((t3) => hn(t3), an), this.ic = /* @__PURE__ */ new Map(), this.rc = /* @__PURE__ */ new Set(), this.oc = new $t(ut.comparator), this.uc = /* @__PURE__ */ new Map(), this.cc = new to(), this.ac = {}, this.hc = /* @__PURE__ */ new Map(), this.lc = Dr.vn(), this.onlineState = "Unknown", this.fc = void 0;
  }
  get isPrimaryClient() {
    return true === this.fc;
  }
};
async function sc2(t2, e) {
  const n = xc2(t2);
  let s, i;
  const r = n.sc.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.tc();
  else {
    const t3 = await vo(n.localStore, un(e));
    n.isPrimaryClient && cu(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await ic2(n, e, s, "current" === r2);
  }
  return i;
}
async function ic2(t2, e, n, s) {
  t2.dc = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.ju(n3);
    i2.$i && (i2 = await So(
      t3.localStore,
      e3.query,
      false
    ).then(({ documents: t4 }) => e3.view.ju(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(
      i2,
      t3.isPrimaryClient,
      r2
    );
    return gc2(t3, e3.targetId, o2.Yu), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await So(
    t2.localStore,
    e,
    true
  ), r = new Zu(e, i.Hi), o = r.ju(i.documents), u = ws.createSynthesizedTargetChangeForCurrentChange(n, s && "Offline" !== t2.onlineState), c = r.applyChanges(
    o,
    t2.isPrimaryClient,
    u
  );
  gc2(t2, n, c.Yu);
  const a = new tc2(e, n, r);
  return t2.sc.set(e, a), t2.ic.has(n) ? t2.ic.get(n).push(e) : t2.ic.set(n, [e]), c.snapshot;
}
async function rc2(t2, e) {
  const n = F(t2), s = n.sc.get(e), i = n.ic.get(s.targetId);
  if (i.length > 1)
    return n.ic.set(s.targetId, i.filter((t3) => !an(t3, e))), void n.sc.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await Vo(
      n.localStore,
      s.targetId,
      false
    ).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), au(n.remoteStore, s.targetId), wc2(n, s.targetId);
    }).catch(Tt);
  } else
    wc2(n, s.targetId), await Vo(
      n.localStore,
      s.targetId,
      true
    );
}
async function oc2(t2, e, n) {
  const s = Nc2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = F(t4), s2 = et.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), ls());
      let r, o;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => {
        let u = ns(), c = ls();
        return n2.Gi.getEntries(t5, i).next((t6) => {
          u = t6, u.forEach((t7, e3) => {
            e3.isValidDocument() || (c = c.add(t7));
          });
        }).next(() => n2.localDocuments.getOverlayedDocuments(t5, u)).next((i2) => {
          r = i2;
          const o2 = [];
          for (const t6 of e2) {
            const e3 = Ln(t6, r.get(t6.key).overlayedDocument);
            null != e3 && o2.push(new Kn(t6.key, e3, ve(e3.value.mapValue), kn.exists(true)));
          }
          return n2.mutationQueue.addMutationBatch(t5, s2, o2, e2);
        }).next((e3) => {
          o = e3;
          const s3 = e3.applyToLocalDocumentSet(r, c);
          return n2.documentOverlayCache.saveOverlays(t5, e3.batchId, s3);
        });
      }).then(() => ({
        batchId: o.batchId,
        changes: rs(r)
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.ac[t4.currentUser.toKey()];
      s2 || (s2 = new $t(X2));
      s2 = s2.insert(e2, n2), t4.ac[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await Ic2(s, t3.changes), await Tu(s.remoteStore);
  } catch (t3) {
    const e2 = Mu(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function uc2(t2, e) {
  const n = F(t2);
  try {
    const t3 = await Ro(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.uc.get(e2);
      s && (M2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.ec = true : t4.modifiedDocuments.size > 0 ? M2(s.ec) : t4.removedDocuments.size > 0 && (M2(s.ec), s.ec = false));
    }), await Ic2(n, t3, e);
  } catch (t3) {
    await Tt(t3);
  }
}
function cc2(t2, e, n) {
  const s = F(t2);
  if (s.isPrimaryClient && 0 === n || !s.isPrimaryClient && 1 === n) {
    const t3 = [];
    s.sc.forEach((n2, s2) => {
      const i = s2.view.bu(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = F(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.bu(e2) && (s2 = true);
      }), s2 && Qu(n2);
    }(s.eventManager, e), t3.length && s.nc.Wo(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function ac2(t2, e, n) {
  const s = F(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.uc.get(e), r = i && i.key;
  if (r) {
    let t3 = new $t(ut.comparator);
    t3 = t3.insert(r, Ve.newNoDocument(r, nt.min()));
    const n2 = ls().add(r), i2 = new _s(
      nt.min(),
      /* @__PURE__ */ new Map(),
      new Ut(X2),
      t3,
      n2
    );
    await uc2(s, i2), s.oc = s.oc.remove(r), s.uc.delete(e), pc2(s);
  } else
    await Vo(
      s.localStore,
      e,
      false
    ).then(() => wc2(s, e, n)).catch(Tt);
}
async function hc2(t2, e) {
  const n = F(t2), s = e.batch.batchId;
  try {
    const t3 = await Eo(n.localStore, e);
    _c(n, s, null), dc2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Ic2(n, t3);
  } catch (t3) {
    await Tt(t3);
  }
}
async function lc2(t2, e, n) {
  const s = F(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = F(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.mutationQueue.lookupMutationBatch(t5, e2).next((e3) => (M2(null !== e3), s2 = e3.keys(), n2.mutationQueue.removeMutationBatch(t5, e3))).next(() => n2.mutationQueue.performConsistencyCheck(t5)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(t5, s2, e2)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t5, s2)).next(() => n2.localDocuments.getDocuments(t5, s2));
      });
    }(s.localStore, e);
    _c(s, e, n), dc2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Ic2(s, t3);
  } catch (n2) {
    await Tt(n2);
  }
}
async function fc2(t2, e) {
  const n = F(t2);
  _u(n.remoteStore) || D2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = F(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.mutationQueue.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (-1 === t3)
      return void e.resolve();
    const s = n.hc.get(t3) || [];
    s.push(e), n.hc.set(t3, s);
  } catch (t3) {
    const n2 = Mu(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function dc2(t2, e) {
  (t2.hc.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.hc.delete(e);
}
function _c(t2, e, n) {
  const s = F(t2);
  let i = s.ac[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.ac[s.currentUser.toKey()] = i;
  }
}
function wc2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ic.get(e))
    t2.sc.delete(s), n && t2.nc._c(s, n);
  if (t2.ic.delete(e), t2.isPrimaryClient) {
    t2.cc.ls(e).forEach((e2) => {
      t2.cc.containsKey(e2) || mc2(t2, e2);
    });
  }
}
function mc2(t2, e) {
  t2.rc.delete(e.path.canonicalString());
  const n = t2.oc.get(e);
  null !== n && (au(t2.remoteStore, n), t2.oc = t2.oc.remove(e), t2.uc.delete(n), pc2(t2));
}
function gc2(t2, e, n) {
  for (const s of n)
    if (s instanceof Yu)
      t2.cc.addReference(s.key, e), yc2(t2, s);
    else if (s instanceof Xu) {
      D2("SyncEngine", "Document no longer in limbo: " + s.key), t2.cc.removeReference(s.key, e);
      t2.cc.containsKey(s.key) || mc2(t2, s.key);
    } else
      k2();
}
function yc2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.oc.get(n) || t2.rc.has(s) || (D2("SyncEngine", "New document in limbo: " + n), t2.rc.add(s), pc2(t2));
}
function pc2(t2) {
  for (; t2.rc.size > 0 && t2.oc.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.rc.values().next().value;
    t2.rc.delete(e);
    const n = new ut(it.fromString(e)), s = t2.lc.next();
    t2.uc.set(s, new ec2(n)), t2.oc = t2.oc.insert(n, s), cu(t2.remoteStore, new Oi(un(tn(n.path)), s, 2, kt.at));
  }
}
async function Ic2(t2, e, n) {
  const s = F(t2), i = [], r = [], o = [];
  s.sc.isEmpty() || (s.sc.forEach((t3, u) => {
    o.push(s.dc(u, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(u.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = go.Ci(u.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.nc.Wo(i), await async function(t3, e2) {
    const n2 = F(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => Et.forEach(e2, (e3) => Et.forEach(e3.Si, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => Et.forEach(e3.Di, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!vt(t4))
        throw t4;
      D2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Ui.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.Ui = n2.Ui.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function Tc2(t2, e) {
  const n = F(t2);
  if (!n.currentUser.isEqual(e)) {
    D2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await To(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.hc.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new B2($.CANCELLED, e2));
        });
      }), t4.hc.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await Ic2(n, t3.ji);
  }
}
function Ec2(t2, e) {
  const n = F(t2), s = n.uc.get(e);
  if (s && s.ec)
    return ls().add(s.key);
  {
    let t3 = ls();
    const s2 = n.ic.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.sc.get(e2);
      t3 = t3.unionWith(s3.view.Qu);
    }
    return t3;
  }
}
async function Ac2(t2, e) {
  const n = F(t2), s = await So(
    n.localStore,
    e.query,
    true
  ), i = e.view.Zu(s);
  return n.isPrimaryClient && gc2(n, e.targetId, i.Yu), i;
}
async function Rc2(t2, e) {
  const n = F(t2);
  return Co(n.localStore, e).then((t3) => Ic2(n, t3));
}
async function bc2(t2, e, n, s) {
  const i = F(t2), r = await function(t3, e2) {
    const n2 = F(t3), s2 = F(n2.mutationQueue);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Tn(t4, e2).next((e3) => e3 ? n2.localDocuments.getDocuments(t4, e3) : Et.resolve(null)));
  }(i.localStore, e);
  null !== r ? ("pending" === n ? await Tu(i.remoteStore) : "acknowledged" === n || "rejected" === n ? (_c(i, e, s || null), dc2(i, e), function(t3, e2) {
    F(F(t3).mutationQueue).An(e2);
  }(i.localStore, e)) : k2(), await Ic2(i, r)) : D2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Pc2(t2, e) {
  const n = F(t2);
  if (xc2(n), Nc2(n), true === e && true !== n.fc) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await vc2(n, t3.toArray());
    n.fc = true, await Cu(n.remoteStore, true);
    for (const t4 of e2)
      cu(n.remoteStore, t4);
  } else if (false === e && false !== n.fc) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ic.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (wc2(n, i), Vo(
        n.localStore,
        i,
        true
      ))), au(n.remoteStore, i);
    }), await e2, await vc2(n, t3), function(t4) {
      const e3 = F(t4);
      e3.uc.forEach((t5, n2) => {
        au(e3.remoteStore, n2);
      }), e3.cc.fs(), e3.uc = /* @__PURE__ */ new Map(), e3.oc = new $t(ut.comparator);
    }(n), n.fc = false, await Cu(n.remoteStore, false);
  }
}
async function vc2(t2, e, n) {
  const s = F(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ic.get(t3);
    if (n2 && 0 !== n2.length) {
      e2 = await vo(s.localStore, un(n2[0]));
      for (const t4 of n2) {
        const e3 = s.sc.get(t4), n3 = await Ac2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await Do(s.localStore, t3);
      e2 = await vo(s.localStore, n3), await ic2(
        s,
        Vc2(n3),
        t3,
        false
      );
    }
    i.push(e2);
  }
  return s.nc.Wo(r), i;
}
function Vc2(t2) {
  return Ze(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Sc2(t2) {
  const e = F(t2);
  return F(F(e.localStore).persistence).vi();
}
async function Dc2(t2, e, n, s) {
  const i = F(t2);
  if (i.fc)
    return void D2("SyncEngine", "Ignoring unexpected query state notification.");
  const r = i.ic.get(e);
  if (r && r.length > 0)
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await Co(i.localStore, dn(r[0])), s2 = _s.createSynthesizedRemoteEventForCurrentChange(e, "current" === n);
        await Ic2(i, t3, s2);
        break;
      }
      case "rejected":
        await Vo(
          i.localStore,
          e,
          true
        ), wc2(i, e, s);
        break;
      default:
        k2();
    }
}
async function Cc2(t2, e, n) {
  const s = xc2(t2);
  if (s.fc) {
    for (const t3 of e) {
      if (s.ic.has(t3)) {
        D2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await Do(s.localStore, t3), n2 = await vo(s.localStore, e2);
      await ic2(
        s,
        Vc2(e2),
        n2.targetId,
        false
      ), cu(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ic.has(t3) && await Vo(
        s.localStore,
        t3,
        false
      ).then(() => {
        au(s.remoteStore, t3), wc2(s, t3);
      }).catch(Tt);
  }
}
function xc2(t2) {
  const e = F(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = uc2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Ec2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = ac2.bind(null, e), e.nc.Wo = Ku.bind(null, e.eventManager), e.nc._c = Gu.bind(null, e.eventManager), e;
}
function Nc2(t2) {
  const e = F(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = hc2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = lc2.bind(null, e), e;
}
function kc2(t2, e, n) {
  const s = F(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = F(t4), s3 = Ss(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Ns.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2)), Promise.resolve(/* @__PURE__ */ new Set());
      n2._updateProgress(Ju(s2));
      const i = new Hu(s2, t3.localStore, e2.It);
      let r = await e2.wc();
      for (; r; ) {
        const t4 = await i.Ou(r);
        t4 && n2._updateProgress(t4), r = await e2.wc();
      }
      const o = await i.complete();
      return await Ic2(
        t3,
        o.Bu,
        void 0
      ), await function(t4, e3) {
        const n3 = F(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Ns.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress), Promise.resolve(o.$u);
    } catch (t4) {
      return x2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4), Promise.resolve(/* @__PURE__ */ new Set());
    }
  })(s, e, n).then((t3) => {
    s.sharedClientState.notifyBundleLoaded(t3);
  });
}
var Mc2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.It = Xo(t2.databaseInfo.databaseId), this.sharedClientState = this.mc(t2), this.persistence = this.gc(t2), await this.persistence.start(), this.localStore = this.yc(t2), this.gcScheduler = this.Ic(t2, this.localStore), this.indexBackfillerScheduler = this.Tc(t2, this.localStore);
  }
  Ic(t2, e) {
    return null;
  }
  Tc(t2, e) {
    return null;
  }
  yc(t2) {
    return Io(this.persistence, new yo(), t2.initialUser, this.It);
  }
  gc(t2) {
    return new oo(co.Bs, this.It);
  }
  mc(t2) {
    return new Go();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Oc2 = class extends Mc2 {
  constructor(t2, e, n) {
    super(), this.Ec = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await this.Ec.initialize(this, t2), await Nc2(this.Ec.syncEngine), await Tu(this.Ec.remoteStore), await this.persistence.li(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(), this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(), Promise.resolve()));
  }
  yc(t2) {
    return Io(this.persistence, new yo(), t2.initialUser, this.It);
  }
  Ic(t2, e) {
    const n = this.persistence.referenceDelegate.garbageCollector;
    return new Fr(n, t2.asyncQueue, e);
  }
  Tc(t2, e) {
    const n = new Nt(e, this.persistence);
    return new xt(t2.asyncQueue, n);
  }
  gc(t2) {
    const e = mo(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = void 0 !== this.cacheSizeBytes ? Er.withCacheSize(this.cacheSizeBytes) : Er.DEFAULT;
    return new fo(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Jo(), Yo(), this.It, this.sharedClientState, !!this.forceOwnership);
  }
  mc(t2) {
    return new Go();
  }
};
var Fc2 = class extends Oc2 {
  constructor(t2, e) {
    super(t2, e, false), this.Ec = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.Ec.syncEngine;
    this.sharedClientState instanceof Ko && (this.sharedClientState.syncEngine = {
      Fr: bc2.bind(null, e),
      $r: Dc2.bind(null, e),
      Br: Cc2.bind(null, e),
      vi: Sc2.bind(null, e),
      Or: Rc2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.li(async (t3) => {
      await Pc2(this.Ec.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start() : t3 || this.gcScheduler.stop()), this.indexBackfillerScheduler && (t3 && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : t3 || this.indexBackfillerScheduler.stop());
    });
  }
  mc(t2) {
    const e = Jo();
    if (!Ko.C(e))
      throw new B2($.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = mo(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Ko(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var $c2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(
      e,
      !t2.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (t3) => cc2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Tc2.bind(null, this.syncEngine), await Cu(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Lu();
  }
  createDatastore(t2) {
    const e = Xo(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Ho(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new su(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => cc2(this.syncEngine, t3, 0), r = jo.C() ? new jo() : new Qo(), new ru(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const u = new nc2(t3, e2, n, s, i, r);
      return o && (u.fc = true), u;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = F(t2);
      D2("RemoteStore", "RemoteStore shutting down."), e._u.add(5), await uu(e), e.mu.shutdown(), e.gu.set("Unknown");
    }(this.remoteStore);
  }
};
function Bc2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Lc2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Ac(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Ac(this.observer.error, t2) : C2("Uncaught Error in snapshot listener:", t2);
  }
  Rc() {
    this.muted = true;
  }
  Ac(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Uc2 = class {
  constructor(t2, e) {
    this.bc = t2, this.It = e, this.metadata = new L2(), this.buffer = new Uint8Array(), this.Pc = new TextDecoder("utf-8"), this.vc().then((t3) => {
      t3 && t3.ku() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(null == t3 ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.bc.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async wc() {
    return await this.getMetadata(), this.vc();
  }
  async vc() {
    const t2 = await this.Vc();
    if (null === t2)
      return null;
    const e = this.Pc.decode(t2), n = Number(e);
    isNaN(n) && this.Sc(`length string (${e}) is not valid number`);
    const s = await this.Dc(n);
    return new Wu(JSON.parse(s), t2.length + n);
  }
  Cc() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Vc() {
    for (; this.Cc() < 0; ) {
      if (await this.xc())
        break;
    }
    if (0 === this.buffer.length)
      return null;
    const t2 = this.Cc();
    t2 < 0 && this.Sc("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async Dc(t2) {
    for (; this.buffer.length < t2; ) {
      await this.xc() && this.Sc("Reached the end of bundle when more is expected.");
    }
    const e = this.Pc.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Sc(t2) {
    throw this.bc.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async xc() {
    const t2 = await this.bc.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var qc2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new B2($.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = F(t3), s = Os(n.It) + "/documents", i = {
        documents: e2.map((t4) => xs(n.It, t4))
      }, r = await n.fo("BatchGetDocuments", s, i, e2.length), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = Ls(n.It, t4);
        o.set(e3.key.toString(), e3);
      });
      const u = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        M2(!!e3), u.push(e3);
      }), u;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new Wn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = ut.fromPath(e);
      this.mutations.push(new zn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = F(t3), s = Os(n.It) + "/documents", i = {
        writes: e.map((t4) => qs(n.It, t4))
      };
      await n.co("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw k2();
      e = nt.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new B2($.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? e.isEqual(nt.min()) ? kn.exists(false) : kn.updateTime(e) : kn.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(nt.min()))
        throw new B2($.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return kn.updateTime(e);
    }
    return kn.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Kc2 = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.datastore = e, this.options = n, this.updateFunction = s, this.deferred = i, this.Nc = n.maxAttempts, this.xo = new Zo(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Nc -= 1, this.kc();
  }
  kc() {
    this.xo.Ao(async () => {
      const t2 = new qc2(this.datastore), e = this.Mc(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.Oc(t3);
        }));
      }).catch((t3) => {
        this.Oc(t3);
      });
    });
  }
  Mc(t2) {
    try {
      const e = this.updateFunction(t2);
      return !ne(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  Oc(t2) {
    this.Nc > 0 && this.Fc(t2) ? (this.Nc -= 1, this.asyncQueue.enqueueAndForget(() => (this.kc(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  Fc(t2) {
    if ("FirebaseError" === t2.name) {
      const e = t2.code;
      return "aborted" === e || "failed-precondition" === e || !Xn(e);
    }
    return false;
  }
};
var Gc2 = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = b.UNAUTHENTICATED, this.clientId = Y2.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      D2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (D2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new B2($.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new L2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = Mu(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Qc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), D2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await To(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function jc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Wc2(t2);
  D2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => Du(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => Du(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function Wc2(t2) {
  return t2.offlineComponents || (D2("FirestoreClient", "Using default OfflineComponentProvider"), await Qc2(t2, new Mc2())), t2.offlineComponents;
}
async function zc2(t2) {
  return t2.onlineComponents || (D2("FirestoreClient", "Using default OnlineComponentProvider"), await jc2(t2, new $c2())), t2.onlineComponents;
}
function Hc2(t2) {
  return Wc2(t2).then((t3) => t3.persistence);
}
function Jc2(t2) {
  return Wc2(t2).then((t3) => t3.localStore);
}
function Yc2(t2) {
  return zc2(t2).then((t3) => t3.remoteStore);
}
function Xc2(t2) {
  return zc2(t2).then((t3) => t3.syncEngine);
}
async function Zc2(t2) {
  const e = await zc2(t2), n = e.eventManager;
  return n.onListen = sc2.bind(null, e.syncEngine), n.onUnlisten = rc2.bind(null, e.syncEngine), n;
}
function ta2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Hc2(t2), n = await Yc2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = F(t3);
      return e2._u.delete(0), ou(e2);
    }(n);
  });
}
function ea2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Hc2(t2), n = await Yc2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = F(t3);
      e2._u.add(0), await uu(e2), e2.gu.set("Offline");
    }(n);
  });
}
function na2(t2, e) {
  const n = new L2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = F(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.localDocuments.getDocument(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new B2($.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Mu(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Jc2(t2), e, n)), n.promise;
}
function sa2(t2, e, n = {}) {
  const s = new L2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Lc2({
      next: (r2) => {
        e2.enqueueAndForget(() => qu(t3, o));
        const u = r2.docs.has(n2);
        !u && r2.fromCache ? i.reject(new B2($.UNAVAILABLE, "Failed to get document because the client is offline.")) : u && r2.fromCache && s2 && "server" === s2.source ? i.reject(new B2($.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new ju(tn(n2.path), r, {
      includeMetadataChanges: true,
      Nu: true
    });
    return Uu(t3, o);
  }(await Zc2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ia2(t2, e) {
  const n = new L2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await So(
        t3,
        e2,
        true
      ), i = new Zu(e2, s.Hi), r = i.ju(s.documents), o = i.applyChanges(
        r,
        false
      );
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Mu(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Jc2(t2), e, n)), n.promise;
}
function ra2(t2, e, n = {}) {
  const s = new L2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Lc2({
      next: (n3) => {
        e2.enqueueAndForget(() => qu(t3, o)), n3.fromCache && "server" === s2.source ? i.reject(new B2($.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new ju(n2, r, {
      includeMetadataChanges: true,
      Nu: true
    });
    return Uu(t3, o);
  }(await Zc2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function oa2(t2, e) {
  const n = new Lc2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    F(t3).Ru.add(e2), e2.next();
  }(await Zc2(t2), n)), () => {
    n.Rc(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      F(t3).Ru.delete(e2);
    }(await Zc2(t2), n));
  };
}
function ua2(t2, e, n) {
  const s = new L2();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const i = await function(t3) {
      return zc2(t3).then((t4) => t4.datastore);
    }(t2);
    new Kc2(t2.asyncQueue, i, n, e, s).run();
  }), s.promise;
}
function ca2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = "string" == typeof t3 ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Uc2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Bc2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Bc2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Xo(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    kc2(await Xc2(t2), i, s);
  });
}
function aa2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = F(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Ns.getNamedQuery(t4, e2));
  }(await Jc2(t2), e));
}
var ha2 = /* @__PURE__ */ new Map();
function la2(t2, e, n) {
  if (!n)
    throw new B2($.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function fa2(t2, e, n, s) {
  if (true === e && true === s)
    throw new B2($.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function da2(t2) {
  if (!ut.isDocumentKey(t2))
    throw new B2($.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function _a(t2) {
  if (ut.isDocumentKey(t2))
    throw new B2($.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function wa2(t2) {
  if (void 0 === t2)
    return "undefined";
  if (null === t2)
    return "null";
  if ("string" == typeof t2)
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if ("number" == typeof t2 || "boolean" == typeof t2)
    return "" + t2;
  if ("object" == typeof t2) {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return "function" == typeof t2 ? "a function" : k2();
}
function ma2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new B2($.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = wa2(t2);
      throw new B2($.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function ga(t2, e) {
  if (e <= 0)
    throw new B2($.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var ya2 = class {
  constructor(t2) {
    var e;
    if (void 0 === t2.host) {
      if (void 0 !== t2.ssl)
        throw new B2($.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = null === (e = t2.ssl) || void 0 === e || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, void 0 === t2.cacheSizeBytes)
      this.cacheSizeBytes = 41943040;
    else {
      if (-1 !== t2.cacheSizeBytes && t2.cacheSizeBytes < 1048576)
        throw new B2($.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, fa2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var pa2 = class {
  constructor(t2, e, n, s) {
    this._authCredentials = t2, this._appCheckCredentials = e, this._databaseId = n, this._app = s, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new ya2({}), this._settingsFrozen = false;
  }
  get app() {
    if (!this._app)
      throw new B2($.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return void 0 !== this._terminateTask;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new B2($.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new ya2(t2), void 0 !== t2.credentials && (this._authCredentials = function(t3) {
      if (!t3)
        return new q2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return new j(e, t3.sessionIndex || "0", t3.iamToken || null, t3.authTokenFactory || null);
        case "provider":
          return t3.client;
        default:
          throw new B2($.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = ha2.get(t2);
      e && (D2("ComponentProvider", "Removing Datastore"), ha2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Ia2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = ma2(t2, pa2))._getSettings();
  if ("firestore.googleapis.com" !== r.host && r.host !== e && x2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if ("string" == typeof s.mockUserToken)
      e2 = s.mockUserToken, n2 = b.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, null === (i = t2._app) || void 0 === i ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new B2($.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new b(r2);
    }
    t2._authCredentials = new K2(new U2(e2, n2));
  }
}
var Ta2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new Aa2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new Ta2(this.firestore, t2, this._key);
  }
};
var Ea2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Ea2(this.firestore, t2, this._query);
  }
};
var Aa2 = class extends Ea2 {
  constructor(t2, e, n) {
    super(t2, e, tn(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new Ta2(
      this.firestore,
      null,
      new ut(t2)
    );
  }
  withConverter(t2) {
    return new Aa2(this.firestore, t2, this._path);
  }
};
function Ra2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), la2("collection", "path", e), t2 instanceof pa2) {
    const s = it.fromString(e, ...n);
    return _a(s), new Aa2(t2, null, s);
  }
  {
    if (!(t2 instanceof Ta2 || t2 instanceof Aa2))
      throw new B2($.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(it.fromString(e, ...n));
    return _a(s), new Aa2(
      t2.firestore,
      null,
      s
    );
  }
}
function ba2(t2, e) {
  if (t2 = ma2(t2, pa2), la2("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new B2($.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Ea2(
    t2,
    null,
    function(t3) {
      return new Xe(it.emptyPath(), t3);
    }(e)
  );
}
function Pa2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), 1 === arguments.length && (e = Y2.R()), la2("doc", "path", e), t2 instanceof pa2) {
    const s = it.fromString(e, ...n);
    return da2(s), new Ta2(
      t2,
      null,
      new ut(s)
    );
  }
  {
    if (!(t2 instanceof Ta2 || t2 instanceof Aa2))
      throw new B2($.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(it.fromString(e, ...n));
    return da2(s), new Ta2(t2.firestore, t2 instanceof Aa2 ? t2.converter : null, new ut(s));
  }
}
function va2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof Ta2 || t2 instanceof Aa2) && (e instanceof Ta2 || e instanceof Aa2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function Va2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof Ea2 && e instanceof Ea2 && (t2.firestore === e.firestore && an(t2._query, e._query) && t2.converter === e.converter);
}
var Sa2 = class {
  constructor() {
    this.$c = Promise.resolve(), this.Bc = [], this.Lc = false, this.Uc = [], this.qc = null, this.Kc = false, this.Gc = false, this.Qc = [], this.xo = new Zo(this, "async_queue_retry"), this.jc = () => {
      const t3 = Yo();
      t3 && D2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.xo.bo();
    };
    const t2 = Yo();
    t2 && "function" == typeof t2.addEventListener && t2.addEventListener("visibilitychange", this.jc);
  }
  get isShuttingDown() {
    return this.Lc;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Wc(), this.zc(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.Lc) {
      this.Lc = true, this.Gc = t2 || false;
      const e = Yo();
      e && "function" == typeof e.removeEventListener && e.removeEventListener("visibilitychange", this.jc);
    }
  }
  enqueue(t2) {
    if (this.Wc(), this.Lc)
      return new Promise(() => {
      });
    const e = new L2();
    return this.zc(() => this.Lc && this.Gc ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.Bc.push(t2), this.Hc()));
  }
  async Hc() {
    if (0 !== this.Bc.length) {
      try {
        await this.Bc[0](), this.Bc.shift(), this.xo.reset();
      } catch (t2) {
        if (!vt(t2))
          throw t2;
        D2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.Bc.length > 0 && this.xo.Ao(() => this.Hc());
    }
  }
  zc(t2) {
    const e = this.$c.then(() => (this.Kc = true, t2().catch((t3) => {
      this.qc = t3, this.Kc = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw C2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Kc = false, t3))));
    return this.$c = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Wc(), this.Qc.indexOf(t2) > -1 && (e = 0);
    const s = ku.createAndSchedule(this, t2, e, n, (t3) => this.Jc(t3));
    return this.Uc.push(s), s;
  }
  Wc() {
    this.qc && k2();
  }
  verifyOperationInProgress() {
  }
  async Yc() {
    let t2;
    do {
      t2 = this.$c, await t2;
    } while (t2 !== this.$c);
  }
  Xc(t2) {
    for (const e of this.Uc)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Zc(t2) {
    return this.Yc().then(() => {
      this.Uc.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.Uc)
        if (e.skipDelay(), "all" !== t2 && e.timerId === t2)
          break;
      return this.Yc();
    });
  }
  ta(t2) {
    this.Qc.push(t2);
  }
  Jc(t2) {
    const e = this.Uc.indexOf(t2);
    this.Uc.splice(e, 1);
  }
};
function Da(t2) {
  return function(t3, e) {
    if ("object" != typeof t3 || null === t3)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && "function" == typeof n[t4])
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Ca = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new L2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var xa2 = -1;
var Na2 = class extends pa2 {
  constructor(t2, e, n, s) {
    super(t2, e, n, s), this.type = "firestore", this._queue = new Sa2(), this._persistenceKey = (null == s ? void 0 : s.name) || "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Fa(this), this._firestoreClient.terminate();
  }
};
function ka2(t2, e, n) {
  n || (n = "(default)");
  const s = _getProvider(t2, "firestore");
  if (s.isInitialized(n)) {
    const t3 = s.getImmediate({
      identifier: n
    }), i = s.getOptions(n);
    if (deepEqual(i, e))
      return t3;
    throw new B2($.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (void 0 !== e.cacheSizeBytes && -1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576)
    throw new B2($.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return s.initialize({
    options: e,
    instanceIdentifier: n
  });
}
function Ma2(e, n) {
  const s = "object" == typeof e ? e : getApp(), i = "string" == typeof e ? e : n || "(default)";
  return _getProvider(s, "firestore").getImmediate({
    identifier: i
  });
}
function Oa2(t2) {
  return t2._firestoreClient || Fa(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Fa(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new te(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, (null === (e = t2._app) || void 0 === e ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Gc2(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function $a2(t2, e) {
  za2(t2 = ma2(t2, Na2));
  const n = Oa2(t2), s = t2._freezeSettings(), i = new $c2();
  return La2(n, i, new Oc2(i, s.cacheSizeBytes, null == e ? void 0 : e.forceOwnership));
}
function Ba2(t2) {
  za2(t2 = ma2(t2, Na2));
  const e = Oa2(t2), n = t2._freezeSettings(), s = new $c2();
  return La2(e, s, new Fc2(s, n.cacheSizeBytes));
}
function La2(t2, e, n) {
  const s = new L2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Qc2(t2, n), await jc2(t2, e), s.resolve();
    } catch (t3) {
      const e2 = t3;
      if (!function(t4) {
        if ("FirebaseError" === t4.name)
          return t4.code === $.FAILED_PRECONDITION || t4.code === $.UNIMPLEMENTED;
        if ("undefined" != typeof DOMException && t4 instanceof DOMException)
          return 22 === t4.code || 20 === t4.code || 11 === t4.code;
        return true;
      }(e2))
        throw e2;
      x2("Error enabling offline persistence. Falling back to persistence disabled: " + e2), s.reject(e2);
    }
  }).then(() => s.promise);
}
function Ua2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new B2($.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new L2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Rt.C())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Rt.delete(e2);
      }(mo(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function qa2(t2) {
  return function(t3) {
    const e = new L2();
    return t3.asyncQueue.enqueueAndForget(async () => fc2(await Xc2(t3), e)), e.promise;
  }(Oa2(t2 = ma2(t2, Na2)));
}
function Ka(t2) {
  return ta2(Oa2(t2 = ma2(t2, Na2)));
}
function Ga(t2) {
  return ea2(Oa2(t2 = ma2(t2, Na2)));
}
function Qa2(t2) {
  return _removeServiceInstance(t2.app, "firestore", t2._databaseId.database), t2._delete();
}
function ja2(t2, e) {
  const n = Oa2(t2 = ma2(t2, Na2)), s = new Ca();
  return ca2(n, t2._databaseId, e, s), s;
}
function Wa2(t2, e) {
  return aa2(Oa2(t2 = ma2(t2, Na2)), e).then((e2) => e2 ? new Ea2(t2, null, e2.query) : null);
}
function za2(t2) {
  if (t2._initialized || t2._terminated)
    throw new B2($.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Ha = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (0 === t2[e].length)
        throw new B2($.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ot(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Ja2() {
  return new Ha("__name__");
}
var Ya2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Ya2(jt.fromBase64String(t2));
    } catch (t3) {
      throw new B2($.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Ya2(jt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Xa2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var Za = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new B2($.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new B2($.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return X2(this._lat, t2._lat) || X2(this._long, t2._long);
  }
};
var th = /^__.*__$/;
var eh = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return null !== this.fieldMask ? new Kn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new qn(t2, this.data, e, this.fieldTransforms);
  }
};
var nh = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new Kn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function sh(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw k2();
  }
}
var ih = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.It = n, this.ignoreUndefinedProperties = s, void 0 === i && this.ea(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get na() {
    return this.settings.na;
  }
  sa(t2) {
    return new ih(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.It, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  ia(t2) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t2), s = this.sa({
      path: n,
      ra: false
    });
    return s.oa(t2), s;
  }
  ua(t2) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t2), s = this.sa({
      path: n,
      ra: false
    });
    return s.ea(), s;
  }
  ca(t2) {
    return this.sa({
      path: void 0,
      ra: true
    });
  }
  aa(t2) {
    return Rh(t2, this.settings.methodName, this.settings.ha || false, this.path, this.settings.la);
  }
  contains(t2) {
    return void 0 !== this.fieldMask.find((e) => t2.isPrefixOf(e)) || void 0 !== this.fieldTransforms.find((e) => t2.isPrefixOf(e.field));
  }
  ea() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.oa(this.path.get(t2));
  }
  oa(t2) {
    if (0 === t2.length)
      throw this.aa("Document fields must not be empty");
    if (sh(this.na) && th.test(t2))
      throw this.aa('Document fields cannot begin and end with "__"');
  }
};
var rh = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.It = n || Xo(t2);
  }
  fa(t2, e, n, s = false) {
    return new ih({
      na: t2,
      methodName: e,
      la: n,
      path: ot.emptyPath(),
      ra: false,
      ha: s
    }, this.databaseId, this.It, this.ignoreUndefinedProperties);
  }
};
function oh(t2) {
  const e = t2._freezeSettings(), n = Xo(t2._databaseId);
  return new rh(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function uh(t2, e, n, s, i, r = {}) {
  const o = t2.fa(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Ih("Data must be an object, but it was:", o, s);
  const u = yh(s, o);
  let c, a;
  if (r.merge)
    c = new Gt(o.fieldMask), a = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = Th(e, s2, n);
      if (!o.contains(i2))
        throw new B2($.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      bh(t3, i2) || t3.push(i2);
    }
    c = new Gt(t3), a = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, a = o.fieldTransforms;
  return new eh(new Pe(u), c, a);
}
var ch = class extends Xa2 {
  _toFieldTransform(t2) {
    if (2 !== t2.na)
      throw 1 === t2.na ? t2.aa(`${this._methodName}() can only appear at the top level of your update data`) : t2.aa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof ch;
  }
};
function ah(t2, e, n) {
  return new ih({
    na: 3,
    la: e.settings.la,
    methodName: t2._methodName,
    ra: n
  }, e.databaseId, e.It, e.ignoreUndefinedProperties);
}
var hh = class extends Xa2 {
  _toFieldTransform(t2) {
    return new Cn(t2.path, new An());
  }
  isEqual(t2) {
    return t2 instanceof hh;
  }
};
var lh = class extends Xa2 {
  constructor(t2, e) {
    super(t2), this.da = e;
  }
  _toFieldTransform(t2) {
    const e = ah(
      this,
      t2,
      true
    ), n = this.da.map((t3) => gh(t3, e)), s = new Rn(n);
    return new Cn(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var fh = class extends Xa2 {
  constructor(t2, e) {
    super(t2), this.da = e;
  }
  _toFieldTransform(t2) {
    const e = ah(
      this,
      t2,
      true
    ), n = this.da.map((t3) => gh(t3, e)), s = new Pn(n);
    return new Cn(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var dh = class extends Xa2 {
  constructor(t2, e) {
    super(t2), this._a = e;
  }
  _toFieldTransform(t2) {
    const e = new Vn(t2.It, yn(t2.It, this._a));
    return new Cn(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function _h(t2, e, n, s) {
  const i = t2.fa(1, e, n);
  Ih("Data must be an object, but it was:", i, s);
  const r = [], o = Pe.empty();
  Ot(s, (t3, s2) => {
    const u2 = Ah(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.ua(u2);
    if (s2 instanceof ch)
      r.push(u2);
    else {
      const t4 = gh(s2, c);
      null != t4 && (r.push(u2), o.set(u2, t4));
    }
  });
  const u = new Gt(r);
  return new nh(o, u, i.fieldTransforms);
}
function wh(t2, e, n, s, i, r) {
  const o = t2.fa(1, e, n), u = [Th(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new B2($.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    u.push(Th(e, r[t3])), c.push(r[t3 + 1]);
  const a = [], h = Pe.empty();
  for (let t3 = u.length - 1; t3 >= 0; --t3)
    if (!bh(a, u[t3])) {
      const e2 = u[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.ua(e2);
      if (n2 instanceof ch)
        a.push(e2);
      else {
        const t4 = gh(n2, s2);
        null != t4 && (a.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new Gt(a);
  return new nh(h, l2, o.fieldTransforms);
}
function mh(t2, e, n, s = false) {
  return gh(n, t2.fa(s ? 4 : 3, e));
}
function gh(t2, e) {
  if (ph(
    t2 = getModularInstance(t2)
  ))
    return Ih("Unsupported field value:", e, t2), yh(t2, e);
  if (t2 instanceof Xa2)
    return function(t3, e2) {
      if (!sh(e2.na))
        throw e2.aa(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.aa(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (void 0 === t2 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.ra && 4 !== e.na)
      throw e.aa("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = gh(i, e2.ca(s));
        null == t4 && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if (null === (t3 = getModularInstance(t3)))
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t3)
      return yn(e2.It, t3);
    if ("boolean" == typeof t3)
      return {
        booleanValue: t3
      };
    if ("string" == typeof t3)
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = et.fromDate(t3);
      return {
        timestampValue: Ps(e2.It, n)
      };
    }
    if (t3 instanceof et) {
      const n = new et(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Ps(e2.It, n)
      };
    }
    if (t3 instanceof Za)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Ya2)
      return {
        bytesValue: vs(e2.It, t3._byteString)
      };
    if (t3 instanceof Ta2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.aa(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: Ds(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.aa(`Unsupported field value: ${wa2(t3)}`);
  }(t2, e);
}
function yh(t2, e) {
  const n = {};
  return Ft(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : Ot(t2, (t3, s) => {
    const i = gh(s, e.ia(t3));
    null != i && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function ph(t2) {
  return !("object" != typeof t2 || null === t2 || t2 instanceof Array || t2 instanceof Date || t2 instanceof et || t2 instanceof Za || t2 instanceof Ya2 || t2 instanceof Ta2 || t2 instanceof Xa2);
}
function Ih(t2, e, n) {
  if (!ph(n) || !function(t3) {
    return "object" == typeof t3 && null !== t3 && (Object.getPrototypeOf(t3) === Object.prototype || null === Object.getPrototypeOf(t3));
  }(n)) {
    const s = wa2(n);
    throw "an object" === s ? e.aa(t2 + " a custom object") : e.aa(t2 + " " + s);
  }
}
function Th(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Ha)
    return e._internalPath;
  if ("string" == typeof e)
    return Ah(t2, e);
  throw Rh(
    "Field path arguments must be of type string or ",
    t2,
    false,
    void 0,
    n
  );
}
var Eh = new RegExp("[~\\*/\\[\\]]");
function Ah(t2, e, n) {
  if (e.search(Eh) >= 0)
    throw Rh(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      t2,
      false,
      void 0,
      n
    );
  try {
    return new Ha(...e.split("."))._internalPath;
  } catch (s) {
    throw Rh(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      t2,
      false,
      void 0,
      n
    );
  }
}
function Rh(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = void 0 !== i;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new B2($.INVALID_ARGUMENT, u + t2 + c);
}
function bh(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var Ph = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Ta2(this._firestore, this._converter, this._key);
  }
  exists() {
    return null !== this._document;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new vh(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          null
        );
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(Vh("DocumentSnapshot.get", t2));
      if (null !== e)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var vh = class extends Ph {
  data() {
    return super.data();
  }
};
function Vh(t2, e) {
  return "string" == typeof e ? Ah(t2, e) : e instanceof Ha ? e._internalPath : e._delegate._internalPath;
}
var Sh = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Dh = class extends Ph {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Ch(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          null
        );
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(Vh("DocumentSnapshot.get", t2));
      if (null !== n)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Ch = class extends Dh {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var xh = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Sh(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return 0 === this.size;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Ch(this._firestore, this._userDataWriter, n.key, n, new Sh(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new B2($.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Ch(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Sh(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || 3 !== t4.type).map((e3) => {
          const s = new Ch(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Sh(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return 0 !== e3.type && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), 1 !== e3.type && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Nh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Nh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return k2();
  }
}
function kh(t2, e) {
  return t2 instanceof Dh && e instanceof Dh ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (null === t2._document ? null === e._document : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof xh && e instanceof xh && (t2._firestore === e._firestore && Va2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Mh(t2) {
  if ("L" === t2.limitType && 0 === t2.explicitOrderBy.length)
    throw new B2($.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Oh = class {
};
function Fh(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var $h = class extends Oh {
  constructor(t2, e, n) {
    super(), this.wa = t2, this.ma = e, this.ga = n, this.type = "where";
  }
  _apply(t2) {
    const e = oh(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let u;
      if (i.isKeyField()) {
        if ("array-contains" === r || "array-contains-any" === r)
          throw new B2($.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if ("in" === r || "not-in" === r) {
          Zh(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Xh(s, t3, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = Xh(s, t3, o);
      } else
        "in" !== r && "not-in" !== r && "array-contains-any" !== r || Zh(o, r), u = mh(
          n2,
          e2,
          o,
          "in" === r || "not-in" === r
        );
      const c = $e.create(i, r, u);
      return function(t4, e3) {
        if (e3.dt()) {
          const n4 = sn(t4);
          if (null !== n4 && !n4.isEqual(e3.field))
            throw new B2($.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = nn(t4);
          null !== s2 && tl(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(
          t4,
          function(t5) {
            switch (t5) {
              case "!=":
                return ["!=", "not-in"];
              case "array-contains":
                return ["array-contains", "array-contains-any", "not-in"];
              case "in":
                return ["array-contains-any", "in", "not-in"];
              case "array-contains-any":
                return ["array-contains", "array-contains-any", "in", "not-in"];
              case "not-in":
                return ["array-contains", "array-contains-any", "in", "not-in", "!="];
              default:
                return [];
            }
          }(e3.op)
        );
        if (null !== n3)
          throw n3 === e3.op ? new B2($.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new B2($.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, c), c;
    }(t2._query, "where", e, t2.firestore._databaseId, this.wa, this.ma, this.ga);
    return new Ea2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new Xe(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Bh(t2, e, n) {
  const s = e, i = Vh("where", t2);
  return new $h(i, s, n);
}
var Lh = class extends Oh {
  constructor(t2, e) {
    super(), this.wa = t2, this.ya = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (null !== t3.startAt)
        throw new B2($.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (null !== t3.endAt)
        throw new B2($.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new ze(e2, n);
      return function(t4, e3) {
        if (null === nn(t4)) {
          const n2 = sn(t4);
          null !== n2 && tl(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.wa, this.ya);
    return new Ea2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new Xe(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Uh(t2, e = "asc") {
  const n = e, s = Vh("orderBy", t2);
  return new Lh(s, n);
}
var qh = class extends Oh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.pa = e, this.Ia = n;
  }
  _apply(t2) {
    return new Ea2(t2.firestore, t2.converter, cn(t2._query, this.pa, this.Ia));
  }
};
function Kh(t2) {
  return ga("limit", t2), new qh("limit", t2, "F");
}
function Gh(t2) {
  return ga("limitToLast", t2), new qh("limitToLast", t2, "L");
}
var Qh = class extends Oh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ta = e, this.Ea = n;
  }
  _apply(t2) {
    const e = Yh(t2, this.type, this.Ta, this.Ea);
    return new Ea2(t2.firestore, t2.converter, function(t3, e2) {
      return new Xe(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function jh(...t2) {
  return new Qh(
    "startAt",
    t2,
    true
  );
}
function Wh(...t2) {
  return new Qh(
    "startAfter",
    t2,
    false
  );
}
var zh = class extends Oh {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ta = e, this.Ea = n;
  }
  _apply(t2) {
    const e = Yh(t2, this.type, this.Ta, this.Ea);
    return new Ea2(t2.firestore, t2.converter, function(t3, e2) {
      return new Xe(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Hh(...t2) {
  return new zh(
    "endBefore",
    t2,
    false
  );
}
function Jh(...t2) {
  return new zh("endAt", t2, true);
}
function Yh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Ph)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new B2($.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of on(t3))
        if (n3.field.isKeyField())
          r.push(_e(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Yt(t4))
            throw new B2($.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (null === t4) {
            const t5 = n3.field.canonicalString();
            throw new B2($.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new We(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = oh(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new B2($.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if ("string" != typeof c)
            throw new B2($.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!rn(t3) && -1 !== c.indexOf("/"))
            throw new B2($.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(it.fromString(c));
          if (!ut.isDocumentKey(n3))
            throw new B2($.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new ut(n3);
          u.push(_e(e2, i3));
        } else {
          const t4 = mh(n2, s2, c);
          u.push(t4);
        }
      }
      return new We(u, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Xh(t2, e, n) {
  if ("string" == typeof (n = getModularInstance(n))) {
    if ("" === n)
      throw new B2($.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!rn(e) && -1 !== n.indexOf("/"))
      throw new B2($.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(it.fromString(n));
    if (!ut.isDocumentKey(s))
      throw new B2($.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return _e(t2, new ut(s));
  }
  if (n instanceof Ta2)
    return _e(t2, n._key);
  throw new B2($.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${wa2(n)}.`);
}
function Zh(t2, e) {
  if (!Array.isArray(t2) || 0 === t2.length)
    throw new B2($.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new B2($.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function tl(t2, e, n) {
  if (!n.isEqual(e))
    throw new B2($.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var el = {
  maxAttempts: 5
};
var nl = class {
  convertValue(t2, e = "none") {
    switch (ue(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Ht(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(Jt(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw k2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return Ot(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new Za(Ht(t2.latitude), Ht(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = Xt(t2);
        return null == n ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Zt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = zt(t2);
    return new et(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = it.fromString(t2);
    M2(si(n));
    const s = new ee(n.get(1), n.get(3)), i = new ut(n.popFirst(5));
    return s.isEqual(e) || C2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function sl(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var il = class extends nl {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Ya2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Ta2(this.firestore, null, e);
  }
};
var rl = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = oh(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = ol(t2, this._firestore), i = sl(s.converter, e, n), r = uh(this._dataReader, "WriteBatch.set", s._key, i, null !== s.converter, n);
    return this._mutations.push(r.toMutation(s._key, kn.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = ol(t2, this._firestore);
    let r;
    return r = "string" == typeof (e = getModularInstance(e)) || e instanceof Ha ? wh(this._dataReader, "WriteBatch.update", i._key, e, n, s) : _h(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, kn.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = ol(t2, this._firestore);
    return this._mutations = this._mutations.concat(new Wn(e._key, kn.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new B2($.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function ol(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new B2($.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function ul(t2) {
  t2 = ma2(t2, Ta2);
  const e = ma2(t2.firestore, Na2);
  return sa2(Oa2(e), t2._key).then((n) => Tl(e, t2, n));
}
var cl = class extends nl {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Ya2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Ta2(this.firestore, null, e);
  }
};
function al(t2) {
  t2 = ma2(t2, Ta2);
  const e = ma2(t2.firestore, Na2), n = Oa2(e), s = new cl(e);
  return na2(n, t2._key).then((n2) => new Dh(e, s, t2._key, n2, new Sh(
    null !== n2 && n2.hasLocalMutations,
    true
  ), t2.converter));
}
function hl(t2) {
  t2 = ma2(t2, Ta2);
  const e = ma2(t2.firestore, Na2);
  return sa2(Oa2(e), t2._key, {
    source: "server"
  }).then((n) => Tl(e, t2, n));
}
function ll(t2) {
  t2 = ma2(t2, Ea2);
  const e = ma2(t2.firestore, Na2), n = Oa2(e), s = new cl(e);
  return Mh(t2._query), ra2(n, t2._query).then((n2) => new xh(e, s, t2, n2));
}
function fl(t2) {
  t2 = ma2(t2, Ea2);
  const e = ma2(t2.firestore, Na2), n = Oa2(e), s = new cl(e);
  return ia2(n, t2._query).then((n2) => new xh(e, s, t2, n2));
}
function dl(t2) {
  t2 = ma2(t2, Ea2);
  const e = ma2(t2.firestore, Na2), n = Oa2(e), s = new cl(e);
  return ra2(n, t2._query, {
    source: "server"
  }).then((n2) => new xh(e, s, t2, n2));
}
function _l(t2, e, n) {
  t2 = ma2(t2, Ta2);
  const s = ma2(t2.firestore, Na2), i = sl(t2.converter, e, n);
  return Il(s, [uh(oh(s), "setDoc", t2._key, i, null !== t2.converter, n).toMutation(t2._key, kn.none())]);
}
function wl(t2, e, n, ...s) {
  t2 = ma2(t2, Ta2);
  const i = ma2(t2.firestore, Na2), r = oh(i);
  let o;
  o = "string" == typeof (e = getModularInstance(e)) || e instanceof Ha ? wh(r, "updateDoc", t2._key, e, n, s) : _h(r, "updateDoc", t2._key, e);
  return Il(i, [o.toMutation(t2._key, kn.exists(true))]);
}
function ml(t2) {
  return Il(ma2(t2.firestore, Na2), [new Wn(t2._key, kn.none())]);
}
function gl(t2, e) {
  const n = ma2(t2.firestore, Na2), s = Pa2(t2), i = sl(t2.converter, e);
  return Il(n, [uh(oh(t2.firestore), "addDoc", s._key, i, null !== t2.converter, {}).toMutation(s._key, kn.exists(false))]).then(() => s);
}
function yl(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  "object" != typeof e[o] || Da(e[o]) || (r = e[o], o++);
  const u = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Da(e[o])) {
    const t3 = e[o];
    e[o] = null === (n = t3.next) || void 0 === n ? void 0 : n.bind(t3), e[o + 1] = null === (s = t3.error) || void 0 === s ? void 0 : s.bind(t3), e[o + 2] = null === (i = t3.complete) || void 0 === i ? void 0 : i.bind(t3);
  }
  let c, a, h;
  if (t2 instanceof Ta2)
    a = ma2(t2.firestore, Na2), h = tn(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](Tl(a, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = ma2(t2, Ea2);
    a = ma2(n2.firestore, Na2), h = n2._query;
    const s2 = new cl(a);
    c = {
      next: (t3) => {
        e[o] && e[o](new xh(a, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Mh(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Lc2(s2), r2 = new ju(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Uu(await Zc2(t3), r2)), () => {
      i2.Rc(), t3.asyncQueue.enqueueAndForget(async () => qu(await Zc2(t3), r2));
    };
  }(Oa2(a), h, u, c);
}
function pl(t2, e) {
  return oa2(Oa2(t2 = ma2(t2, Na2)), Da(e) ? e : {
    next: e
  });
}
function Il(t2, e) {
  return function(t3, e2) {
    const n = new L2();
    return t3.asyncQueue.enqueueAndForget(async () => oc2(await Xc2(t3), e2, n)), n.promise;
  }(Oa2(t2), e);
}
function Tl(t2, e, n) {
  const s = n.docs.get(e._key), i = new cl(t2);
  return new Dh(t2, i, e._key, s, new Sh(n.hasPendingWrites, n.fromCache), e.converter);
}
var El = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = oh(t2);
  }
  get(t2) {
    const e = ol(t2, this._firestore), n = new il(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || 1 !== t3.length)
        return k2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new Ph(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Ph(this._firestore, n, e._key, null, e.converter);
      throw k2();
    });
  }
  set(t2, e, n) {
    const s = ol(t2, this._firestore), i = sl(s.converter, e, n), r = uh(this._dataReader, "Transaction.set", s._key, i, null !== s.converter, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = ol(t2, this._firestore);
    let r;
    return r = "string" == typeof (e = getModularInstance(e)) || e instanceof Ha ? wh(this._dataReader, "Transaction.update", i._key, e, n, s) : _h(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = ol(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = ol(t2, this._firestore), n = new cl(this._firestore);
    return super.get(t2).then((t3) => new Dh(this._firestore, n, e._key, t3._document, new Sh(
      false,
      false
    ), e.converter));
  }
};
function Al(t2, e, n) {
  t2 = ma2(t2, Na2);
  const s = Object.assign(Object.assign({}, el), n);
  !function(t3) {
    if (t3.maxAttempts < 1)
      throw new B2($.INVALID_ARGUMENT, "Max attempts must be at least 1");
  }(s);
  return ua2(Oa2(t2), (n2) => e(new El(t2, n2)), s);
}
function Rl() {
  return new ch("deleteField");
}
function bl() {
  return new hh("serverTimestamp");
}
function Pl(...t2) {
  return new lh("arrayUnion", t2);
}
function vl(...t2) {
  return new fh("arrayRemove", t2);
}
function Vl(t2) {
  return new dh("increment", t2);
}
function Sl(t2) {
  return Oa2(t2 = ma2(t2, Na2)), new rl(t2, (e) => Il(t2, e));
}
function Dl(t2, e) {
  var n;
  const s = Oa2(t2 = ma2(t2, Na2));
  if (!(null === (n = s.offlineComponents) || void 0 === n ? void 0 : n.indexBackfillerScheduler))
    return x2("Cannot enable indexes when persistence is disabled"), Promise.resolve();
  const i = function(t3) {
    const e2 = "string" == typeof t3 ? function(t4) {
      var e3;
      try {
        return JSON.parse(t4);
      } catch (t5) {
        throw new B2($.INVALID_ARGUMENT, "Failed to parse JSON: " + (null === (e3 = t5) || void 0 === e3 ? void 0 : e3.message));
      }
    }(t3) : t3, n2 = [];
    if (Array.isArray(e2.indexes))
      for (const t4 of e2.indexes) {
        const e3 = Cl(t4, "collectionGroup"), s2 = [];
        if (Array.isArray(t4.fields))
          for (const e4 of t4.fields) {
            const t5 = Ah("setIndexConfiguration", Cl(e4, "fieldPath"));
            "CONTAINS" === e4.arrayConfig ? s2.push(new ft(t5, 2)) : "ASCENDING" === e4.order ? s2.push(new ft(t5, 0)) : "DESCENDING" === e4.order && s2.push(new ft(t5, 1));
          }
        n2.push(new ct(ct.UNKNOWN_ID, e3, s2, _t.empty()));
      }
    return n2;
  }(e);
  return Jc2(s).then((t3) => async function(t4, e2) {
    const n2 = F(t4), s2 = n2.indexManager, i2 = [];
    return n2.persistence.runTransaction("Configure indexes", "readwrite", (t5) => s2.getFieldIndexes(t5).next((n3) => function(t6, e3, n4, s3, i3) {
      t6 = [...t6], e3 = [...e3], t6.sort(n4), e3.sort(n4);
      const r = t6.length, o = e3.length;
      let u = 0, c = 0;
      for (; u < o && c < r; ) {
        const r2 = n4(t6[c], e3[u]);
        r2 < 0 ? i3(t6[c++]) : r2 > 0 ? s3(e3[u++]) : (u++, c++);
      }
      for (; u < o; )
        s3(e3[u++]);
      for (; c < r; )
        i3(t6[c++]);
    }(n3, e2, lt, (e3) => {
      i2.push(s2.addFieldIndex(t5, e3));
    }, (e3) => {
      i2.push(s2.deleteFieldIndex(t5, e3));
    })).next(() => Et.waitFor(i2)));
  }(t3, i));
}
function Cl(t2, e) {
  if ("string" != typeof t2[e])
    throw new B2($.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t2[e];
}
!function(t2, e = true) {
  !function(t3) {
    P2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { instanceIdentifier: n, options: s }) => {
    const i = t3.getProvider("app").getImmediate(), r = new Na2(new G2(t3.getProvider("auth-internal")), new z2(t3.getProvider("app-check-internal")), function(t4, e2) {
      if (!Object.prototype.hasOwnProperty.apply(t4.options, ["projectId"]))
        throw new B2($.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new ee(t4.options.projectId, e2);
    }(i, n), i);
    return s = Object.assign({
      useFetchStreams: e
    }, s), r._setSettings(s), r;
  }, "PUBLIC").setMultipleInstances(true)), registerVersion(R2, "3.5.0", t2), registerVersion(R2, "3.5.0", "esm2017");
}();
export {
  nl as AbstractUserDataWriter,
  Ya2 as Bytes,
  xa2 as CACHE_SIZE_UNLIMITED,
  Aa2 as CollectionReference,
  Ta2 as DocumentReference,
  Dh as DocumentSnapshot,
  Ha as FieldPath,
  Xa2 as FieldValue,
  Na2 as Firestore,
  B2 as FirestoreError,
  Za as GeoPoint,
  Ca as LoadBundleTask,
  Ea2 as Query,
  Oh as QueryConstraint,
  Ch as QueryDocumentSnapshot,
  xh as QuerySnapshot,
  Sh as SnapshotMetadata,
  et as Timestamp,
  El as Transaction,
  rl as WriteBatch,
  ee as _DatabaseId,
  ut as _DocumentKey,
  H2 as _EmptyAppCheckTokenProvider,
  q2 as _EmptyAuthCredentialsProvider,
  ot as _FieldPath,
  ma2 as _cast,
  O2 as _debugAssert,
  Qt as _isBase64Available,
  x2 as _logWarn,
  fa2 as _validateIsNotUsedTogether,
  gl as addDoc,
  vl as arrayRemove,
  Pl as arrayUnion,
  Ua2 as clearIndexedDbPersistence,
  Ra2 as collection,
  ba2 as collectionGroup,
  Ia2 as connectFirestoreEmulator,
  ml as deleteDoc,
  Rl as deleteField,
  Ga as disableNetwork,
  Pa2 as doc,
  Ja2 as documentId,
  $a2 as enableIndexedDbPersistence,
  Ba2 as enableMultiTabIndexedDbPersistence,
  Ka as enableNetwork,
  Jh as endAt,
  Hh as endBefore,
  Oa2 as ensureFirestoreConfigured,
  Il as executeWrite,
  ul as getDoc,
  al as getDocFromCache,
  hl as getDocFromServer,
  ll as getDocs,
  fl as getDocsFromCache,
  dl as getDocsFromServer,
  Ma2 as getFirestore,
  Vl as increment,
  ka2 as initializeFirestore,
  Kh as limit,
  Gh as limitToLast,
  ja2 as loadBundle,
  Wa2 as namedQuery,
  yl as onSnapshot,
  pl as onSnapshotsInSync,
  Uh as orderBy,
  Fh as query,
  Va2 as queryEqual,
  va2 as refEqual,
  Al as runTransaction,
  bl as serverTimestamp,
  _l as setDoc,
  Dl as setIndexConfiguration,
  S2 as setLogLevel,
  kh as snapshotEqual,
  Wh as startAfter,
  jh as startAt,
  Qa2 as terminate,
  wl as updateDoc,
  qa2 as waitForPendingWrites,
  Bh as where,
  Sl as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
