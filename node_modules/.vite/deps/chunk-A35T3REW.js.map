{
  "version": 3,
  "sources": ["../../@firebase/component/src/component.ts", "../../@firebase/component/src/constants.ts", "../../@firebase/component/src/provider.ts", "../../@firebase/component/src/component_container.ts", "../../@firebase/logger/src/logger.ts", "../../idb/build/wrap-idb-value.js", "../../idb/build/index.js", "../../@firebase/app/src/platformLoggerService.ts", "../../@firebase/app/src/logger.ts", "../../@firebase/app/src/constants.ts", "../../@firebase/app/src/internal.ts", "../../@firebase/app/src/errors.ts", "../../@firebase/app/src/firebaseApp.ts", "../../@firebase/app/src/api.ts", "../../@firebase/app/src/indexeddb.ts", "../../@firebase/app/src/heartbeatService.ts", "../../@firebase/app/src/registerCoreComponents.ts", "../../@firebase/app/src/index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  InstantiationMode,\n  InstanceFactory,\n  ComponentType,\n  Dictionary,\n  Name,\n  onInstanceCreatedCallback\n} from './types';\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nexport class Component<T extends Name = Name> {\n  multipleInstances = false;\n  /**\n   * Properties to be added to the service namespace\n   */\n  serviceProps: Dictionary = {};\n\n  instantiationMode = InstantiationMode.LAZY;\n\n  onInstanceCreated: onInstanceCreatedCallback<T> | null = null;\n\n  /**\n   *\n   * @param name The public service name, e.g. app, auth, firestore, database\n   * @param instanceFactory Service factory responsible for creating the public interface\n   * @param type whether the service provided by the component is public or private\n   */\n  constructor(\n    readonly name: T,\n    readonly instanceFactory: InstanceFactory<T>,\n    readonly type: ComponentType\n  ) {}\n\n  setInstantiationMode(mode: InstantiationMode): this {\n    this.instantiationMode = mode;\n    return this;\n  }\n\n  setMultipleInstances(multipleInstances: boolean): this {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n\n  setServiceProps(props: Dictionary): this {\n    this.serviceProps = props;\n    return this;\n  }\n\n  setInstanceCreatedCallback(callback: onInstanceCreatedCallback<T>): this {\n    this.onInstanceCreated = callback;\n    return this;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_ENTRY_NAME = '[DEFAULT]';\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Deferred } from '@firebase/util';\nimport { ComponentContainer } from './component_container';\nimport { DEFAULT_ENTRY_NAME } from './constants';\nimport {\n  InitializeOptions,\n  InstantiationMode,\n  Name,\n  NameServiceMapping,\n  OnInitCallBack\n} from './types';\nimport { Component } from './component';\n\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nexport class Provider<T extends Name> {\n  private component: Component<T> | null = null;\n  private readonly instances: Map<string, NameServiceMapping[T]> = new Map();\n  private readonly instancesDeferred: Map<\n    string,\n    Deferred<NameServiceMapping[T]>\n  > = new Map();\n  private readonly instancesOptions: Map<string, Record<string, unknown>> =\n    new Map();\n  private onInitCallbacks: Map<string, Set<OnInitCallBack<T>>> = new Map();\n\n  constructor(\n    private readonly name: T,\n    private readonly container: ComponentContainer\n  ) {}\n\n  /**\n   * @param identifier A provider can provide mulitple instances of a service\n   * if this.component.multipleInstances is true.\n   */\n  get(identifier?: string): Promise<NameServiceMapping[T]> {\n    // if multipleInstances is not supported, use the default name\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      const deferred = new Deferred<NameServiceMapping[T]>();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n\n      if (\n        this.isInitialized(normalizedIdentifier) ||\n        this.shouldAutoInitialize()\n      ) {\n        // initialize the service if it can be auto-initialized\n        try {\n          const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {\n          // when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier)!.promise;\n  }\n\n  /**\n   *\n   * @param options.identifier A provider can provide mulitple instances of a service\n   * if this.component.multipleInstances is true.\n   * @param options.optional If optional is false or not provided, the method throws an error when\n   * the service is not immediately available.\n   * If optional is true, the method returns null if the service is not immediately available.\n   */\n  getImmediate(options: {\n    identifier?: string;\n    optional: true;\n  }): NameServiceMapping[T] | null;\n  getImmediate(options?: {\n    identifier?: string;\n    optional?: false;\n  }): NameServiceMapping[T];\n  getImmediate(options?: {\n    identifier?: string;\n    optional?: boolean;\n  }): NameServiceMapping[T] | null {\n    // if multipleInstances is not supported, use the default name\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(\n      options?.identifier\n    );\n    const optional = options?.optional ?? false;\n\n    if (\n      this.isInitialized(normalizedIdentifier) ||\n      this.shouldAutoInitialize()\n    ) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available`);\n      }\n    }\n  }\n\n  getComponent(): Component<T> | null {\n    return this.component;\n  }\n\n  setComponent(component: Component<T>): void {\n    if (component.name !== this.name) {\n      throw Error(\n        `Mismatching Component ${component.name} for Provider ${this.name}.`\n      );\n    }\n\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n\n    this.component = component;\n\n    // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n    if (!this.shouldAutoInitialize()) {\n      return;\n    }\n\n    // if the service is eager, initialize the default instance\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n      } catch (e) {\n        // when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    }\n\n    // Create service instances for the pending promises and resolve them\n    // NOTE: if this.multipleInstances is false, only the default instance will be created\n    // and all promises with resolve with it regardless of the identifier.\n    for (const [\n      instanceIdentifier,\n      instanceDeferred\n    ] of this.instancesDeferred.entries()) {\n      const normalizedIdentifier =\n        this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      try {\n        // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n        const instance = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        })!;\n        instanceDeferred.resolve(instance);\n      } catch (e) {\n        // when the instance factory throws an exception, it should not cause\n        // a fatal error. We just leave the promise unresolved.\n      }\n    }\n  }\n\n  clearInstance(identifier: string = DEFAULT_ENTRY_NAME): void {\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  }\n\n  // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n  async delete(): Promise<void> {\n    const services = Array.from(this.instances.values());\n\n    await Promise.all([\n      ...services\n        .filter(service => 'INTERNAL' in service) // legacy services\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        .map(service => (service as any).INTERNAL!.delete()),\n      ...services\n        .filter(service => '_delete' in service) // modularized services\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        .map(service => (service as any)._delete())\n    ]);\n  }\n\n  isComponentSet(): boolean {\n    return this.component != null;\n  }\n\n  isInitialized(identifier: string = DEFAULT_ENTRY_NAME): boolean {\n    return this.instances.has(identifier);\n  }\n\n  getOptions(identifier: string = DEFAULT_ENTRY_NAME): Record<string, unknown> {\n    return this.instancesOptions.get(identifier) || {};\n  }\n\n  initialize(opts: InitializeOptions = {}): NameServiceMapping[T] {\n    const { options = {} } = opts;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(\n      opts.instanceIdentifier\n    );\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(\n        `${this.name}(${normalizedIdentifier}) has already been initialized`\n      );\n    }\n\n    if (!this.isComponentSet()) {\n      throw Error(`Component ${this.name} has not been registered yet`);\n    }\n\n    const instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options\n    })!;\n\n    // resolve any pending promise waiting for the service instance\n    for (const [\n      instanceIdentifier,\n      instanceDeferred\n    ] of this.instancesDeferred.entries()) {\n      const normalizedDeferredIdentifier =\n        this.normalizeInstanceIdentifier(instanceIdentifier);\n      if (normalizedIdentifier === normalizedDeferredIdentifier) {\n        instanceDeferred.resolve(instance);\n      }\n    }\n\n    return instance;\n  }\n\n  /**\n   *\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n   *\n   * @param identifier An optional instance identifier\n   * @returns a function to unregister the callback\n   */\n  onInit(callback: OnInitCallBack<T>, identifier?: string): () => void {\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    const existingCallbacks =\n      this.onInitCallbacks.get(normalizedIdentifier) ??\n      new Set<OnInitCallBack<T>>();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n\n    const existingInstance = this.instances.get(normalizedIdentifier);\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n\n    return () => {\n      existingCallbacks.delete(callback);\n    };\n  }\n\n  /**\n   * Invoke onInit callbacks synchronously\n   * @param instance the service instance`\n   */\n  private invokeOnInitCallbacks(\n    instance: NameServiceMapping[T],\n    identifier: string\n  ): void {\n    const callbacks = this.onInitCallbacks.get(identifier);\n    if (!callbacks) {\n      return;\n    }\n    for (const callback of callbacks) {\n      try {\n        callback(instance, identifier);\n      } catch {\n        // ignore errors in the onInit callback\n      }\n    }\n  }\n\n  private getOrInitializeService({\n    instanceIdentifier,\n    options = {}\n  }: {\n    instanceIdentifier: string;\n    options?: Record<string, unknown>;\n  }): NameServiceMapping[T] | null {\n    let instance = this.instances.get(instanceIdentifier);\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n\n      /**\n       * Invoke onInit listeners.\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\n       * while onInit listeners are registered by consumers of the provider.\n       */\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n\n      /**\n       * Order is important\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n       * makes `isInitialized()` return true.\n       */\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(\n            this.container,\n            instanceIdentifier,\n            instance\n          );\n        } catch {\n          // ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n\n    return instance || null;\n  }\n\n  private normalizeInstanceIdentifier(\n    identifier: string = DEFAULT_ENTRY_NAME\n  ): string {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  }\n\n  private shouldAutoInitialize(): boolean {\n    return (\n      !!this.component &&\n      this.component.instantiationMode !== InstantiationMode.EXPLICIT\n    );\n  }\n}\n\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier: string): string | undefined {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager<T extends Name>(component: Component<T>): boolean {\n  return component.instantiationMode === InstantiationMode.EAGER;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Provider } from './provider';\nimport { Component } from './component';\nimport { Name } from './types';\n\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nexport class ComponentContainer {\n  private readonly providers = new Map<string, Provider<Name>>();\n\n  constructor(private readonly name: string) {}\n\n  /**\n   *\n   * @param component Component being added\n   * @param overwrite When a component with the same name has already been registered,\n   * if overwrite is true: overwrite the existing component with the new component and create a new\n   * provider with the new component. It can be useful in tests where you want to use different mocks\n   * for different tests.\n   * if overwrite is false: throw an exception\n   */\n  addComponent<T extends Name>(component: Component<T>): void {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      throw new Error(\n        `Component ${component.name} has already been registered with ${this.name}`\n      );\n    }\n\n    provider.setComponent(component);\n  }\n\n  addOrOverwriteComponent<T extends Name>(component: Component<T>): void {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  }\n\n  /**\n   * getProvider provides a type safe interface where it can only be called with a field name\n   * present in NameServiceMapping interface.\n   *\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\n   * themselves.\n   */\n  getProvider<T extends Name>(name: T): Provider<T> {\n    if (this.providers.has(name)) {\n      return this.providers.get(name) as unknown as Provider<T>;\n    }\n\n    // create a Provider for a service that hasn't registered with Firebase\n    const provider = new Provider<T>(name, this);\n    this.providers.set(name, provider as unknown as Provider<Name>);\n\n    return provider as Provider<T>;\n  }\n\n  getProviders(): Array<Provider<Name>> {\n    return Array.from(this.providers.values());\n  }\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type LogLevelString =\n  | 'debug'\n  | 'verbose'\n  | 'info'\n  | 'warn'\n  | 'error'\n  | 'silent';\n\nexport interface LogOptions {\n  level: LogLevelString;\n}\n\nexport type LogCallback = (callbackParams: LogCallbackParams) => void;\n\nexport interface LogCallbackParams {\n  level: LogLevelString;\n  message: string;\n  args: unknown[];\n  type: string;\n}\n\n/**\n * A container for all of the Logger instances\n */\nexport const instances: Logger[] = [];\n\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nexport enum LogLevel {\n  DEBUG,\n  VERBOSE,\n  INFO,\n  WARN,\n  ERROR,\n  SILENT\n}\n\nconst levelStringToEnum: { [key in LogLevelString]: LogLevel } = {\n  'debug': LogLevel.DEBUG,\n  'verbose': LogLevel.VERBOSE,\n  'info': LogLevel.INFO,\n  'warn': LogLevel.WARN,\n  'error': LogLevel.ERROR,\n  'silent': LogLevel.SILENT\n};\n\n/**\n * The default log level\n */\nconst defaultLogLevel: LogLevel = LogLevel.INFO;\n\n/**\n * We allow users the ability to pass their own log handler. We will pass the\n * type of log, the current log level, and any other arguments passed (i.e. the\n * messages that the user wants to log) to this function.\n */\nexport type LogHandler = (\n  loggerInstance: Logger,\n  logType: LogLevel,\n  ...args: unknown[]\n) => void;\n\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n  [LogLevel.DEBUG]: 'log',\n  [LogLevel.VERBOSE]: 'log',\n  [LogLevel.INFO]: 'info',\n  [LogLevel.WARN]: 'warn',\n  [LogLevel.ERROR]: 'error'\n};\n\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler: LogHandler = (instance, logType, ...args): void => {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  const now = new Date().toISOString();\n  const method = ConsoleMethod[logType as keyof typeof ConsoleMethod];\n  if (method) {\n    console[method as 'log' | 'info' | 'warn' | 'error'](\n      `[${now}]  ${instance.name}:`,\n      ...args\n    );\n  } else {\n    throw new Error(\n      `Attempted to log a message with an invalid logType (value: ${logType})`\n    );\n  }\n};\n\nexport class Logger {\n  /**\n   * Gives you an instance of a Logger to capture messages according to\n   * Firebase's logging scheme.\n   *\n   * @param name The name that the logs will be associated with\n   */\n  constructor(public name: string) {\n    /**\n     * Capture the current instance for later use\n     */\n    instances.push(this);\n  }\n\n  /**\n   * The log level of the given Logger instance.\n   */\n  private _logLevel = defaultLogLevel;\n\n  get logLevel(): LogLevel {\n    return this._logLevel;\n  }\n\n  set logLevel(val: LogLevel) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n\n  // Workaround for setter/getter having to be the same type.\n  setLogLevel(val: LogLevel | LogLevelString): void {\n    this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n  }\n\n  /**\n   * The main (internal) log handler for the Logger instance.\n   * Can be set to a new function in internal package code but not by user.\n   */\n  private _logHandler: LogHandler = defaultLogHandler;\n  get logHandler(): LogHandler {\n    return this._logHandler;\n  }\n  set logHandler(val: LogHandler) {\n    if (typeof val !== 'function') {\n      throw new TypeError('Value assigned to `logHandler` must be a function');\n    }\n    this._logHandler = val;\n  }\n\n  /**\n   * The optional, additional, user-defined log handler for the Logger instance.\n   */\n  private _userLogHandler: LogHandler | null = null;\n  get userLogHandler(): LogHandler | null {\n    return this._userLogHandler;\n  }\n  set userLogHandler(val: LogHandler | null) {\n    this._userLogHandler = val;\n  }\n\n  /**\n   * The functions below are all based on the `console` interface\n   */\n\n  debug(...args: unknown[]): void {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n    this._logHandler(this, LogLevel.DEBUG, ...args);\n  }\n  log(...args: unknown[]): void {\n    this._userLogHandler &&\n      this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n    this._logHandler(this, LogLevel.VERBOSE, ...args);\n  }\n  info(...args: unknown[]): void {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n    this._logHandler(this, LogLevel.INFO, ...args);\n  }\n  warn(...args: unknown[]): void {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n    this._logHandler(this, LogLevel.WARN, ...args);\n  }\n  error(...args: unknown[]): void {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n    this._logHandler(this, LogLevel.ERROR, ...args);\n  }\n}\n\nexport function setLogLevel(level: LogLevelString | LogLevel): void {\n  instances.forEach(inst => {\n    inst.setLogLevel(level);\n  });\n}\n\nexport function setUserLogHandler(\n  logCallback: LogCallback | null,\n  options?: LogOptions\n): void {\n  for (const instance of instances) {\n    let customLogLevel: LogLevel | null = null;\n    if (options && options.level) {\n      customLogLevel = levelStringToEnum[options.level];\n    }\n    if (logCallback === null) {\n      instance.userLogHandler = null;\n    } else {\n      instance.userLogHandler = (\n        instance: Logger,\n        level: LogLevel,\n        ...args: unknown[]\n      ) => {\n        const message = args\n          .map(arg => {\n            if (arg == null) {\n              return null;\n            } else if (typeof arg === 'string') {\n              return arg;\n            } else if (typeof arg === 'number' || typeof arg === 'boolean') {\n              return arg.toString();\n            } else if (arg instanceof Error) {\n              return arg.message;\n            } else {\n              try {\n                return JSON.stringify(arg);\n              } catch (ignored) {\n                return null;\n              }\n            }\n          })\n          .filter(arg => arg)\n          .join(' ');\n        if (level >= (customLogLevel ?? instance.logLevel)) {\n          logCallback({\n            level: LogLevel[level].toLowerCase() as LogLevelString,\n            message,\n            args,\n            type: instance.name\n          });\n        }\n      };\n    }\n  }\n}\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ComponentContainer,\n  ComponentType,\n  Provider,\n  Name\n} from '@firebase/component';\nimport { PlatformLoggerService, VersionService } from './types';\n\nexport class PlatformLoggerServiceImpl implements PlatformLoggerService {\n  constructor(private readonly container: ComponentContainer) {}\n  // In initial implementation, this will be called by installations on\n  // auth token refresh, and installations will send this string.\n  getPlatformInfoString(): string {\n    const providers = this.container.getProviders();\n    // Loop through providers and get library/version pairs from any that are\n    // version components.\n    return providers\n      .map(provider => {\n        if (isVersionServiceProvider(provider)) {\n          const service = provider.getImmediate() as VersionService;\n          return `${service.library}/${service.version}`;\n        } else {\n          return null;\n        }\n      })\n      .filter(logString => logString)\n      .join(' ');\n  }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider: Provider<Name>): boolean {\n  const component = provider.getComponent();\n  return component?.type === ComponentType.VERSION;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@firebase/logger';\n\nexport const logger = new Logger('@firebase/app');\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { name as appName } from '../package.json';\nimport { name as appCompatName } from '../../app-compat/package.json';\nimport { name as analyticsCompatName } from '../../../packages/analytics-compat/package.json';\nimport { name as analyticsName } from '../../../packages/analytics/package.json';\nimport { name as appCheckCompatName } from '../../../packages/app-check-compat/package.json';\nimport { name as appCheckName } from '../../../packages/app-check/package.json';\nimport { name as authName } from '../../../packages/auth/package.json';\nimport { name as authCompatName } from '../../../packages/auth-compat/package.json';\nimport { name as databaseName } from '../../../packages/database/package.json';\nimport { name as databaseCompatName } from '../../../packages/database-compat/package.json';\nimport { name as functionsName } from '../../../packages/functions/package.json';\nimport { name as functionsCompatName } from '../../../packages/functions-compat/package.json';\nimport { name as installationsName } from '../../../packages/installations/package.json';\nimport { name as installationsCompatName } from '../../../packages/installations-compat/package.json';\nimport { name as messagingName } from '../../../packages/messaging/package.json';\nimport { name as messagingCompatName } from '../../../packages/messaging-compat/package.json';\nimport { name as performanceName } from '../../../packages/performance/package.json';\nimport { name as performanceCompatName } from '../../../packages/performance-compat/package.json';\nimport { name as remoteConfigName } from '../../../packages/remote-config/package.json';\nimport { name as remoteConfigCompatName } from '../../../packages/remote-config-compat/package.json';\nimport { name as storageName } from '../../../packages/storage/package.json';\nimport { name as storageCompatName } from '../../../packages/storage-compat/package.json';\nimport { name as firestoreName } from '../../../packages/firestore/package.json';\nimport { name as firestoreCompatName } from '../../../packages/firestore-compat/package.json';\nimport { name as packageName } from '../../../packages/firebase/package.json';\n\n/**\n * The default app name\n *\n * @internal\n */\nexport const DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\nexport const PLATFORM_LOG_STRING = {\n  [appName]: 'fire-core',\n  [appCompatName]: 'fire-core-compat',\n  [analyticsName]: 'fire-analytics',\n  [analyticsCompatName]: 'fire-analytics-compat',\n  [appCheckName]: 'fire-app-check',\n  [appCheckCompatName]: 'fire-app-check-compat',\n  [authName]: 'fire-auth',\n  [authCompatName]: 'fire-auth-compat',\n  [databaseName]: 'fire-rtdb',\n  [databaseCompatName]: 'fire-rtdb-compat',\n  [functionsName]: 'fire-fn',\n  [functionsCompatName]: 'fire-fn-compat',\n  [installationsName]: 'fire-iid',\n  [installationsCompatName]: 'fire-iid-compat',\n  [messagingName]: 'fire-fcm',\n  [messagingCompatName]: 'fire-fcm-compat',\n  [performanceName]: 'fire-perf',\n  [performanceCompatName]: 'fire-perf-compat',\n  [remoteConfigName]: 'fire-rc',\n  [remoteConfigCompatName]: 'fire-rc-compat',\n  [storageName]: 'fire-gcs',\n  [storageCompatName]: 'fire-gcs-compat',\n  [firestoreName]: 'fire-fst',\n  [firestoreCompatName]: 'fire-fst-compat',\n  'fire-js': 'fire-js', // Platform identifier for JS SDK.\n  [packageName]: 'fire-js-all'\n} as const;\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from './public-types';\nimport { Component, Provider, Name } from '@firebase/component';\nimport { logger } from './logger';\nimport { DEFAULT_ENTRY_NAME } from './constants';\nimport { FirebaseAppImpl } from './firebaseApp';\n\n/**\n * @internal\n */\nexport const _apps = new Map<string, FirebaseApp>();\n\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const _components = new Map<string, Component<any>>();\n\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nexport function _addComponent<T extends Name>(\n  app: FirebaseApp,\n  component: Component<T>\n): void {\n  try {\n    (app as FirebaseAppImpl).container.addComponent(component);\n  } catch (e) {\n    logger.debug(\n      `Component ${component.name} failed to register with FirebaseApp ${app.name}`,\n      e\n    );\n  }\n}\n\n/**\n *\n * @internal\n */\nexport function _addOrOverwriteComponent(\n  app: FirebaseApp,\n  component: Component\n): void {\n  (app as FirebaseAppImpl).container.addOrOverwriteComponent(component);\n}\n\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nexport function _registerComponent<T extends Name>(\n  component: Component<T>\n): boolean {\n  const componentName = component.name;\n  if (_components.has(componentName)) {\n    logger.debug(\n      `There were multiple attempts to register component ${componentName}.`\n    );\n\n    return false;\n  }\n\n  _components.set(componentName, component);\n\n  // add the component to existing app instances\n  for (const app of _apps.values()) {\n    _addComponent(app as FirebaseAppImpl, component);\n  }\n\n  return true;\n}\n\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nexport function _getProvider<T extends Name>(\n  app: FirebaseApp,\n  name: T\n): Provider<T> {\n  const heartbeatController = (app as FirebaseAppImpl).container\n    .getProvider('heartbeat')\n    .getImmediate({ optional: true });\n  if (heartbeatController) {\n    void heartbeatController.triggerHeartbeat();\n  }\n  return (app as FirebaseAppImpl).container.getProvider(name);\n}\n\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nexport function _removeServiceInstance<T extends Name>(\n  app: FirebaseApp,\n  name: T,\n  instanceIdentifier: string = DEFAULT_ENTRY_NAME\n): void {\n  _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n\n/**\n * Test only\n *\n * @internal\n */\nexport function _clearComponents(): void {\n  _components.clear();\n}\n\n/**\n * Exported in order to be used in app-compat package\n */\nexport { DEFAULT_ENTRY_NAME as _DEFAULT_ENTRY_NAME };\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AppError {\n  NO_APP = 'no-app',\n  BAD_APP_NAME = 'bad-app-name',\n  DUPLICATE_APP = 'duplicate-app',\n  APP_DELETED = 'app-deleted',\n  INVALID_APP_ARGUMENT = 'invalid-app-argument',\n  INVALID_LOG_ARGUMENT = 'invalid-log-argument',\n  IDB_OPEN = 'idb-open',\n  IDB_GET = 'idb-get',\n  IDB_WRITE = 'idb-set',\n  IDB_DELETE = 'idb-delete'\n}\n\nconst ERRORS: ErrorMap<AppError> = {\n  [AppError.NO_APP]:\n    \"No Firebase App '{$appName}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  [AppError.BAD_APP_NAME]: \"Illegal App name: '{$appName}\",\n  [AppError.DUPLICATE_APP]:\n    \"Firebase App named '{$appName}' already exists with different options or config\",\n  [AppError.APP_DELETED]: \"Firebase App named '{$appName}' already deleted\",\n  [AppError.INVALID_APP_ARGUMENT]:\n    'firebase.{$appName}() takes either no argument or a ' +\n    'Firebase App instance.',\n  [AppError.INVALID_LOG_ARGUMENT]:\n    'First argument to `onLog` must be null or a function.',\n  [AppError.IDB_OPEN]:\n    'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n  [AppError.IDB_GET]:\n    'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n  [AppError.IDB_WRITE]:\n    'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n  [AppError.IDB_DELETE]:\n    'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'\n};\n\ninterface ErrorParams {\n  [AppError.NO_APP]: { appName: string };\n  [AppError.BAD_APP_NAME]: { appName: string };\n  [AppError.DUPLICATE_APP]: { appName: string };\n  [AppError.APP_DELETED]: { appName: string };\n  [AppError.INVALID_APP_ARGUMENT]: { appName: string };\n  [AppError.IDB_OPEN]: { originalErrorMessage?: string };\n  [AppError.IDB_GET]: { originalErrorMessage?: string };\n  [AppError.IDB_WRITE]: { originalErrorMessage?: string };\n  [AppError.IDB_DELETE]: { originalErrorMessage?: string };\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<AppError, ErrorParams>(\n  'app',\n  'Firebase',\n  ERRORS\n);\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  FirebaseOptions,\n  FirebaseAppSettings\n} from './public-types';\nimport {\n  ComponentContainer,\n  Component,\n  ComponentType\n} from '@firebase/component';\nimport { ERROR_FACTORY, AppError } from './errors';\n\nexport class FirebaseAppImpl implements FirebaseApp {\n  private readonly _options: FirebaseOptions;\n  private readonly _name: string;\n  /**\n   * Original config values passed in as a constructor parameter.\n   * It is only used to compare with another config object to support idempotent initializeApp().\n   *\n   * Updating automaticDataCollectionEnabled on the App instance will not change its value in _config.\n   */\n  private readonly _config: Required<FirebaseAppSettings>;\n  private _automaticDataCollectionEnabled: boolean;\n  private _isDeleted = false;\n  private readonly _container: ComponentContainer;\n\n  constructor(\n    options: FirebaseOptions,\n    config: Required<FirebaseAppSettings>,\n    container: ComponentContainer\n  ) {\n    this._options = { ...options };\n    this._config = { ...config };\n    this._name = config.name;\n    this._automaticDataCollectionEnabled =\n      config.automaticDataCollectionEnabled;\n    this._container = container;\n    this.container.addComponent(\n      new Component('app', () => this, ComponentType.PUBLIC)\n    );\n  }\n\n  get automaticDataCollectionEnabled(): boolean {\n    this.checkDestroyed();\n    return this._automaticDataCollectionEnabled;\n  }\n\n  set automaticDataCollectionEnabled(val: boolean) {\n    this.checkDestroyed();\n    this._automaticDataCollectionEnabled = val;\n  }\n\n  get name(): string {\n    this.checkDestroyed();\n    return this._name;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed();\n    return this._options;\n  }\n\n  get config(): Required<FirebaseAppSettings> {\n    this.checkDestroyed();\n    return this._config;\n  }\n\n  get container(): ComponentContainer {\n    return this._container;\n  }\n\n  get isDeleted(): boolean {\n    return this._isDeleted;\n  }\n\n  set isDeleted(val: boolean) {\n    this._isDeleted = val;\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed(): void {\n    if (this.isDeleted) {\n      throw ERROR_FACTORY.create(AppError.APP_DELETED, { appName: this._name });\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  FirebaseOptions,\n  FirebaseAppSettings\n} from './public-types';\nimport { DEFAULT_ENTRY_NAME, PLATFORM_LOG_STRING } from './constants';\nimport { ERROR_FACTORY, AppError } from './errors';\nimport {\n  ComponentContainer,\n  Component,\n  Name,\n  ComponentType\n} from '@firebase/component';\nimport { version } from '../../firebase/package.json';\nimport { FirebaseAppImpl } from './firebaseApp';\nimport { _apps, _components, _registerComponent } from './internal';\nimport { logger } from './logger';\nimport {\n  LogLevelString,\n  setLogLevel as setLogLevelImpl,\n  LogCallback,\n  LogOptions,\n  setUserLogHandler\n} from '@firebase/logger';\nimport { deepEqual } from '@firebase/util';\n\nexport { FirebaseError } from '@firebase/util';\n\n/**\n * The current SDK version.\n *\n * @public\n */\nexport const SDK_VERSION = version;\n\n/**\n * Creates and initializes a {@link @firebase/app#FirebaseApp} instance.\n *\n * See\n * {@link\n *   https://firebase.google.com/docs/web/setup#add_firebase_to_your_app\n *   | Add Firebase to your app} and\n * {@link\n *   https://firebase.google.com/docs/web/setup#multiple-projects\n *   | Initialize multiple projects} for detailed documentation.\n *\n * @example\n * ```javascript\n *\n * // Initialize default app\n * // Retrieve your own options values by adding a web app on\n * // https://console.firebase.google.com\n * initializeApp({\n *   apiKey: \"AIza....\",                             // Auth / General Use\n *   authDomain: \"YOUR_APP.firebaseapp.com\",         // Auth with popup/redirect\n *   databaseURL: \"https://YOUR_APP.firebaseio.com\", // Realtime Database\n *   storageBucket: \"YOUR_APP.appspot.com\",          // Storage\n *   messagingSenderId: \"123456789\"                  // Cloud Messaging\n * });\n * ```\n *\n * @example\n * ```javascript\n *\n * // Initialize another app\n * const otherApp = initializeApp({\n *   databaseURL: \"https://<OTHER_DATABASE_NAME>.firebaseio.com\",\n *   storageBucket: \"<OTHER_STORAGE_BUCKET>.appspot.com\"\n * }, \"otherApp\");\n * ```\n *\n * @param options - Options to configure the app's services.\n * @param name - Optional name of the app to initialize. If no name\n *   is provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The initialized app.\n *\n * @public\n */\nexport function initializeApp(\n  options: FirebaseOptions,\n  name?: string\n): FirebaseApp;\n/**\n * Creates and initializes a FirebaseApp instance.\n *\n * @param options - Options to configure the app's services.\n * @param config - FirebaseApp Configuration\n *\n * @public\n */\nexport function initializeApp(\n  options: FirebaseOptions,\n  config?: FirebaseAppSettings\n): FirebaseApp;\nexport function initializeApp(\n  options: FirebaseOptions,\n  rawConfig = {}\n): FirebaseApp {\n  if (typeof rawConfig !== 'object') {\n    const name = rawConfig;\n    rawConfig = { name };\n  }\n\n  const config: Required<FirebaseAppSettings> = {\n    name: DEFAULT_ENTRY_NAME,\n    automaticDataCollectionEnabled: false,\n    ...rawConfig\n  };\n  const name = config.name;\n\n  if (typeof name !== 'string' || !name) {\n    throw ERROR_FACTORY.create(AppError.BAD_APP_NAME, {\n      appName: String(name)\n    });\n  }\n\n  const existingApp = _apps.get(name) as FirebaseAppImpl;\n  if (existingApp) {\n    // return the existing app if options and config deep equal the ones in the existing app.\n    if (\n      deepEqual(options, existingApp.options) &&\n      deepEqual(config, existingApp.config)\n    ) {\n      return existingApp;\n    } else {\n      throw ERROR_FACTORY.create(AppError.DUPLICATE_APP, { appName: name });\n    }\n  }\n\n  const container = new ComponentContainer(name);\n  for (const component of _components.values()) {\n    container.addComponent(component);\n  }\n\n  const newApp = new FirebaseAppImpl(options, config, container);\n\n  _apps.set(name, newApp);\n\n  return newApp;\n}\n\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nexport function getApp(name: string = DEFAULT_ENTRY_NAME): FirebaseApp {\n  const app = _apps.get(name);\n  if (!app) {\n    throw ERROR_FACTORY.create(AppError.NO_APP, { appName: name });\n  }\n\n  return app;\n}\n\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nexport function getApps(): FirebaseApp[] {\n  return Array.from(_apps.values());\n}\n\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nexport async function deleteApp(app: FirebaseApp): Promise<void> {\n  const name = app.name;\n  if (_apps.has(name)) {\n    _apps.delete(name);\n    await Promise.all(\n      (app as FirebaseAppImpl).container\n        .getProviders()\n        .map(provider => provider.delete())\n    );\n    (app as FirebaseAppImpl).isDeleted = true;\n  }\n}\n\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nexport function registerVersion(\n  libraryKeyOrName: string,\n  version: string,\n  variant?: string\n): void {\n  // TODO: We can use this check to whitelist strings when/if we set up\n  // a good whitelist system.\n  let library = PLATFORM_LOG_STRING[libraryKeyOrName] ?? libraryKeyOrName;\n  if (variant) {\n    library += `-${variant}`;\n  }\n  const libraryMismatch = library.match(/\\s|\\//);\n  const versionMismatch = version.match(/\\s|\\//);\n  if (libraryMismatch || versionMismatch) {\n    const warning = [\n      `Unable to register library \"${library}\" with version \"${version}\":`\n    ];\n    if (libraryMismatch) {\n      warning.push(\n        `library name \"${library}\" contains illegal characters (whitespace or \"/\")`\n      );\n    }\n    if (libraryMismatch && versionMismatch) {\n      warning.push('and');\n    }\n    if (versionMismatch) {\n      warning.push(\n        `version name \"${version}\" contains illegal characters (whitespace or \"/\")`\n      );\n    }\n    logger.warn(warning.join(' '));\n    return;\n  }\n  _registerComponent(\n    new Component(\n      `${library}-version` as Name,\n      () => ({ library, version }),\n      ComponentType.VERSION\n    )\n  );\n}\n\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nexport function onLog(\n  logCallback: LogCallback | null,\n  options?: LogOptions\n): void {\n  if (logCallback !== null && typeof logCallback !== 'function') {\n    throw ERROR_FACTORY.create(AppError.INVALID_LOG_ARGUMENT);\n  }\n  setUserLogHandler(logCallback, options);\n}\n\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nexport function setLogLevel(logLevel: LogLevelString): void {\n  setLogLevelImpl(logLevel);\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { DBSchema, openDB, IDBPDatabase } from 'idb';\nimport { AppError, ERROR_FACTORY } from './errors';\nimport { FirebaseApp } from './public-types';\nimport { HeartbeatsInIndexedDB } from './types';\nimport { logger } from './logger';\n\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\n\ninterface AppDB extends DBSchema {\n  'firebase-heartbeat-store': {\n    key: string;\n    value: HeartbeatsInIndexedDB;\n  };\n}\n\nlet dbPromise: Promise<IDBPDatabase<AppDB>> | null = null;\nfunction getDbPromise(): Promise<IDBPDatabase<AppDB>> {\n  if (!dbPromise) {\n    dbPromise = openDB<AppDB>(DB_NAME, DB_VERSION, {\n      upgrade: (db, oldVersion) => {\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME);\n        }\n      }\n    }).catch(e => {\n      throw ERROR_FACTORY.create(AppError.IDB_OPEN, {\n        originalErrorMessage: e.message\n      });\n    });\n  }\n  return dbPromise;\n}\n\nexport async function readHeartbeatsFromIndexedDB(\n  app: FirebaseApp\n): Promise<HeartbeatsInIndexedDB | undefined> {\n  try {\n    const db = await getDbPromise();\n    return db\n      .transaction(STORE_NAME)\n      .objectStore(STORE_NAME)\n      .get(computeKey(app)) as Promise<HeartbeatsInIndexedDB | undefined>;\n  } catch (e) {\n    if (e instanceof FirebaseError) {\n      logger.warn(e.message);\n    } else {\n      const idbGetError = ERROR_FACTORY.create(AppError.IDB_GET, {\n        originalErrorMessage: (e as Error)?.message\n      });\n      logger.warn(idbGetError.message);\n    }\n  }\n}\n\nexport async function writeHeartbeatsToIndexedDB(\n  app: FirebaseApp,\n  heartbeatObject: HeartbeatsInIndexedDB\n): Promise<void> {\n  try {\n    const db = await getDbPromise();\n    const tx = db.transaction(STORE_NAME, 'readwrite');\n    const objectStore = tx.objectStore(STORE_NAME);\n    await objectStore.put(heartbeatObject, computeKey(app));\n    return tx.done;\n  } catch (e) {\n    if (e instanceof FirebaseError) {\n      logger.warn(e.message);\n    } else {\n      const idbGetError = ERROR_FACTORY.create(AppError.IDB_WRITE, {\n        originalErrorMessage: (e as Error)?.message\n      });\n      logger.warn(idbGetError.message);\n    }\n  }\n}\n\nfunction computeKey(app: FirebaseApp): string {\n  return `${app.name}!${app.options.appId}`;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ComponentContainer } from '@firebase/component';\nimport {\n  base64urlEncodeWithoutPadding,\n  isIndexedDBAvailable,\n  validateIndexedDBOpenable\n} from '@firebase/util';\nimport {\n  readHeartbeatsFromIndexedDB,\n  writeHeartbeatsToIndexedDB\n} from './indexeddb';\nimport { FirebaseApp } from './public-types';\nimport {\n  HeartbeatsByUserAgent,\n  HeartbeatService,\n  HeartbeatsInIndexedDB,\n  HeartbeatStorage,\n  SingleDateHeartbeat\n} from './types';\n\nconst MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\n\nexport class HeartbeatServiceImpl implements HeartbeatService {\n  /**\n   * The persistence layer for heartbeats\n   * Leave public for easier testing.\n   */\n  _storage: HeartbeatStorageImpl;\n\n  /**\n   * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n   * the header string.\n   * Stores one record per date. This will be consolidated into the standard\n   * format of one record per user agent string before being sent as a header.\n   * Populated from indexedDB when the controller is instantiated and should\n   * be kept in sync with indexedDB.\n   * Leave public for easier testing.\n   */\n  _heartbeatsCache: HeartbeatsInIndexedDB | null = null;\n\n  /**\n   * the initialization promise for populating heartbeatCache.\n   * If getHeartbeatsHeader() is called before the promise resolves\n   * (hearbeatsCache == null), it should wait for this promise\n   * Leave public for easier testing.\n   */\n  _heartbeatsCachePromise: Promise<HeartbeatsInIndexedDB>;\n  constructor(private readonly container: ComponentContainer) {\n    const app = this.container.getProvider('app').getImmediate();\n    this._storage = new HeartbeatStorageImpl(app);\n    this._heartbeatsCachePromise = this._storage.read().then(result => {\n      this._heartbeatsCache = result;\n      return result;\n    });\n  }\n\n  /**\n   * Called to report a heartbeat. The function will generate\n   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n   * to IndexedDB.\n   * Note that we only store one heartbeat per day. So if a heartbeat for today is\n   * already logged, subsequent calls to this function in the same day will be ignored.\n   */\n  async triggerHeartbeat(): Promise<void> {\n    const platformLogger = this.container\n      .getProvider('platform-logger')\n      .getImmediate();\n\n    // This is the \"Firebase user agent\" string from the platform logger\n    // service, not the browser user agent.\n    const agent = platformLogger.getPlatformInfoString();\n    const date = getUTCDateString();\n    if (this._heartbeatsCache === null) {\n      this._heartbeatsCache = await this._heartbeatsCachePromise;\n    }\n    // Do not store a heartbeat if one is already stored for this day\n    // or if a header has already been sent today.\n    if (\n      this._heartbeatsCache.lastSentHeartbeatDate === date ||\n      this._heartbeatsCache.heartbeats.some(\n        singleDateHeartbeat => singleDateHeartbeat.date === date\n      )\n    ) {\n      return;\n    } else {\n      // There is no entry for this date. Create one.\n      this._heartbeatsCache.heartbeats.push({ date, agent });\n    }\n    // Remove entries older than 30 days.\n    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(\n      singleDateHeartbeat => {\n        const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n        const now = Date.now();\n        return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n      }\n    );\n    return this._storage.overwrite(this._heartbeatsCache);\n  }\n\n  /**\n   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n   * It also clears all heartbeats from memory as well as in IndexedDB.\n   *\n   * NOTE: Consuming product SDKs should not send the header if this method\n   * returns an empty string.\n   */\n  async getHeartbeatsHeader(): Promise<string> {\n    if (this._heartbeatsCache === null) {\n      await this._heartbeatsCachePromise;\n    }\n    // If it's still null or the array is empty, there is no data to send.\n    if (\n      this._heartbeatsCache === null ||\n      this._heartbeatsCache.heartbeats.length === 0\n    ) {\n      return '';\n    }\n    const date = getUTCDateString();\n    // Extract as many heartbeats from the cache as will fit under the size limit.\n    const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(\n      this._heartbeatsCache.heartbeats\n    );\n    const headerString = base64urlEncodeWithoutPadding(\n      JSON.stringify({ version: 2, heartbeats: heartbeatsToSend })\n    );\n    // Store last sent date to prevent another being logged/sent for the same day.\n    this._heartbeatsCache.lastSentHeartbeatDate = date;\n    if (unsentEntries.length > 0) {\n      // Store any unsent entries if they exist.\n      this._heartbeatsCache.heartbeats = unsentEntries;\n      // This seems more likely than emptying the array (below) to lead to some odd state\n      // since the cache isn't empty and this will be called again on the next request,\n      // and is probably safest if we await it.\n      await this._storage.overwrite(this._heartbeatsCache);\n    } else {\n      this._heartbeatsCache.heartbeats = [];\n      // Do not wait for this, to reduce latency.\n      void this._storage.overwrite(this._heartbeatsCache);\n    }\n    return headerString;\n  }\n}\n\nfunction getUTCDateString(): string {\n  const today = new Date();\n  // Returns date format 'YYYY-MM-DD'\n  return today.toISOString().substring(0, 10);\n}\n\nexport function extractHeartbeatsForHeader(\n  heartbeatsCache: SingleDateHeartbeat[],\n  maxSize = MAX_HEADER_BYTES\n): {\n  heartbeatsToSend: HeartbeatsByUserAgent[];\n  unsentEntries: SingleDateHeartbeat[];\n} {\n  // Heartbeats grouped by user agent in the standard format to be sent in\n  // the header.\n  const heartbeatsToSend: HeartbeatsByUserAgent[] = [];\n  // Single date format heartbeats that are not sent.\n  let unsentEntries = heartbeatsCache.slice();\n  for (const singleDateHeartbeat of heartbeatsCache) {\n    // Look for an existing entry with the same user agent.\n    const heartbeatEntry = heartbeatsToSend.find(\n      hb => hb.agent === singleDateHeartbeat.agent\n    );\n    if (!heartbeatEntry) {\n      // If no entry for this user agent exists, create one.\n      heartbeatsToSend.push({\n        agent: singleDateHeartbeat.agent,\n        dates: [singleDateHeartbeat.date]\n      });\n      if (countBytes(heartbeatsToSend) > maxSize) {\n        // If the header would exceed max size, remove the added heartbeat\n        // entry and stop adding to the header.\n        heartbeatsToSend.pop();\n        break;\n      }\n    } else {\n      heartbeatEntry.dates.push(singleDateHeartbeat.date);\n      // If the header would exceed max size, remove the added date\n      // and stop adding to the header.\n      if (countBytes(heartbeatsToSend) > maxSize) {\n        heartbeatEntry.dates.pop();\n        break;\n      }\n    }\n    // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n    // quota and the loop breaks early.)\n    unsentEntries = unsentEntries.slice(1);\n  }\n  return {\n    heartbeatsToSend,\n    unsentEntries\n  };\n}\n\nexport class HeartbeatStorageImpl implements HeartbeatStorage {\n  private _canUseIndexedDBPromise: Promise<boolean>;\n  constructor(public app: FirebaseApp) {\n    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n  }\n  async runIndexedDBEnvironmentCheck(): Promise<boolean> {\n    if (!isIndexedDBAvailable()) {\n      return false;\n    } else {\n      return validateIndexedDBOpenable()\n        .then(() => true)\n        .catch(() => false);\n    }\n  }\n  /**\n   * Read all heartbeats.\n   */\n  async read(): Promise<HeartbeatsInIndexedDB> {\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return { heartbeats: [] };\n    } else {\n      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n      return idbHeartbeatObject || { heartbeats: [] };\n    }\n  }\n  // overwrite the storage with the provided heartbeats\n  async overwrite(heartbeatsObject: HeartbeatsInIndexedDB): Promise<void> {\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return;\n    } else {\n      const existingHeartbeatsObject = await this.read();\n      return writeHeartbeatsToIndexedDB(this.app, {\n        lastSentHeartbeatDate:\n          heartbeatsObject.lastSentHeartbeatDate ??\n          existingHeartbeatsObject.lastSentHeartbeatDate,\n        heartbeats: heartbeatsObject.heartbeats\n      });\n    }\n  }\n  // add heartbeats\n  async add(heartbeatsObject: HeartbeatsInIndexedDB): Promise<void> {\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return;\n    } else {\n      const existingHeartbeatsObject = await this.read();\n      return writeHeartbeatsToIndexedDB(this.app, {\n        lastSentHeartbeatDate:\n          heartbeatsObject.lastSentHeartbeatDate ??\n          existingHeartbeatsObject.lastSentHeartbeatDate,\n        heartbeats: [\n          ...existingHeartbeatsObject.heartbeats,\n          ...heartbeatsObject.heartbeats\n        ]\n      });\n    }\n  }\n}\n\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nexport function countBytes(heartbeatsCache: HeartbeatsByUserAgent[]): number {\n  // base64 has a restricted set of characters, all of which should be 1 byte.\n  return base64urlEncodeWithoutPadding(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })\n  ).length;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Component, ComponentType } from '@firebase/component';\nimport { PlatformLoggerServiceImpl } from './platformLoggerService';\nimport { name, version } from '../package.json';\nimport { _registerComponent } from './internal';\nimport { registerVersion } from './api';\nimport { HeartbeatServiceImpl } from './heartbeatService';\n\nexport function registerCoreComponents(variant?: string): void {\n  _registerComponent(\n    new Component(\n      'platform-logger',\n      container => new PlatformLoggerServiceImpl(container),\n      ComponentType.PRIVATE\n    )\n  );\n  _registerComponent(\n    new Component(\n      'heartbeat',\n      container => new HeartbeatServiceImpl(container),\n      ComponentType.PRIVATE\n    )\n  );\n\n  // Register `app` package.\n  registerVersion(name, version, variant);\n  // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n  registerVersion(name, version, '__BUILD_TARGET__');\n  // Register platform SDK identifier (no version).\n  registerVersion('fire-js', '');\n}\n", "/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { registerCoreComponents } from './registerCoreComponents';\n\nexport * from './api';\nexport * from './internal';\nexport * from './public-types';\n\nregisterCoreComponents('__RUNTIME_ENV__');\n"],
  "mappings": "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",
  "names": ["name", "LogLevel", "name", "instance", "name", "version", "target", "DEFAULT_ENTRY_NAME", "appName", "appCompatName", "analyticsName", "analyticsCompatName", "appCheckName", "appCheckCompatName", "authName", "authCompatName", "databaseName", "databaseCompatName", "functionsName", "functionsCompatName", "installationsName", "installationsCompatName", "messagingName", "messagingCompatName", "performanceName", "performanceCompatName", "remoteConfigName", "remoteConfigCompatName", "storageName", "storageCompatName", "firestoreName", "firestoreCompatName", "packageName", "name", "version", "setLogLevel", "setLogLevelImpl"]
}
